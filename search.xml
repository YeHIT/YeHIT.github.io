<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实际开发遇到问题及方案</title>
    <url>/2021/03/23/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E5%8F%8A%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="实际开发遇到问题及方案">实际开发遇到问题及方案</h1>
<h2 id="什么是内存泄漏怎么确定内存泄漏">什么是内存泄漏，怎么确定内存泄漏</h2>
<blockquote>
<p>简单来说内存泄漏就是使用了内存空间后，在不使用的情况下没有及时的释放对应空间。</p>
<p>在Java中虽然存在GC机制，但有时也有产生内存泄漏的现象。</p>
<p>​ 如：使用ThreadLocal、使用静态集合类引用数据、使用单例模式创建的对象引用的过多对象。</p>
<p>Java确定内存泄漏的方式：</p>
<p>​ 如果内存泄漏了一般来说会频繁触发GC，可以先使用linux的top指令查看当前java进程具体情况，如果频繁GC往往会导致CPU使用率异常。</p>
<p>​ 如果确认异常，再通过jmap指令生成dump文件，用于之后查看。</p>
<p>​ 通过jstat查看当前虚拟机情况，主要观察GC频率。</p>
<p>​ 使用jhat或者其他可视化工具分析dump文件，找到对应内存使用巨大的类。</p>
<p>​ 找到类后，分析具体代码解决问题即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>3.常用工具</title>
    <url>/2021/03/21/JVMKnowledge/3.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="常用工具">常用工具</h1>
<h2 id="jps">jps</h2>
<blockquote>
<p>jps用于列出正在运行的虚拟机进程，并显示虚拟机执行主类名称及这些进程的本地虚拟机唯一ID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/03/21/JVMKnowledge/3.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/jps.png" alt="jps"><figcaption aria-hidden="true">jps</figcaption>
</figure>
</blockquote>
<h2 id="jstat">jstat</h2>
<blockquote>
<p>jstat用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或远程虚拟机进程中类加载、内存、垃圾收集、即时编译等运行时数据。</p>
<p>往往通过jps找出对应进程本地虚拟机唯一ID，加上对应参数来查看具体虚拟机信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure>
<p>如<img src="/2021/03/21/JVMKnowledge/3.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/jstat.png" alt="jstat"></p>
</blockquote>
<h2 id="jinfo">jinfo</h2>
<blockquote>
<p>jinfo的作用是实时查看和调整虚拟机各项参数。</p>
<p>jinfo + jps查看的唯一ID：打印全部配置信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jinfo [ option ] pid</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/03/21/JVMKnowledge/3.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/jinfo.png" alt="jinfo"><figcaption aria-hidden="true">jinfo</figcaption>
</figure>
</blockquote>
<h2 id="jmap">jmap</h2>
<blockquote>
<p>Java内存映像工具，jmap命令用于生成堆转储快照即heap dump/dump文件。</p>
<p>jmap作用除了获取堆转储快照之外，还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前使用的收集器等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jmap [ option ] vmid</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/03/21/JVMKnowledge/3.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/jmap.png" alt="jmap"><figcaption aria-hidden="true">jmap</figcaption>
</figure>
</blockquote>
<h2 id="jhat">jhat</h2>
<blockquote>
<p>jhat一般是同jmap配合使用，通过jhat命令可以分析jmap产生的堆转储快照。一般不用这个指令，因为jhat耗时久且有更好用的工具可以用于分析dump文件。</p>
</blockquote>
<h2 id="jstack">jstack</h2>
<blockquote>
<p>jstack命令用于生成虚拟机当前时刻的线程快照(threaddump/javacore文件)。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成快照的目的通常是定位线程出现长时间停顿的原因：如死锁、死循环、请求外部资源导致长时间挂起等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstack [ option ] vmid</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/03/21/JVMKnowledge/3.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/jstack.png" alt="jstack"><figcaption aria-hidden="true">jstack</figcaption>
</figure>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>4.虚拟机执行子系统</title>
    <url>/2021/03/21/JVMKnowledge/4.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="虚拟机执行子系统">虚拟机执行子系统</h1>
<h2 id="class文件">Class文件</h2>
<blockquote>
<p>Java虚拟机不和包括Java语言在内的任何语言绑定，它只和Class文件这种特点的二进制文件格式所关联。任何其他语言如果可以将语言编译成class文件支持的形式，那么他们都可以将Java虚拟机作为他们语言运行基础。</p>
<p><strong>class文件是一组以8个字节为基础单位的二进制流</strong>，各个数据项目严格按照顺序紧凑地排列在文件之中，之间没有任何分隔符。当遇到需要占用8个以上字节空间的数据时会以高为在前的方式分割成若干个字节进行存储。class文件格式只有两种数据类型：<strong>无符号数和表</strong>。描述同一类型但数量不定的多个数据时，经常使用一个前置的容量计数器加若干个连续的数据项的形式。</p>
</blockquote>
<h2 id="class文件格式">Class文件格式</h2>
<h3 id="魔数和class文件的版本">魔数和Class文件的版本</h3>
<blockquote>
<p>每个Class文件的头四个字节被称为魔数，唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件。</p>
<p>魔数后的四个字节存储的是Class文件的版本号：第5、6个字节是次版本号，7、8个字节是主版本号。</p>
<p>Java版本号是从45开始的，JDK1.1后每个JDK大版本发布主版本号向上加1，高版本的JDK可以向下兼容之前版本的Class文件，但不能运行之后版本的Class文件。</p>
</blockquote>
<h3 id="常量池">常量池</h3>
<blockquote>
<p>主、次版本号后的是常量池入口，常量池可以比作Class文件里的资源仓库，是Class文件结构中与其他项目关联最多的数据。常量池入口处往往放置一个u2类型的数据，来代表常量池容量计数值。可以通过<strong>javap</strong>命令输出常量表。</p>
</blockquote>
<h3 id="其他详细内容省略">其他详细内容省略</h3>
<h2 id="虚拟机类加载机制">虚拟机类加载机制</h2>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<p>Java语言里，类型的加载、连接、初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译面临额外的困难，也让类加载时稍微增加一些性能开销，但提供了极高的拓展性和灵活性。</p>
</blockquote>
<h3 id="类的生命周期">类的生命周期</h3>
<figure>
<img src="/2021/03/21/JVMKnowledge/4.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/类的生命周期.png" alt="类的生命周期"><figcaption aria-hidden="true">类的生命周期</figcaption>
</figure>
<blockquote>
<p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。</p>
<p><strong>立即初始化的情况</strong>：</p>
<p>​ 1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：</p>
<p>​ 使用new关键字实例化对象。</p>
<p>​ 读取或设置一个类型的静态字段(被final修饰、在编译期把结果放入常量池的静态字段除外)。</p>
<p>​ 调用一个类型的静态方法时。</p>
<p>​ 2）使用反射调用时，若没有对类型进行初始化，则需要先触发初始化。</p>
<p>​ 3）初始化类时，若发现其父类没有进行初始化，先触发父类的初始化。</p>
<p>​ 4）虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类。</p>
<p>​ 5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
<p>​ 6）当接口定义了JDK8的默认方法时，初始化这个接口的实现类时需要先初始化接口。</p>
</blockquote>
<h3 id="类加载的全过程">类加载的全过程</h3>
<h4 id="加载">加载</h4>
<blockquote>
<p>Java虚拟机需要：</p>
<p>​ 通过一个类的全限定名获取定义此类的二进制字节流。</p>
<p>​ 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>​ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
</blockquote>
<h4 id="验证">验证</h4>
<blockquote>
<p>主要校验二进制流的安全性。主要分为：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
</blockquote>
<h4 id="其他省略">其他省略</h4>
<h2 id="类加载器">类加载器</h2>
<blockquote>
<p>类加载中“<strong>通过一个类全限定名获取描述该类的二进制字节流</strong>”的动作放到Java虚拟机外部实现，以便让应用程序自己决定如何获取所需的类。实现这个动作的代码被称为<strong>类加载器</strong>。</p>
<p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java性能机中的唯一性，每个类加载器都有一个独立的类名称空间。判断类相等首先需要判断两个类是否是同一个类加载器加载的。</p>
</blockquote>
<h4 id="双亲委派模型">双亲委派模型</h4>
<blockquote>
<p>Java虚拟机中只存在两种不同的类加载器：一个是<strong>启动类加载器</strong>，这个类加载器使用C++语言实现，是虚拟机自身的一部分。另一种就是<strong>其他所有的类加载器</strong>，它们都是由Java语言实现，独立存在于虚拟机外部，且全部继承与抽象类java.lang.ClassLoader</p>
<p>对Java类加载器的细分：</p>
<p>​ <strong>启动类加载器(Bootstrap Class Loader)</strong>：这个类加载器负责加载存放在<JAVA_HOME>，或被-Xbootclasspath参数所指定的路径中存放的且Java虚拟机可识别的类库。该加载器不能被Java程序直接引用，当编写自定义类加载器时，需要把请求委托给启动类加载器实现的话通过null代替。</JAVA_HOME></p>
<p>​ <strong>扩展类加载器(Extension Class Loader)</strong>：负责加载<JAVA_HOME>.ext.dirs系统变量所指定的路径中所有的类库。</JAVA_HOME></p>
<p>​ <strong>应用程序类加载器(Application Class Loader)</strong>：也叫<strong>系统类加载器</strong>，负责加载用户类路径(classpath)上的所有类库，开发者可以直接在代码中使用这个类加载器。</p>
<figure>
<img src="/2021/03/21/JVMKnowledge/4.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/类加载器双亲委派.png" alt="类加载器双亲委派"><figcaption aria-hidden="true">类加载器双亲委派</figcaption>
</figure>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载 器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
<p>其工作流程是：当一个类加载器收到类加载请求时，先不会自己去尝试加载，而是把这个请求委托给父类加载器去完成。所有的加载请求最终都应该到启动类加载器中加载，只有当父加载器无法完成这个加载请求时才会由子加载器加载。</p>
</blockquote>
<h4 id="双亲委派模型的优点">双亲委派模型的优点</h4>
<blockquote>
<p>Java中的类随着它的类加载器一起具备了带有优先级的层次关系。如Object类，存放在rt.jar中，无论哪个类加载器要加载这个类，最终都是通过启动类加载器加载的，因此Object类在程序的各种类加载器环境中都可以保证是同一个类。</p>
<p>若没有双亲委派机制，都通过各个类加载器自行加载，那么可能发生加载了多个不同的Object类，使得Java基础类体系被破坏。</p>
<p>双亲委派模型的具体代码：本质上就是只有当父类加载器无法加载，再由子类加载器加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123; </span><br><span class="line">    <span class="comment">// 首先，检查请求的类是否已经被加载过了 </span></span><br><span class="line">    Class c = findLoadedClass(name); </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; </span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                c = findBootstrapClassOrNull(name); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">            <span class="comment">// 如果父类加载器抛出ClassNotFoundException </span></span><br><span class="line">            <span class="comment">// 说明父类加载器无法完成加载请求 </span></span><br><span class="line">        &#125;<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 在父类加载器无法加载时 </span></span><br><span class="line">            <span class="comment">// 再调用本身的findClass方法来进行类加载 </span></span><br><span class="line">            c = findClass(name); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双亲委派模型被破坏的情况">双亲委派模型被破坏的情况</h4>
</blockquote>
<blockquote>
<p>第一次被破坏发生在双亲委派模型出现前。双亲委派模型在JDK1.2之后被引入，类加载器和抽象类ClassLoader在Java第一个版本就出现。</p>
<p><strong>解决措施</strong>：为兼容已有代码，在JDK1.2后的ClassLoader方法中添加一个protected方法findClass()，引导用户编写的类加载逻辑时尽可能重写该方法，而不是在loadClass中编写代码。使得符合双亲委派模型。</p>
<p>双亲委派模型第二次被破坏是这个模型自身缺陷导致的，双亲委派模型很好地解决了各个类加载器协作时基础类型的一致性问题(越基础的类由越上层的加载器进行加载)。但是当基础类型需要调用用户代码时如何解决呢？如<strong>JNDI服务</strong>，代码是由启动类加载器完成加载，但JNDI的存在目的是对资源进行查找和集中管理，需要调用其他厂商实现并部署在应用程序ClassPath下的JNDI服务提供者接口代码。</p>
<p><strong>解决措施</strong>：Java设计者引入了<strong>线程上下文类加载器</strong>，这个类加载器通过java.lang.Thread类的setContext-ClassLoader()方法进行设置。若创建线程时未设置，会从父线程中继承，若应用程序全局范围内都为设置，则默认为<strong>应用程序类加载器</strong>。而利用线程上下文类加载器，JNDI服务使用该加载器去加载所需的SPI服务代码，即父类加载器去请求子类加载器完成类加载的行为。</p>
<p>双亲委派模型的第三次被破坏是由于用户对程序动态性的追求而导致的，如OSGi，为了实现模块化热部署，它设计了一种复杂的网状结构去进行类加载。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式突击</title>
    <url>/2021/03/18/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="分布式突击">分布式突击</h1>
<h2 id="分布式怎么进行数据切分访问">分布式怎么进行数据切分访问？</h2>
<blockquote>
<p>显然分布式服务中，必然存在服务集群，一般而言是怎么访问这些集群的呢？往往使用hash来将用户划分到不同的区域，以简单的hash函数为例：</p>
<p>​ 假设存在6台服务器，此时采用的hash函数为(key)%6，这样选择对应的服务器。显然是可以实现功能的。当如果服务器的数量突然减少或增加了，此时hash函数将要变化，而这时原有的映射关系将直接无用。怎么解决这个问题呢？<strong>一致性hash！</strong></p>
<p><strong>一致性hash算法</strong></p>
<p>​ 即使用2^32作为取模的数，将整个区域视为一个圆环，先对服务器进行哈希处理，让其发布在圆环的不同位置，然后当有请求到来时，对请求进行哈希处理，此时会发现请求也落在圆环的某个位置，然后沿顺时针查找该位置离哪个服务器最近，即可找到对应提供服务的服务器。此时若需要添加服务器，只需往圆环上添加新位置即可，只需局部调整，无须全部更新。</p>
<figure>
<img src="/2021/03/18/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AA%81%E5%87%BB/一致性哈希环.png" alt="一致性哈希环"><figcaption aria-hidden="true">一致性哈希环</figcaption>
</figure>
<p>​ 当然这样有时会导致某些数据累积在同一台服务器上，一致性hash为了解决这个问题引入了虚拟节点机制，即用一个服务器结点计算多次哈希，在每个计算位置放置服务器结点，以保障数据可以比较合理的分布。</p>
<p>一些分布式集群使用一致性hash(或类似原理)的场景：</p>
<p>​ redis cluster：类似于一致性hash的思想，对于redis集群采用哈希槽的设计思想，即redis cluster有固定的16384即16K个哈希槽(因为16384个槽在传递配置信息时只需要传输2k的位图，16k/ 8bit = 2k，且16k大小的槽足够redis集群使用了)，对请求进行哈希操作时使用16384作为模数，让请求分布到槽中，而每个主机会负责管理一部分的槽。在进行主机的切换拓展时可以通过指定哪个槽由哪个主机负责来实现拓展和移除主机。</p>
</blockquote>
<h2 id="分布式集群怎么选主">分布式集群怎么选主？</h2>
<blockquote>
<p>分布式集群中往往需要一个主进行管理操作，一般是通过主进行写操作，通过从机进行读操作。</p>
<p>选主的算法：<strong>基于序号的选主算法(Bully算法)</strong>、<strong>多数派选主算法(Raft和ZAB算法)</strong></p>
</blockquote>
<h3 id="bully算法">Bully算法</h3>
<blockquote>
<p>选主过程主要分为三种消息</p>
<table>
<thead>
<tr class="header">
<th><strong>#</strong></th>
<th><strong>消息类型</strong></th>
<th><strong>消息描述</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Election消息</td>
<td>用于发起选举</td>
</tr>
<tr class="even">
<td>2</td>
<td>Alive消息</td>
<td>对Election消息的应答</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Victory</td>
<td>竞选成功的节点向其他节点宣誓主权</td>
</tr>
</tbody>
</table>
<p>触发选举的时机有两个：</p>
<p>​ 错误结点恢复。</p>
<p>​ 检测到master节点故障。</p>
<p>选举过程：</p>
<p>​ 1.各节点都判断自己的ID是否最大，若是最大的则直接向其他结点发送Victory消息。</p>
<p>​ 2.若自己不是当前存活的结点中ID最大的，需要向比自己大的结点发送Election消息。</p>
<p>​ 3.在规定时间内若没有收到任何结点的Alive消息，则会认为自己为最大的结点，并像其他结点发送Victory消息。若收到比自己大的结点的Alive消息，则会等待收到最大结点的Victory消息。</p>
<p>​ 4.若收到了比自己小的节点发来的Election消息，则会回复Alive消息。</p>
<p>优点：选举速度快、算法复杂度低、实现简单。</p>
<p>缺点：所有节点需要每个节点的相关信息，需要额外信息存储。</p>
<p>​ 若一个ID比现有集群的master大的结点加入，且不稳定即频繁退出、加入，会导致当前集群频繁进行选主。</p>
</blockquote>
<h3 id="raft算法---投票">Raft算法---投票</h3>
<blockquote>
<p>Etcd使用raft算法。</p>
<p>raft集群各角色：</p>
<table>
<thead>
<tr class="header">
<th>角色</th>
<th><strong>角色描述</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Leader</strong></td>
<td>主节点，同一时刻只有一个主节点，负责整个集群的协调和管理</td>
</tr>
<tr class="even">
<td><strong>Candidate</strong></td>
<td>候选节点，只有候选节点才可以被选为新Leader，每个节点都可能成为候选节点</td>
</tr>
<tr class="odd">
<td><strong>Follower</strong></td>
<td>Leader的追随者，该角色不能发起选主</td>
</tr>
</tbody>
</table>
<p>触发选主时机：</p>
<p>​ Leader故障或任期满。</p>
<p><strong>数据提交流程</strong>：</p>
<p>​ Leader收到数据操作请求时，先产生对应log，然后把log的请求发送给各个Follower。每个follower收到请求后会选择是否听从命令，听从返回true，反对返回false。当超过半数的follower成功写log，leader则开始第二阶段的提交，正式写入数据，然后也给其follower发送请求，当超过半数follower成功写入数据，该请求才正式完成。若这两个步骤其中某个步骤没有超过半数的follower成功执行，则这个事务不成功。</p>
<p><strong>选主流程</strong>：</p>
<figure>
<img src="/2021/03/18/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AA%81%E5%87%BB/Users\SmallYe\Desktop\blog\source_posts\面试突击\分布式突击\raft选主.png" alt="raft选主"><figcaption aria-hidden="true">raft选主</figcaption>
</figure>
<p>初始化时各个结点均为Follower，每个Follower内部维护了一个随机的timer。timer时间到了没有人主动联系时就会变为candidate。</p>
<p>当出现candidate节点时，candidate节点会发送请求给follower节点，每个follower节点只能投一张票。</p>
<p>对于相同情况的candidate，follower按照先来先投票的策略投票。</p>
<p>发起选主的结点若得到一半以上的结点，则会成为主节点，状态变为Leader，其他结点会由Candidate变为Follower状态，此时Leader和Follower通过心跳保持连接。当follower接收到心跳信号时会刷新内部timer。</p>
<p>若Leader任期到了，Leader会降为Follower，进行新一轮选主。</p>
<p><strong>选主可能的问题</strong></p>
<p>​ 当参选的candidate内部数据是缺失/错误的时，如何解决冲突？</p>
<p>​ 1.可以当candidate变为Leader前，从所有的follower处获取数据。</p>
<p>​ 2.当follower遇见这种candidate时不投票给他。(Raft选择的做法)。</p>
<p>​ Raft具体解决方案：</p>
<p>​ 在candidate请求被投票时会传递term、lastLogIndex、lastLogTerm三个信息。</p>
<table>
<thead>
<tr class="header">
<th>参数名</th>
<th>参数含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>term</strong></td>
<td>自身所处的选举周期</td>
</tr>
<tr class="even">
<td><strong>lastLogIndex</strong></td>
<td>log最新的index值</td>
</tr>
<tr class="odd">
<td><strong>lastLogTerm</strong></td>
<td>log中最近的index是在哪个term产生的</td>
</tr>
</tbody>
</table>
<p>​ 投票结点内部会维护currentTerm，节点自身所处term。log[]自身log集合。commitIndex，log中最后被提交的index值。</p>
<p>​ 当term&lt;currentTrem时，拒绝投票。</p>
<p>​ 当已经投票给其他结点时，拒绝投票。</p>
<p>​ log匹配时，投票。</p>
<p><strong>优点</strong>：选举速度快，算法复杂度低，易于实现。新结点加入时不会频繁切主，需要得到半数以上支持才会切主。</p>
<p><strong>缺点</strong>：通信量大。</p>
</blockquote>
<h3 id="zab算法----优先级的民主投票">ZAB算法 -- 优先级的民主投票</h3>
<blockquote>
<p>ZAB是Zookeeper实现分布式协调而设计的。是对Raft算法的一种改进。</p>
<p>ZAB选主的角色：</p>
<p>​ Leader：主节点。</p>
<p>​ Follower：跟随者。</p>
<p>​ Observer：观察者。</p>
<p>ZAB选举过程中，集群节点的状态：</p>
<table>
<thead>
<tr class="header">
<th>状态</th>
<th><strong>状态描述</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Looking</strong></td>
<td>选举状态，此状态下集群中没有Leader，自己进入选主状态。</td>
</tr>
<tr class="even">
<td><strong>Leading</strong></td>
<td>领导者状态，已选好主且当前结点为Leader</td>
</tr>
<tr class="odd">
<td><strong>Following</strong></td>
<td>追随者状态，选为Leader后，其他结点转为Following</td>
</tr>
<tr class="even">
<td><strong>Observing</strong></td>
<td>观察者状态，持观望态度</td>
</tr>
</tbody>
</table>
<p>ZAB算法的每个结点都有唯一三元组(server_id，server_zxId，epoch)表示。server_id为当前节点的ID，server_zxId为当前节点存放数据的最新值id，epoch为当前选主进行的轮数。</p>
<p>具体选主时通过(vote_id，vote_zxId)表示投票给哪个节点，选主唯一原则是server_zxId值最大则成为Leader，如果相同则看server_id最大值。</p>
<p><strong>具体选主流程：</strong></p>
<p>​ 1.系统初始化时，即第一轮选主，epoch=1，所有节点zxID=0，此时所有节点都推选自己，将投票信息广播出去。</p>
<p>​ 2.此时epoch和zxId都是相同的，根据ZAB算法判断，会依据server_id最大者为推选对象，节点更新vote_id重新广播。</p>
<p>​ 3.节点都推选了server_id最大者后，该节点进入Leading状态，其他结点为Following状态，Leader和Follower建立心跳机制。</p>
<p>优点：对系统无特殊要求。</p>
<p>缺点：选举时间长，复杂度高。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计突击</title>
    <url>/2021/03/18/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="系统设计突击">系统设计突击</h1>
<h2 id="如何设计微博关注功能即feed流设计">如何设计微博关注功能？即Feed流设计</h2>
<blockquote>
<p>该问题主要看产品类型，具体分类如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">类型</th>
<th style="text-align: left;">关注关系</th>
<th style="text-align: left;">是否有大V</th>
<th style="text-align: left;">时效性</th>
<th style="text-align: left;">排序</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">微博类</td>
<td style="text-align: left;">单向</td>
<td style="text-align: left;">有</td>
<td style="text-align: left;">秒~分</td>
<td style="text-align: left;">时间</td>
</tr>
<tr class="even">
<td style="text-align: left;">抖音类</td>
<td style="text-align: left;">单向/无</td>
<td style="text-align: left;">有</td>
<td style="text-align: left;">秒~分</td>
<td style="text-align: left;">推荐</td>
</tr>
<tr class="odd">
<td style="text-align: left;">朋友圈类</td>
<td style="text-align: left;">双向</td>
<td style="text-align: left;">无</td>
<td style="text-align: left;">秒</td>
<td style="text-align: left;">时间</td>
</tr>
<tr class="even">
<td style="text-align: left;">私信类</td>
<td style="text-align: left;">双向</td>
<td style="text-align: left;">无</td>
<td style="text-align: left;">秒</td>
<td style="text-align: left;">时间</td>
</tr>
</tbody>
</table>
<p>微博关注功能的主要难点在于，一个用户的粉丝数可能十分巨大，导致消息如何推送是一个问题。</p>
<p>常见的设计方法：</p>
<p>​ 首先将数据库分为，存储库和关系库。</p>
<p>​ 存储库需要可靠存储用户的消息，不能丢失。需要能够支持读取某个人分布的所有消息。支持数据永久存储。</p>
<p>​ 技术选型主要考虑关系型数据库Mysql或Nosql。其中Nosql水平拓展能力较高，方便在数据量巨大时的使用。</p>
<p>​ 存储的信息往往可以是userID和messageID。</p>
<p>​ 关系库则是用于存储用户之间的关系的。</p>
<p><strong>数据的同步方式即用户怎么接收推送的？</strong></p>
<p>​ 1.推模式(写扩散)：发送者发送一个消息后，立即将消息推送给发送者，此时发送者不一定在线，需要将消息同步到一个同步库中。一条消息要发送给多个粉丝所以需要复制多份，要求数据库支持大量写请求。用户上线时只需要读取自己的数据库，找到消息即可。</p>
<p>​ 2.拉模式(读扩散)：这是一种拉的方式，即发送者发送消息后，数据只写入自己对应的数据库，然后用户上线时直接从自己的数据库中读取，此时消息的写入操作仅一次，消息的读取操作次数最多会达到最大粉丝数。因此这种设计要求数据库要有极强的读能力。但是这种设计存在一个问题，即每个用户需要记录自己上次读到了关注者的哪条消息，若关注者数量大，则需要占用大量空间存储该数据。</p>
<p>​ 3.推拉结合模式：推模式在单向关系中因为存在大V，一天消息写扩散可能几百万次。而这些用户可能一大半都是僵尸用户，永远不会上线。存在资源浪费。而拉模式需要记录上次读取消息的位置，架构比较复杂。因此往往设计为普通用户使用推模式，大V使用拉模式，这样平衡架构复杂性和资源使用。</p>
<p><strong>其他具体功能设计见https://developer.aliyun.com/article/706808</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>查缺补漏</title>
    <url>/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E5%A5%87%E6%80%AA%E7%9A%84%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/</url>
    <content><![CDATA[<h1 id="查缺补漏">查缺补漏</h1>
<h2 id="git的rebase和merge有什么区别">git的rebase和merge有什么区别？</h2>
<blockquote>
<p>生成的代码树有区别。git merge的代码树可以精准地看到每次提交，合并时会产生一个合并点，且还保留先前提交的具体信息。</p>
<p>git rebase的代码树比较简单。会忽略每个子分支的具体提交，只留下合并点。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql突击</title>
    <url>/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="mysql突击">Mysql突击</h1>
<h2 id="基础知识">基础知识</h2>
<h3 id="基本sql语句">基本sql语句</h3>
<h4 id="dml数据操作语言">DML(数据操作语言)</h4>
<blockquote>
<p><em>SELECT</em> 、UPDATE、DELETE、INSERT INTO</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查找记录，可以附带条件语句，和分页语句</span><br><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[LIMIT N][<span class="keyword">OFFSET</span> M]</span><br></pre></td></tr></table></figure>
<p>INSERT INTO TABLE_NAME (field1,field2,.....) VALUES(值1,值2,.....)</p>
<p>UPDATE TABLE_NAME SET COL = XXX WHERE COL = YYY 更改表数据</p>
<p>DELETE FROM TABLE_NAME WHERE COL = XXX 删去表中的行</p>
</blockquote>
<h4 id="ddl数据定义语言">DDL(数据定义语言)</h4>
<blockquote>
<p>CREATE DATABASE 数据库名：创建数据库</p>
<p>DROP DATABASE 数据库名：删除数据库</p>
<p>USE DATABASE 数据库名：选用数据库</p>
<p>ALTER DATABASE：变更数据库</p>
<p>CREATE TABLE 表名(列名 列类型，......)：创建数据库表</p>
<p>DROP TABLE;删除表</p>
<p>ALTER TABLE TABLE_NAME DROP COL：删去表格对应列。</p>
<p>ALTER TABLE TABLE_NAME ADD COL TYPE：在表格中增加对应列。</p>
<p>ALTER TABLE TABLE_NAME MODIFY COL TYPE：修改表格中对应列类型</p>
<p>ALTER TABLE TABLE_NAME CHANGE COL1 COL2 TYPE：将表格中COL1列改为COL2列，且指定为TYPE类型</p>
<p>CREATE INDEX;创建索引</p>
<p>DROP INDEX;删除索引</p>
</blockquote>
<h3 id="mysql数据类型">Mysql数据类型</h3>
<blockquote>
<p>数值类型：</p>
<p>​ TINYINT：1个byte 8位</p>
<p>​ SMALLINT：2个bytes 16位</p>
<p>​ MEDIUMINT：3个bytes 24位</p>
<p>​ INT/INTEGER：4bytes 32位</p>
<p>​ BIGINT：8bytes 64位</p>
<p>​ FLOAT：4bytes 32位 单精度浮点数</p>
<p>​ DOUBLE：8bytes 64位 双精度浮点数</p>
<p>​ DECIMAL(a,b)：a指定整数位数，b指定小数位数，适用于高精度场景。默认值10,0</p>
<p>日期和时间类型：</p>
<p>​ DATE：3bytes，格式YYYY-MM-DD，存储日期值</p>
<p>​ TIME：3bytes，格式HH:MM:SS，存储时间值</p>
<p>​ YEAR：1byte，格式YYYY，年份值</p>
<p>​ DATETIME：8bytes，格式YYYY-MM-DD HH:MM:SS，混合了日期和时间值</p>
<p>​ TIMESTAMP：4bytes，存储时间戳。比DATETIME空间效率更高，但是表示的时间范围小。</p>
<p>字符串类型：</p>
<p>​ CHAR：0~255bytes，定长字符串。适合存储很短的字符串，或者所有值都接近同一个长度，如用于存储密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于非常短的列CHAR比VARCHAR在存储空间上更有效率。</p>
<p>​ VARCHAR：0~65535bytes，变长字符串。比定长类型更节省空间因为它只使用必要的空间。VARCHAR需要一个或2个额外字节记录字符串的长度，若列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。它节省了空间但由于它是变长的，所以可能导致特殊情况。如一个行占用的空间增长，且页内没有更多的空间可以存储，在这种情况下不同的存储引擎操作不同。MyISAM会将行拆成不同片段存储，InnoDB通过分裂页来使行可以放入业内。</p>
<p>​ TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB：存储2进制数据，依次为<span class="math inline">\(2^8,2^{16},2^{24},2^{32}\)</span> B</p>
<p>​ TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT：存储文本数据，依次为<span class="math inline">\(2^8,2^{16},2^{24},2^{32}\)</span> B</p>
<p>BLOB和TEXT值太大时，InnoDB会使用专门的外部存储区域来存储，此时每个值在行内需要1~4个字节存储指针，然后在外部存储区域存储实际的值。</p>
</blockquote>
<h3 id="mysql操作符及字句">Mysql操作符及字句</h3>
<blockquote>
<p>UNION：连接两个以上的SELECT语句，将结果组合到数据集中。多个SELECT语句会删除重复的数据。</p>
<p>DISTINCT：表示该值不可重复。如SELECT DISTINCT NAME FROM TABLE_NAME;可以过滤多余的重复记录。</p>
<p>WHERE 字句：设置条件。如SELECT NAME FROM TABLE_NAME WHERE ID &gt; 0；只会查询出id&gt;0的NAME。WHERE字句的格式：WHERE 列 运算符 值。</p>
<p>​ 可以使用的运算符：=，&lt;&gt;(不等于)，&gt;，&lt;，&gt;=，&lt;=，BETWEEN(在某个范围内)，LIKE(搜索某种模式，如LIKE "A%")</p>
<p>​ LIKE支持的通配符：%代替一个或多个，_代替一个字符，[charlist]代替字符列的任意一个字符，[!charlist]或[^charlist]代替除了字符列之外的任意一个字符。</p>
<p>IN(V1,V2,....)/ IN(子查询)：在V1，V2....之中的记录。</p>
<p>AND和OR：可以基于一个及以上条件对记录进行过滤，如WHERE A AND B; 过滤出当A且B的条件满足的记录。</p>
<p>ORDER BY 列名：按xxx列排序，如 ORDER BY COL1，COL2 DESC 表示记录按COL1降序排列，若COL1相同则按COL2降序排列，或后跟ASC表示升序排列。</p>
<p>SELECT * FROM TABLE_NAME LIMIT NUMBER 返回number数量的值。</p>
<p>GROUP BY：根据一个或多个列对结果集进行分组</p>
<p>IS NULL：判断值为空</p>
<p>IS NOT NULL：判断值不为空</p>
<p>EXISTS和NOT EXISTS (sub)：判断该子句是否存在结果。</p>
<p>ANY (subquery)：对结果任一满足条件即可。如 where A &gt; ANY(SELECT * FROM TABLE);即为若A＞子查询任意记录的值即可。相当于多个OR语句</p>
<p>SOME(subquery)：和ANY一样。</p>
<p>ALL(subquery)：要求同时满足，相当于多个AND语句。</p>
<p>REGEXP ‘正则表达式’：在条件中使用正则表达式匹配。</p>
</blockquote>
<h3 id="mysql连接的使用">Mysql连接的使用</h3>
<blockquote>
<p>内连接：<strong>INNER JOIN</strong>、<strong>JOIN</strong>、<strong>CROSS JOIN</strong>。是等价的，都返回笛卡尔积。</p>
<p>外连接：<strong>LEFT JOIN</strong>、<strong>RIGHT JOIN</strong>、<strong>NATURAL JOIN</strong>，分别为左连接，右连接，自然连接。均可以省略OUTER关键字。即<strong>LEFT JOIN = LEFT OUTER JOIN</strong></p>
<p><strong>LEFT JOIN</strong>：会读取左边数据表的全部数据，即使右边表无数据</p>
<p><strong>RIGHT JOIN</strong>：会读取右边数据表的全部数据，即使左边表无数据。</p>
<p><strong>NATURAL JOIN</strong>：是对两张表中字段名和数据类型都相同的字段进行等值连接，并符合符合条件的结果。注意只能有一个列符合条件。</p>
</blockquote>
<h2 id="mysql结构">Mysql结构</h2>
<blockquote>
<figure>
<img src="/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/Mysql架构.png" alt="Mysql架构"><figcaption aria-hidden="true">Mysql架构</figcaption>
</figure>
<p>最上层是连接器即客户端同Mysql连接的架构，提供连接处理、授权认证、安全等功能。</p>
<p>第二层是Mysql的服务层，包括Mysql核心服务功能：解析、分析、优化、缓存及内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。有分析器、优化器、执行器、查询缓存等组件。</p>
<p>最底层即第三层是存储引擎层，Mysql可以使用多种存储引擎如：InnoDB、MyISAM、Memory，存储引擎负责Mysql中数据的存取。</p>
</blockquote>
<h3 id="各组件功能">各组件功能</h3>
<blockquote>
<p>连接器：负责和客户端建立连接、获取权限、维持和管理连接。每个服务端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或CPU中运行。服务器会缓存线程，不需要为每个新建的连接创建或销毁线程。连接过程服务端还会对客户端进行认证，认证基于用户名、原始主机信息和密码。</p>
<p>分析器：有词法分析、语法分析两个功能。对于一个SQL语句，分析器先进行词法分析，对SQL进行拆分，识别出各个字符串代表的含义。然后进行语法分析，分析器根据定义的语法规则判断SQL是否满足Mysql语法。</p>
<p>优化器：优化器在获取分析器的结果后，通过表结构和SQL语句选择执行方案，比如：多表关联时，各个表如何进行连接；当表中有索引时，应该怎样选择索引。</p>
<p>执行器：获取到执行方案后，执行器会根据表的引擎定义，去使用引擎提供的接口。查询过程Mysql执行器内部执行步骤：</p>
<p>​ 1、调用引擎接口取这个表的第一行，判断该行是否满足WHERE字句，若满足则将这行存在结果集中，否则跳过。</p>
<p>​ 2、调用引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行。</p>
<p>​ 3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
<p>​ UPDATE操作的处理逻辑(InnoDB引擎)：</p>
<p>​ 1、Mysql Server发送更新请求到InnoDB引擎。</p>
<p>​ 2、从Buffer Pool加载对应记录的Data Page，若Buffer Pool中没有该记录，则从磁盘中读取记录。</p>
<p>​ 3、将P1存储到Undo Page中，并在Redo Log Buffer中记录Undo操作。</p>
<p>​ 4、更新P1为P1‘，并将P1’写入Dirty Page，记录变更到Redo Log Buffer(Prepare状态)。</p>
<p>​ 5、返回Mysql Server执行完成。</p>
<p>​ 6、Mysql Server 记录binlog。</p>
<p>​ 7、Mysql Server 提交commit。</p>
<p>​ 8、 Redo Log Buffer状态由Prepare 更改为Commit，并刷入磁盘。</p>
<p>​ 9、当Dirty Page过多时，启动ChechPoint机制，将脏页刷入磁盘。</p>
</blockquote>
<h3 id="存储引擎">存储引擎</h3>
<blockquote>
<p>使用SHOW TABLE STATUS可以查看表的相关信息。</p>
</blockquote>
<h4 id="innodb存储引擎">InnoDB存储引擎</h4>
<blockquote>
<p>InnoDB是Mysql的默认事物引擎。被设计用来处理大量短期事务，短期事务大部分情况是正常提交，少部分被回滚。</p>
<p>InnoDB的数据存储在表空间，表空间是InnoDB管理的黑盒，由一系列数据文件组成。</p>
<p>InnoDB采用MVCC来支持高并发，并实现了四个标准的隔离级别，默认隔离级别是REPEATABLE READ，并提供间隙锁策略来防止幻读出现。间隙锁让InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入。</p>
<p>InnoDB表是基于聚簇索引建立的。InnoDB的索引结构和Mysql的其他存储引擎存在很大不同，聚簇索引对主键查询有很高的性能，但是它的二级索引必须包含主键列，所以如果主键列很大，那么其他的所有索引都会很大。</p>
<p>InnoDB还做了许多优化，如从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，能加速插入操作的插入缓冲区等。</p>
<p>InnoDB通过一些机制和工具支持真正的热备份。</p>
</blockquote>
<h4 id="myisam">MyISAM</h4>
<blockquote>
<p>MyISAM不支持事务和行级锁，不能热备份，且崩溃后无法安全恢复。当对于只读的数据或者表比较小、可以忍受修复操作，可以使用MyISAM。</p>
<p>MyISAM的特性：</p>
<p>​ 加锁和并发：MyISAM对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但当表有读取查询时，也可以往表中插入新记录。</p>
<p>​ 修复：可以手工或自动执行检查和修复操作。但是执行表的修复可能导致数据丢失。</p>
<p>​ 索引特性：对于MyISAM表即使是BLOB和TEXT长字段，也可以基于前500个字符创建索引。也支持全文索引。</p>
<p>​ 压缩表：即使用myisampack对MyISAM进行压缩，压缩表是不能进行修改的(除非先解压缩，修改数据，再压缩)，压缩表可以减少磁盘占用，也减少磁盘I/O。</p>
</blockquote>
<h4 id="innodb和myisam的区别">InnoDB和MyISAM的区别</h4>
<h5 id="事务">事务</h5>
<blockquote>
<p>MyISAM：不支持事务。</p>
<p>InnoDB：支持事务。</p>
</blockquote>
<h5 id="外键">外键</h5>
<blockquote>
<p>MyISAM：不支持外键。</p>
<p>InnoDB：支持外键。</p>
</blockquote>
<h5 id="索引">索引</h5>
<blockquote>
<p>InnoDB使用聚簇索引和辅助(非聚簇)索引。实现方式都是B+树，但基于聚簇索引的查询，InnoDB查询的结果为具体的数据，而基于辅助索引的查询，查询的结果为对应的主键。即B+树的叶子节点是存储的数据一个是整个记录，一个是对应的主键。</p>
<p>MyISAM使用非聚簇索引。实现方式是B+树，非聚簇索引的两颗树没有什么不同，区别在于叶子节点存储的是具体数据的地址。无论是主键查询，还是基于辅助索引查询，都可以直接获取具体数据的地址。索引和数据是分离的。</p>
</blockquote>
<h5 id="锁">锁</h5>
<blockquote>
<p>InnoDB支持表、行(默认)级锁。InnoDB行锁是实现在索引上的，若访问没有命中索引，无法使用行锁，要退化为表锁。</p>
<p>MyISAM支持表级锁。</p>
</blockquote>
<h4 id="存储引擎的切换">存储引擎的切换</h4>
<blockquote>
<p>ALTER TABEL table_name ENGINE = XXXX</p>
<p>导入导出：使用mysqldump工具将数据导出到文件，然后修改文件中CREATE TABLE语句中存储引擎选项。</p>
<p>创建和查询：即先创建一个同结果的表，然后修改表存储引擎，最后使用insert into 配合select将旧数据插入到新表。</p>
</blockquote>
<h2 id="mysql事务">Mysql事务</h2>
<h3 id="事务的基本特性acid">事务的基本特性ACID</h3>
<blockquote>
<p>A：原子性，即一个事务的操作要么全部完成，要么全部不完成。</p>
<p>C：一致性，即在事务开始之前和之后数据库的完整性没有被破坏。所有写入的规则都必须完全符合所有预设规则。</p>
<p>I：隔离性，数据库对多个并发事务同时对其数据进行读写和修改的能力。</p>
<p>D：持久性，事务处理结束后，对数据库的修改就是永久的。</p>
</blockquote>
<h3 id="事务隔离级别">事务隔离级别</h3>
<blockquote>
<p>READ UNCOMMITTED：读未提交，即事务中的修改即使没有提交，对其他事务也是可见的。存在脏读、不可重复读、幻读的问题</p>
<p>READ COMMITED：读已提交，一个事务开始时只能看见已经提交的事物所做的修改。解决了脏读的问题。</p>
<p>REPEATABLE READ：可重复读，Mysql的默认事物隔离级别。解决了不可重复读的问题，保证了在同一个事务中多次读取同样记录的结果是一致的。解决了脏读和不可重复读的问题。</p>
<p>SERIALIZABLE：串行化。最高的隔离级别，强制事务串行处理，避免了幻读问题。</p>
<p>脏读：会读到其他事务没有提交的内容。</p>
<p>不可重复读：执行两次同样的查询可能得到不一样的结果，即其他事务修改了当前读取的记录。</p>
<p>幻读：指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新记录，当之前的事务再次读取该范围的记录时，会产生幻行。</p>
</blockquote>
<h3 id="多版本并发控制mvcc">多版本并发控制MVCC</h3>
<blockquote>
<p>MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，开销更低。只在READ COMMITED和REPEATABLE READ下工作，因为READ UNCOMMITED总是读取最新的数据行。SERIALIZABLE会对所有读取的行都加锁。</p>
<p>MVCC的实现是通过保存数据在某个时间点的快照来实现的，也就是说不管需要执行多次时间，每个事务看到的数据都是一致的。根据事务开始时间的不同，不同事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>理论上的MVCC需要保存数据的创建时间和过期时间来控制版本。</p>
<p>InnoDB的MVCC，是通过在每行记录后保存两个隐藏的列来实现的。这两个列一个保存了DATA_TRX_ID事务ID，一个保存DATA_ROLL_PTR回滚指针。每开启一个新的事务并执行增删改，系统版本号将会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用于和查询到的每行记录的版本号进行比较。此外若表中没有显式定义主键/没有唯一索引，Mysql会自动创建一个6字节的row id存入记录中，即DB_ROW_ID。同时InnoDB还会使用删除标志位来确保删除操作不可见。</p>
<p>语句更新时会生成undo log即回滚日志，用于从某个版本回退到历史版本。故而MVCC的本质就是保持多个不同版本的数据。</p>
<p>而解决脏读和不可重复读问题，则是基于MVCC并配合一致性视图ReadView的。</p>
</blockquote>
<h4 id="一致性视图readview">一致性视图ReadView</h4>
<blockquote>
<p>其中RR和RC生成视图的时间不同，RR是在事务开启/执行第一条SELECT语句时产生一致性视图，RC则是在每条语句执行前生成一次一致性视图。</p>
<p>一致性视图主要由m_ids即当前活跃的事务列表，up_limit_id最小活跃的事务，low_limit_id最大活跃事务，及m_creator_trx_id创建该视图的事务id。</p>
<p>而具体查询的流程进行如下操作：</p>
<p>​ 如果被访问版本的 trx_id 小于 m_ids 中的最小值 up_limit_id，说明生成该版本的事务在 ReadView 生成前就已经提交了，所以该版本可以被当前事务访问。</p>
<p>​ 如果被访问版本的 trx_id 大于 m_ids 列表中的最大值 low_limit_id，说明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。需要根据 Undo Log 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。 ​ 如果被访问版本的 trx_id 属性值在 m_ids 列表中最大值和最小值之间（包含），那就需要判断一下 trx_id 的值是不是在 m_ids 列表中。如果在，说明创建 ReadView 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 DB_TRX_ID 再从头计算一次可见性；如果不在或为创建该视图的事务id，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</p>
<p>此时就会存在当前读和快照读的区别：</p>
<p>​ 当前读指在事务开启后，执行更新语句时会读取当前数据库中最新的数据，即可以读到在事务开启之后提交的数据用于更新，避免数据操作丢失。</p>
<p>​ 快照读指的是事务开启后，只能读出当前事务id之前操作的值，用于避免读取的数据是不可重复读的。</p>
<p>当前读和快照读的触发时机：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">快照读</th>
<th style="text-align: center;">当前读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">RR事务隔离级别情况下，不显式加锁的读操作</td>
<td style="text-align: center;">显式加锁的读操作和增删改等写操作</td>
</tr>
</tbody>
</table>
<p>在读提交情况下一致性视图是在每次执行语句创建的，在可重复读的情况下一致性视图是在创建事务时创建的。</p>
</blockquote>
<h4 id="repeatable-read下mvcc的具体操作">REPEATABLE READ下MVCC的具体操作</h4>
<blockquote>
<p>SELECT：InnoDB会根据以下条件来检查记录</p>
<p>​ InnoDB只查找版本&lt;=当前事务版本的数据行，这样可以确保事务读取的行要么是事务开启前已经存在的，要么是事务自身插入或修改过的。</p>
<p>​ 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行在事务开始之前没有被删除。</p>
<p>INSEART：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除表示。</p>
<p>UPDATE：InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
</blockquote>
<h3 id="事务隔离级别的实现">事务隔离级别的实现</h3>
<blockquote>
<p>可重复读RR(Repeatable Read)：在Mysql中每条记录在更新时会同时记录一条回滚操作。记录上的最新值可以通过回滚操作得到前一个状态的值。同一条记录在系统中可以存着多个版本，即MVCC。其中回滚日志会在系统中没有比这个回滚日志更早的read-view时删除。(因此最好不要使用长事务。)</p>
</blockquote>
<h3 id="innodb上锁操作">InnoDB上锁操作</h3>
<blockquote>
<p>上锁分为隐式锁定和显式锁定。</p>
<p>InnoDB采用的是两阶段锁定协议，在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。这就是隐式锁定，InnoDB会根据隔离级别在需要时自动加锁。</p>
<p>显示锁定：</p>
<p>​ 如SELECT .... LOCK IN SHARE MODE</p>
<p>​ SELECT .... FOR UPDATE</p>
</blockquote>
<h3 id="事务日志">事务日志</h3>
<blockquote>
<p>事务日志可以提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再将该修改行为记录到持久在硬盘上的事务日志中，而不用每次将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域的顺序I/O，而非随机I/O需要在磁盘的多个地方移动磁头。事务日志持久后，内存被修改的数据在后台可以被慢慢地刷回磁盘。这是目前大多数存储引擎的实现方式，被叫作预写式日志，修改数据需要写两次磁盘。</p>
</blockquote>
<h3 id="事务基本操作">事务基本操作</h3>
<blockquote>
<p>BEGIN/START TRANSACTION：开启事务。</p>
<p>COMMIT/COMMIT WORK：提交事务。</p>
<p>ROLLBACK/ROLLBACK WORK：回滚事务。</p>
<p>SAVEPOINT IDENTIFIER：在事务中创建一个保存点。</p>
<p>RELEASE SAVEPOINT IDENTIFIER：删除一个事务的保存点，当没有指定的保存点时会抛出异常。</p>
<p>ROLLBACK TO IDENTIFIER：把事务回滚到保存点。</p>
<p>SET TRANSACTION 隔离级别：设置事务的隔离级别。READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</p>
</blockquote>
<h2 id="mysql索引">Mysql索引</h2>
<blockquote>
<p>索引可以大大提高查询速度，但会降低更新表的速度，因为更新表时Mysql不仅要保存数据还需要保存索引文件。同时索引也会占用磁盘空间的索引文件。</p>
<p>创建索引：</p>
<p>​ CREATE INDEX INDEX_NAME ON TABLE_NAME()</p>
<p>唯一索引：UNIQUE INDEX。索引值必须是唯一的，除了NULL之外。可能出现多个NULL。</p>
<p>主键索引：PRIMARY KEY。索引值必须是唯一的且不能为NULL。</p>
<p>普通索引：INDEX。索引值可以出现多次。</p>
<p>全文索引：FULLTEXT。</p>
</blockquote>
<h3 id="索引的类型">索引的类型</h3>
<h4 id="b-tree索引">B-TREE索引</h4>
<blockquote>
<p>是Mysql对索引的称呼，底层的存储引擎可能采用不同的数据结构。如InnoDB采用的是B+树实现的索引。</p>
<p>B-Tree索引的限制：</p>
<p>​ 若不是按照索引的最左列开始查找，则无法使用索引。如索引是A-B-C，查找B无法利用索引。</p>
<p>​ 不能跳过索引中的列，即若索引是A-B-C，查找A-C则只能利用索引的第一列</p>
<p>​ 若查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。如索引为A-B-C，查询操作中B使用了如LIKE ‘%’的语句，则只能索引索引的前两列。</p>
</blockquote>
<h4 id="哈希索引">哈希索引</h4>
<blockquote>
<p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。只有精确匹配索引所有列的查询才有效。对于每行数据，存储引擎会对所有的索引计算一个哈希码。哈希索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，让哈希索引查找的速度非常快。</p>
<p>哈希索引的限制：</p>
<p>​ 哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。</p>
<p>​ 哈希索引数据不是按照索引值顺序存储的，所以无法用于排序。</p>
<p>​ 哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容计算哈希值的。如索引A-B，查询A无法使用哈希索引。</p>
<p>​ 哈希索引只支持等值比较查询，如=、IN()、&lt;=&gt;(可以判断NULL的=)，不支持任何的范围查询。</p>
<p>​ 访问哈希索引的数据非常快，除非有很多哈希冲突。出现哈希冲突时需要遍历链表里的所有行指针。</p>
<p>​ 如果哈希冲突很多的话，一些索引维护操作的代价也很高。如：删去一行需要在链表中查找到对应行才能删去。</p>
<p>InnoDB的自适应哈希索引：当InnoDB注意到某些索引值被使用得很频繁时，会在内存上基于B-Tree索引上再创建一个哈希索引，这样让B-Tree索引也有哈希索引的一些优点。</p>
<p>创建自定义哈希索引：只需要很小的索引就可以为超长的键创建索引。只需要在B-Tree的基础上创建一个伪哈希索引。使用B-Tree查找，但使用哈希值而非键本身进行索引查找。</p>
</blockquote>
<h4 id="全文索引">全文索引</h4>
<blockquote>
<p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
</blockquote>
<h4 id="聚簇索引">聚簇索引</h4>
<blockquote>
<p>聚簇索引不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>当表有聚簇索引时，它的数据行实际上放在索引的叶子页。聚簇是指数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，故一个表只能有一个聚簇索引。InnoDB是通过主键聚集数据。若没有定义主键，InnoDB会选择一个唯一的非空索引代替。若没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。</p>
<p><strong>聚簇索引的优点</strong>：</p>
<p>​ 可以把相关数据保存在一起。如实现电子邮箱时按用户ID聚集数据，这样只需要从磁盘读取少量数据页即可获取用户的全部邮件。</p>
<p>​ 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据往往比非聚簇索引中查找更快。</p>
<p>​ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>
<p><strong>聚簇索引的缺点</strong>：</p>
<p>​ 插入速度严重依赖于插入顺序。若按主键顺序插入速度最快，若不是按主键顺序插入，那加载完成后最好使用OPTIMIZE TABLE命令重新组织表。</p>
<p>​ 更新聚簇索引列的代价很高。因为会强制InnoDB将每个被更新的行移动到新位置。</p>
<p>​ 基于聚簇索引的表在插入新行，或者主键被更新需要移动时，可能存在页分裂的情况。</p>
<p>​ 聚簇索引可能导致全表扫描变慢，特别是当行比较稀疏，或由于页分裂导致数据存储不联系时。</p>
<p>​ 二级索引(非聚簇索引/辅助索引)的空间占用可能较大，因为二级索引叶子节点中包含主键列。</p>
<p>​ 二级索引访问需要两次索引查找而非一次。</p>
<p><strong>聚簇索引的使用</strong>：</p>
<p>​ <strong>最好避免随机的聚簇索引</strong>，即索引值不应该是不连续且值分布访问非常大。因为这会导致聚簇索引的插入变得完全随机。随机的聚簇索引插入不仅花费的时间更长而且索引占用的空间也更大。这既是由于主键字段长，也是由于页分裂和碎片导致的。</p>
<p><strong>采用顺序的主键值插入</strong>，由于主键的值是顺序的，InnoDB会将每一条记录存储在上一条记录的后面，当达到页的最大填充因子时下一条记录会写入新的页中，主键页会被以近似顺序的记录填满：</p>
<figure>
<img src="/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/聚簇索引顺序插入.png" alt="聚簇索引顺序插入"><figcaption aria-hidden="true">聚簇索引顺序插入</figcaption>
</figure>
<p><strong>采用随机的主键值插入</strong>，由于新行的主键不一定比之前插入的大，所以InnoDB不能简单地总把新行插入到索引的最后，而要为新行寻找合适的位置，通常是已有数据的中间位置，且分配空间。这样带来了缺点：</p>
<p>​ 写入的目标页可能已经刷到磁盘上并从缓存中移除，或没有加载到缓存中，InnoDB在插入之前需要先找到并从磁盘中读取目标页到内存。这样导致了随机I/O。</p>
<p>​ 因为写入是乱序的，InnoDB需要频繁地进行页分裂操作，以便为新行分配空间。导致移动大量数据，一次插入至少修改三个页，而非一个页。</p>
<p>​ 由于频繁页分裂，页会变得稀疏且不规则，最终数据会有碎片。</p>
<p><strong>顺序主键的缺点</strong>：并发场景下，InnoDB按主键顺序插入可能造成明显争用。</p>
</blockquote>
<h4 id="覆盖索引">覆盖索引</h4>
<blockquote>
<p>为了避免回表操作，即查询到的数据是主键，还要再用主键查询一次。如果索引的叶子节点包含要查询的数据就不用进行回表操作了。而一个索引包含了所有需要查询的字段的值，我们就称之为覆盖索引。</p>
<p>覆盖索引的优点：</p>
<p>​ 索引条目通常原小于数据行大小，如果只用读取索引，Mysql就会极大地减少数据访问量。覆盖索引也会让I/O密集型应用有帮助，因为索引比数据更小，更容易放入内存中。</p>
<p>​ 索引是按照列值顺序存储的(至少在单页内如此)，所以I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O少得多。</p>
<p>​ 一些存储引擎如MyISAM在内存中只缓存索引，数据依赖操作系统缓存，导致访问数据需要进行系统调用。</p>
<p>​ 由于InnoDB采用聚簇索引，所以覆盖索引对于InnoDB表特别有用。</p>
<p>并非所有类型的索引都可以成为覆盖索引。覆盖索引必须存储索引列的值，而哈希索引、空间索引、全文索引等都不能存储索引列的值，故Mysql只能用B-Tree索引做覆盖索引。</p>
</blockquote>
<h3 id="索引的优缺点">索引的优缺点</h3>
<blockquote>
<p>优点：</p>
<p>​ 索引大大减少了服务器需要扫描的数量。</p>
<p>​ 索引可以帮助服务器避免排序和临时表。</p>
<p>​ 索引可以将随机I/O变为顺序I/O。</p>
<p>缺点：</p>
<p>​ 索引会占据额外空间，此外也降低了更新表的操作效率，因为更新表时Mysql不仅要保存数据还需要保存索引文件。</p>
</blockquote>
<h3 id="高效地使用索引">高效地使用索引</h3>
<h4 id="独立的列">独立的列</h4>
<blockquote>
<p>索引必须是独立的列。如索引为A，查询时使用 A + 1 = X，不会使用索引。即索引列不能是表达式的一部分，也不能是函数的参数。</p>
</blockquote>
<h4 id="索引前缀下推icp">索引前缀下推ICP</h4>
<blockquote>
<p>即在使用索引时若找到索引后若没有ICP则需要先回表然后进行判断where条件，引入ICP后可以直接在找到索引后利用where条件先筛选。</p>
</blockquote>
<h4 id="前缀索引和索引选择性">前缀索引和索引选择性</h4>
<blockquote>
<p>有时索引很长的字符列，索引会变得大且慢，此时可以使用模拟哈希索引，也可以索引开始的部分字符，以节省索引空间，提高索引效率。</p>
<p>索引的选择性是指不重复的索引值和数据报的记录总数的比值。索引选择性越高则查询效率越高，1为最佳。</p>
<p>可以将长度较大的字符列，采用前缀索引的方式，即使用该列的前x个字符作为索引。这样可以使索引更小，更快。但是存在缺点：Mysql不能使用前缀索引进行ORDER BY和GROUP BY操作，也不能使用前缀索引进行覆盖扫描。</p>
<p>而具体选择几个字符作为前缀可以通过计算区分度来决定。即根据需要建立前缀索引列占总体比值，和对应长度前缀占总体比值来判断。</p>
<p>SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;</p>
<p>SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;</p>
<p>但是前缀索引由于是部分信息，所以查找时需要回表操作，不能使用覆盖索引。</p>
</blockquote>
<h4 id="索引使用注意点">索引使用注意点</h4>
<blockquote>
<p>Mysql不能在索引中执行LIKE操作。Mysql5.5及更早的版本中只允许在索引中做简单的比较操作。Mysql能在索引中做最左前缀匹配的LIKE比较，但不能执行以通配符开头的LIKE查询，这种情况下Mysql只能提前数据行的值而非索引值来进行比较。</p>
</blockquote>
<h4 id="普通索引和唯一索引的选择">普通索引和唯一索引的选择</h4>
<blockquote>
<p>普通索引和唯一索引在查找操作的区别，性能上差距几乎没有：</p>
<p>​ 普通索引查找到满足条件的第一个记录后需要查找下一个记录，直到第一个没有满足条件的记录。此时可能遇到从磁盘进行I/O读取的情况。</p>
<p>​ 唯一索引查找到满足条件时直接返回结果。</p>
<p>普通索引和唯一索引在更新操作的区别：</p>
<p>​ 主要和InnoDB的存储有关，在更新时如果数据页在内存中会直接更新，若数据页没有在内存中，在不影响数据一致性的情况下会将更新操作缓存到change buffer中，直到下次访问到这个数据页时再将这些操作写入。change buffer也是可持久化的数据。将change buffer写入数据页的操作叫merge，访问数据页会触发merge，也会有后台线程进行定期merge。</p>
<p>​ 对于唯一索引，由于需要判断唯一性，故每次操作时都需要读取数据页到内存，此时change buffer没有作用。</p>
<p>​ 而对于普通索引，不需要检查唯一性，可以使用change buffer。此时减少了I/O访问。性能更高。</p>
<p>故change buffer的使用场景为：写多读少的场景，因为写多读少往往可以让写操作积累，这样减少的I/O访问次数更多，提升效率。而若是写后立即读的场景，由于读取数据会调用数据页，change buffer不会积累较多操作，无法提升性能，且维护change buffer还需要开销，性能反而变低。</p>
<p>change buffer和redo log的区别：</p>
<p>​ change buffer主要目的在于将磁盘随机读取操作推迟，而redo log的主要目的在于将磁盘随机写入操作推迟。</p>
</blockquote>
<h2 id="锁-1">锁</h2>
<h3 id="共享锁和排他锁">共享锁和排他锁</h3>
<blockquote>
<p>即行锁的读锁和写锁</p>
<table style="width:100%;">
<colgroup>
<col style="width: 9%">
<col style="width: 16%">
<col style="width: 14%">
<col style="width: 29%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>行锁类型</th>
<th>锁功能</th>
<th>锁兼容性</th>
<th>加锁</th>
<th>释放锁</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>共享锁（读锁、S锁）</td>
<td>允许获取共享锁的亊务读数据</td>
<td>与共享锁兼容，与排它锁不兼容</td>
<td>只有 <code>Serializable</code> 隔离级别会默认为：读加共享锁；其他隔离级别下，可显示使用 <code>select...lock in share model</code> 为读加共享锁</td>
<td>在事务提交或回滚后会自动同时释放锁；除了使用 <code>start transaction</code> 的方式显式开启事务，InnoDB 也会自动为增删改査语句开启事务，并自动提交或回滚；(<code>autocommit=1</code>)</td>
</tr>
<tr class="even">
<td>排它锁（写锁、X锁）</td>
<td>允许获取排它锁的事务更新或删除数据</td>
<td>与共享锁不兼容，与排它锁不兼容</td>
<td>在默认的 <code>Reapeatable Read</code> 隔离级别下，InnoDB 会自动为增删改操作的行加排它锁；也可显式使用 <code>select...for update</code> 为读加排它锁</td>
<td>…</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="意向锁和独占锁">意向锁和独占锁</h3>
<blockquote>
<p>这个是在InnoDB引擎层实现的。MDL锁是Server层实现的。</p>
<p>为了兼容行锁和表锁，设置了意向共享锁和意向排他锁。主要目的是方便表级的读写锁的判断，即当表内存在数据用于排他锁时，会上意向排它锁，此时全表读锁即可利用意向排它锁来判断是否可以获得到锁。</p>
<p>​ 意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 x 锁</p>
<p>​ 意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 s 锁</p>
<p>新请求的锁需要兼容旧锁才能被满足。</p>
</blockquote>
<h3 id="全局锁表锁和行锁">全局锁、表锁和行锁</h3>
<blockquote>
<p>全局锁：对整个数据库实例加锁。可以使用Flush tables with read lock命令上锁。一般用于全库逻辑备份。该操作会让数据库变为只读状态。如果不加锁会导致备份时得到的库的视图是不一致的。</p>
<p>若存储引擎支持一致性读，即可重复读隔离，则可以使用mysql官方工具<strong>mysqldump</strong>使用-single-transaction参数，来获取一致性视图，进行备份操作。</p>
<p>表级锁：</p>
<p>​ lock tables ... read/write。可以使用unlock tables主动释放锁，也可以在客户端断开连接时自动释放。</p>
<p>​ MDL(metadata lock)元数据锁，不显示使用而是在访问表时自动上锁，当执行表增删改操作时上MDL读锁，执行表结构修改时上MDL写锁。MDL锁是在语句执行开始时申请，在语句结束后不会马上释放，需要事务提交后才能被释放。这样会导致对表结构修改操作时，若当前存在MDL读锁，且之后的操作也需要获取MDL读锁，后续的操作会被堵塞。</p>
<p>行锁：Mysql行锁是存储引擎自己实现的。并非所有引擎都支持行锁。MyISAM就不支持行锁。而InnoDB实现了行锁。</p>
<p>InnoDB的行锁是两阶段锁，即在事务中，当执行需要锁操作的指令才会自动加锁，但锁的释放则需要等事务结束才释放。</p>
<p>InnoDB的死锁解决策略：</p>
<p>​ 方法1.通过设置innodb_lock_wait_timeout设置等待超时时间。默认值50s</p>
<p>​ 方法2.发起死锁检测，发现死锁后主动回滚死锁链条的某个事务，让其他事务可以继续执行。设置innodb_deadlock_detect为on。一般使用这个。</p>
</blockquote>
<h3 id="record-lock记录锁gap-lock-间隙锁和next-key-临键锁">Record lock记录锁、Gap lock 间隙锁和Next-key 临键锁</h3>
<blockquote>
<p>Record lock记录锁：即添加到记录上的锁。<strong>InnoDB提供的行锁是基于索引的</strong>，若执行计划访问不了索引则会直接使用表锁。记录锁锁住的是索引记录。如果使用索引作为条件命中了记录，那么就是记录锁，被锁住的记录不能被别的事务插入相同的索引键值，修改和删除。我们用<strong>主键或者唯一索引</strong>作为条件<strong>等值</strong>查询的时候，命中记录就是加的记录锁。对于范围查询则会加临键锁。</p>
<p>Gap lock 间隙锁：锁在索引之间或第一个索引前或最后一个索引后，是左开右开区间。无论是等值查询还是范围查询，当使用<strong>唯一索引/非唯一索引没有命中</strong>时加的是间隙锁。</p>
<p>Next-key 临键锁：类似间隙锁，是左开右闭区间。当使用范围查询且使用<strong>非唯一索引命中</strong>的情况使用临键锁。注意当命中后不仅会加临键锁，还会向后加间隙锁。如 表为 1 - 3 - 5，命中3时会加(1,3]区间和(3,5)区间，即最后锁住(1,5)区间。但是需要注意的是锁住的范围还会和主键有关，如锁住的非索引为(2,5)，具体记录为1-2、3-5，即使插入的是2-2也会失败，插入0-2则会成功。</p>
<p>间隙锁之间不冲突，临键锁之间冲突。</p>
</blockquote>
<h3 id="索引和锁">索引和锁</h3>
<blockquote>
<p>InnoDB只有在访问行的时候才会对其加锁，而索引可以减少InnoDB访问的次数，从而减少锁的数量。但如果索引不能过滤掉无效的行，那么InnoDB检索到数据并返回给服务器层后，Mysql才能应用Where子句，此时InnoDB已经锁住了这些行，到适当时释放。Mysql 5.1前InnoDB可以在服务端过滤掉行后释放，之前的版本，只有在事务提交后才能释放。</p>
<p>InnoDB在二级索引上使用共享锁，访问主键索引需要排它锁。</p>
</blockquote>
<h2 id="mysql日志">Mysql日志</h2>
<h3 id="日志redo-log-和-binlog">日志redo log 和 binlog</h3>
<blockquote>
<p>redo log和binlog区别：</p>
<p>​ <strong>redo log是InnoDB特有的日志</strong>，<strong>binlog是Server层特有的日志</strong></p>
<p>​ redo log是物理日志，记录了“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，如“给ID=2这一行的C字段加1”。</p>
<p>​ redo log是循环写的，空间固定且可以被用完；binlog是可以追加写入的，即binlog文件写到一定大小后会切换到下一个，不会覆盖之前的日志。</p>
<p>Mysql在这一部分主要设计思想为先写日志再写磁盘。即WAL(Write Ahead Logging技术)。</p>
<p>redo log的使用：具体而言当存在记录需要更新时，InnoDB引擎会先把记录写入redo log里，并更新内存，此时认为更新完成了。同时InnoDB会在适当时将操作记录更新到磁盘里。但InnoDB的redo log的固定大小的，如可以配置一组4个文件，每个文件大小为1GB，则redo log一共可以记录4GB操作。然后在写入的过程中会记录当前的write_pos和checkpoint即写入的位置和需要擦除的位置。若二者重合则需要提前将记录写到磁盘。</p>
<p>redo log 和binlog是怎么配合的？<strong>两阶段提交</strong>。以更新某个行的某个字段值为1为例：</p>
<p>​ 执行器会找存储引擎去取出对应行，存储引擎会利用树查找，若该行位于内存中，则返回，否则通过磁盘读入再返回给执行器。</p>
<p>​ 执行器拿到数据将值修改后，调用存储引擎接口写入新数据。</p>
<p>​ 存储引擎将数据更新到内存中，记录该操作到<strong>redo log</strong>，此时redo log处于<strong>prepare</strong>状态。然后告知执行器可以随时提交事务。</p>
<p>​ 执行器生成操作的binlog，将binlog写入磁盘。</p>
<p>​ 执行器调用引擎的事务提交接口，引擎将redo log改为<strong>commit</strong>状态，更新完成。</p>
<p>为什么要<strong>两阶段提交</strong>？</p>
<p>​ 若先写binlog再写redo log：假设在写入binlog后，redo log写入前数据库崩溃了。此时事务没有执行结束，没有对数据进行修改，但由于binlog已经记录了导致还原时会多出一次操作。</p>
<p>​ 若先写redo log再写binlog：假设在写入redo log后，binlog写入前数据库崩溃了。此时事务结束了，数据已经被修改，但由于binlog没有记录操作，导致还原时操作被丢失了。</p>
<p>使用两阶段提交后数据库崩溃的恢复过程：</p>
<p>​ 若在写入redo log prepare后 binlog前崩溃，则不会恢复该操作，因为这个操作没有提交。</p>
<p>​ 若在写入redo log prepare、 binlog后，redo log commit前崩溃，则会检查binlog完整性，若完整则恢复。</p>
<p>可以通过innodb_flush_log_at_trx_commit设为1，让每次事务的redo log持久化到磁盘，设置sync_binlog为1，让每次事务的binlog持久化到磁盘。</p>
</blockquote>
<h3 id="mysql的flush">mysql的flush</h3>
<blockquote>
<p>由于数据写入时都是先写入日志，即内存中，并没有进行磁盘写入。而同内存数据页不符的磁盘数据页被称为“脏页”。而同步后的数据页叫“干净页”。</p>
<p>而刷新的触发时机如下：</p>
<p>​ InnoDB的redo log分为write pos 和 checkpoint，当write pos达到checkpoint时需要推进checkpoint，即写入一定的数据到磁盘。</p>
<p>​ 系统内存不足，需要新的内存页。</p>
<p>​ 每隔一段时间，会有线程自动将一定内存页刷入磁盘页。</p>
<p>​ 当数据库关闭时，将数据刷入磁盘页。</p>
</blockquote>
<h3 id="undo-log">undo log</h3>
<blockquote>
<p>即MVCC使用的回滚日志。每次操作后会记录对应的undo操作。</p>
</blockquote>
<h2 id="mysql查询优化">Mysql查询优化</h2>
<h3 id="sql执行顺序">Sql执行顺序</h3>
<blockquote>
<ul>
<li><ol start="7" type="1">
<li><ul>
<li>SELECT</li>
</ul></li>
</ol></li>
<li><ol start="8" type="1">
<li><ul>
<li>DISTINCT <select_list></select_list></li>
</ul></li>
</ol></li>
<li><ol type="1">
<li><ul>
<li>FROM <left_table></left_table></li>
</ul></li>
</ol></li>
<li><ol start="3" type="1">
<li><ul>
<li><join_type> JOIN <right_table></right_table></join_type></li>
</ul></li>
</ol></li>
<li><ol start="2" type="1">
<li><ul>
<li>ON <join_condition></join_condition></li>
</ul></li>
</ol></li>
<li><ol start="4" type="1">
<li><ul>
<li>WHERE <where_condition></where_condition></li>
</ul></li>
</ol></li>
<li><ol start="5" type="1">
<li><ul>
<li>GROUP BY <group_by_list></group_by_list></li>
</ul></li>
</ol></li>
<li><ol start="6" type="1">
<li><ul>
<li>HAVING <having_condition></having_condition></li>
</ul></li>
</ol></li>
<li><ol start="9" type="1">
<li><ul>
<li>ORDER BY <order_by_condition></order_by_condition></li>
</ul></li>
</ol></li>
<li><ol start="10" type="1">
<li><ul>
<li>LIMIT <limit_number></limit_number></li>
</ul></li>
</ol></li>
</ul>
</blockquote>
<h3 id="mysql执行查询的流程">Mysql执行查询的流程</h3>
<blockquote>
<p>1、客户端发送一条查询给服务器。</p>
<p>2、服务器检查查询缓存，若命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。即解析查询语句前，若查询缓存是开启的，Mysql会优先检查这个查询是否命中缓存中的数据。该检查是通过一个对大小写敏感的哈希查找实现的。</p>
<p>3、服务器端执行SQL解析、预处理，再由优化器生成对应的执行计划。</p>
<p>4、Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询。</p>
<p>5、将结果返回给客户端。</p>
<p>即客户端先经过连接器认证 —&gt; 查询缓存 —&gt; 经过分析器 —&gt; 经过优化器 —&gt; 经过执行器 —&gt; 获得结果返回给客户端。</p>
</blockquote>
<h3 id="显示查询执行情况">显示查询执行情况</h3>
<blockquote>
<p>使用SHOW PROFILE</p>
<p>​ 先查看当前profiling是否开启，如果没开启则set profiling = 1开启profile机制。</p>
<p>​ 然后执行对应sql，通过show profiles;查看执行的query情况，找出刚刚执行的sql，通过show profile for query number来展现具体的情况。</p>
<p>使用SHOW STATUS</p>
<p>使用慢查询日志。</p>
</blockquote>
<h3 id="explain查看执行计划">Explain查看执行计划</h3>
<blockquote>
<p>即在sql语句前使用explain查看详细的执行计划。</p>
<figure>
<img src="/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/explain执行计划.png" alt="explain执行计划"><figcaption aria-hidden="true">explain执行计划</figcaption>
</figure>
<p>ID：表示执行顺序，id相同时自上而下执行，当存在子查询时会出现不同id，id越大越先执行。</p>
<p>select_type：表示查询类型。SIMPLE表示简单查询，即没有union和子查询。 primary最外层查询，即存在子查询时的最外层查询。SUBQUERY子查询。DERIVED表示派生类型，即使用了UNION关键字。UNION表示union关键字后跟随的查询。UNION RESULT表示union的结果。</p>
<p>table：表示该执行计划作用的表。</p>
<p>type：如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">type</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">不访问表或索引即可得出结果</td>
</tr>
<tr class="even">
<td style="text-align: center;">const</td>
<td style="text-align: center;">使用唯一索引查询到一条记录</td>
</tr>
<tr class="odd">
<td style="text-align: center;">system</td>
<td style="text-align: center;">表示仅一行</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>eq_ref</strong></td>
<td style="text-align: center;">使用唯一索引的扫描</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>ref</strong></td>
<td style="text-align: center;">使用非唯一索引或使用唯一索引的前缀扫描</td>
</tr>
<tr class="even">
<td style="text-align: center;">ref_or_null</td>
<td style="text-align: center;">类似ref，但可以额外查找NULL</td>
</tr>
<tr class="odd">
<td style="text-align: center;">index_merge</td>
<td style="text-align: center;">索引合并优化</td>
</tr>
<tr class="even">
<td style="text-align: center;">unique_subquery</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">index_subquery</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>range</strong></td>
<td style="text-align: center;">索引范围扫描，常见于使用了&lt;、&gt;等操作符</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>index</strong></td>
<td style="text-align: center;">索引全扫描</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>all</strong></td>
<td style="text-align: center;">全表扫描</td>
</tr>
</tbody>
</table>
<p>possible_keys：可能使用的索引。</p>
<p>key：实际使用的索引。</p>
<p>key_len：需要被使用索引的长度。</p>
<p>ref：表示查找时使用的列/常量，常见const（常量），func，NULL，字段名（例：film.id）。</p>
<p>rows：预估需要扫描的行数。</p>
<p>filtered：表示返回结果占需要读取行数的百分比。</p>
<p>extra：执行计划的补充说明。具体如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">extra</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>Using filesort</strong></td>
<td style="text-align: center;">对数据进行了外部索引排序，而不是按索引顺序排序，表示mysql无法利用索引排序</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Using temporary</strong></td>
<td style="text-align: center;">使用临时表保存中间结果，常见于order by和group by</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Using index</strong></td>
<td style="text-align: center;">表示只需要访问索引树就可以获取值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Using where</strong></td>
<td style="text-align: center;">使用where过滤</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Using join buffer</td>
<td style="text-align: center;">使用了连接缓存</td>
</tr>
<tr class="even">
<td style="text-align: center;">impossible where</td>
<td style="text-align: center;">where字句值总为false</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Using index condition</strong></td>
<td style="text-align: center;">表示可以使用索引，但还需要进行回表操作</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="mysql-schema设计">Mysql Schema设计</h3>
<h4 id="选择优化的数据类型">选择优化的数据类型</h4>
<blockquote>
<p>更小的通常更好：尽量使用可以存储数据的最小数据类型。</p>
<p>简单就好：如整型比字符操作代价更低。举例：使用Mysql存储日期和时间，而不是使用字符串。使用整型来存储IP地址。</p>
<p>尽量避免NULL：最好指定列为NOT NULL，除非真的需要NULL值。因为查询中包含可为NULL的列对应Mysql来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。</p>
</blockquote>
<h4 id="设计中的陷阱">设计中的陷阱</h4>
<blockquote>
<p>太多的列：</p>
<p>太多的关联：</p>
<p>全能的枚举：将没有必要设计成枚举的列设计成枚举，每次修改时都需要用到ALTER TABLE</p>
<p>不要全盘否定NULL：有时NULL会比特定的值好用，避免代码复杂。</p>
</blockquote>
<h3 id="慢查询优化">慢查询优化</h3>
<blockquote>
<p>1、已经执行完成的SQL。show variables like ‘slow_query_log’；</p>
<p>​ 查看慢查询是否开启。</p>
<p>​ 查看慢查询的日志存放位置。 show variables like ‘slow_query_log_file’；</p>
<p>​ 查看慢查询的时间。show variables like ‘long_query_time’；</p>
<p>如何分析日志：</p>
<p>​ 使用mysqldumpslow工具：执行mysqldumpslow -s r -t 10 日志路径</p>
<p>​ 还可以使用pt-query-digest</p>
<p>2、正在执行的SQL</p>
<p>​ show processlist；</p>
<p>主要分析步骤：</p>
<p>​ 1、确认应用程序是否在检索大量超过需要的数据。即可能访问了太多的行/列。</p>
<p>​ 2、确认Mysql服务器是否在分析大量超过需要的数据行。</p>
</blockquote>
<h3 id="是否向数据库请求了不需要的数据">是否向数据库请求了不需要的数据？</h3>
<blockquote>
<p>判断是否查询了不需要的记录。</p>
<p>​ 如是否存在向Mysql查询了大量记录，然后获取前面N行后关闭结果集。如果存在这种情况，可以在查询后添加LIMIT。</p>
<p>多表关联时返回全部列而非具体需要的列。</p>
<p>是否总是取出全部列？即使用SELECT *操作。</p>
<p>是否重复查询相同的数据？若存在则使用缓存机制。</p>
</blockquote>
<h3 id="mysql是否扫描额外的记录">Mysql是否扫描额外的记录？</h3>
<blockquote>
<p>Mysql开销的三个指标：响应时间、扫描行数、返回行数。</p>
<p>响应时间：包括服务时间和排队时间。服务时间指数据库处理这个查询真正花了多长时间。排队时间指服务器因为等待某些资源而没有真正执行查询的时间(如等待I/O操作，等待行锁等)。</p>
<p>查看扫描的行数和返回的行数。</p>
<p>查看扫描的行数和访问类型。</p>
<p>​ 通过EXPLAIN查看。在Mysql使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<p>​ 在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</p>
<p>​ 使用索引覆盖扫描(在Extra列出现Using index)来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在Mysql服务器层完成的，但无须回表操作。</p>
<p>​ 从数据表中返回数据，然后过滤不满足条件的记录(在Extra列出现Using Where)。这在Mysql服务器层完成，Mysql需要从数据表读出记录再过滤。</p>
<p>当发现查询需要扫描大量数据但只返回少数列时，可以尝试以下方式优化：</p>
<p>​ 使用索引覆盖扫描，把所有需要用的列都放入索引中，这样存储引擎无须回表即可返回结果。</p>
<p>​ 改变库表结构，如使用单独的汇总表。</p>
<p>​ 重新复杂的查询，让Mysql优化器可以以更优化的方式执行查询。</p>
</blockquote>
<h3 id="重构查询的方式">重构查询的方式</h3>
<blockquote>
<p><strong>将一个复杂查询拆分为多个简单查询</strong>。</p>
<p><strong>切分查询</strong>：如删除旧数据时，如果采用一个大语句删除，会一次锁住许多数据、占满事务日志、耗尽系统资源、阻塞小而重要的查询。可以选择一次删除比较少的数目，分多次删除。</p>
<p><strong>分解关联查询</strong>：即将关联查询改为对每个表进行单表查询，然后将结果在应用程序中进行关联。</p>
<p>​ 优点：让缓存的效率更高。</p>
<p>​ 将查询分解后执行单个查询可以减少锁的竞争。</p>
<p>​ 在应用层做关联可以更容易对数据库进行拆分，更容易做到高性能和可拓展。</p>
<p>​ 查询本身的效率可以有所提升。</p>
<p>​ 减少冗余记录的查询，在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复访问一部分数据。</p>
<p>​ 相当于应用中实现了哈希关联，而不是使用Mysql的嵌套循环关联。</p>
</blockquote>
<h2 id="mysql集群分布式">Mysql集群/分布式</h2>
<h3 id="分库分表">分库分表</h3>
<blockquote>
<p>垂直分表：即按列拆分数据表，一般是将大表按列拆分成多个表。</p>
<p>垂直分库：即将一个数据库中的业务按不同类型进行拆分，拆分到多个数据库中。</p>
<p>水平分表、分库：即由于单表/库内的数据过多，需要对数据按行拆分到多个表/库中。</p>
</blockquote>
<h3 id="水平分库分表的方式及问题">水平分库、分表的方式及问题</h3>
<blockquote>
<p>主要方式分为：离散映射和连续映射。</p>
<p>​ 离散映射：利用取模函数，将数据均匀地划分到每个表/库，这样良好地解决了热点问题，但带来了数据迁移和历史数据问题。</p>
<p>​ 连续映射：即按id或创建时间等连续范围进行映射，这样可以避免数据迁移问题，但带来了热点问题。</p>
<p>数据迁移问题：即分库后的数据再次达到上限需要二次分库。</p>
<p>热点问题：由于数据是连续分库的，当达到库上限时虽然无须数据迁移只需新建库，但这样会导致所有的插入操作都集中到新库中。</p>
<p>具体水平分库、分表过程：</p>
<p>​ 假设开始时仅一个数据库DB0，两个表T0、T1。使用id%2进行插入表。</p>
<p>​ 当单数据库达到一定数据量如1kw时，增加一个数据库，将其中一个表移动到新库，对于1kw内的数据通过%2分布到两个库的旧表中，1kw后的数据分布到两个库的新表中。</p>
<p>​ 如果还达到上限如2kw，则将两个库中的两个表再取出一个表移动到两个新库中，然后对应2kw内的数据按之前的方法划分到4个库中，对应2kw后的数据按照%4分布到新的4个表中。</p>
</blockquote>
<h3 id="数据迁移">数据迁移</h3>
<blockquote>
<p>最简单的方式：停机迁移。</p>
<p>无法停机则使用双写迁移。即同时写两个库，一个老库，一个新库。主要分为三步：</p>
<p>​ 导入历史数据阶段：数据库双写，查询走老数据库，通过定时任务补全新老数据差异。</p>
<p>​ 新老数据无差异阶段：数据库双写，查询走新数据库。</p>
<p>​ 稳定运行阶段，移除旧数据库。</p>
</blockquote>
<h3 id="数据库join操作">数据库join操作</h3>
<blockquote>
<p>对于分库后join操作可以使用的解决方法：</p>
<p>​ <strong>全局表</strong>：对于系统各模块都依赖的表可以在每个数据库中都存储一份。</p>
<p>​ <strong>字段冗余</strong>：对于常使用的字段，各模块表都冗余备份一次。但是难以保证数据一致性。</p>
<p>​ <strong>系统层面组装</strong>：在系统层面，调用不同模块的组件或服务，获取数据并拼接。</p>
</blockquote>
<h2 id="tips">Tips</h2>
<blockquote>
<p>InnoDB存储引擎处理死锁的方式是，将持有最少行级排他锁的事务进行回滚。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础突击</title>
    <url>/2021/03/10/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="数据库基础突击">数据库基础突击</h1>
<h2 id="基本关系代数">基本关系代数</h2>
<figure>
<img src="/2021/03/10/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%AA%81%E5%87%BB/基本关系代数.png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="数据库的范式">数据库的范式</h2>
<blockquote>
<p>数据库第一范式：属性不可再分特性。即所以字段都是不可分割的原子值，如一个字段为用户信息：姓名 + 生日，就不符合第一范式。</p>
<p>数据库第二范式：确保表中的每列都和主键相关。而不能只是部分相关。如主键为订单号和商品号，有些信息只依赖商品号，就破坏了第二范式，需要拆分成两个表。</p>
<p>第三范式：属性不依赖于其它非主属性，属性直接依赖于主键。如一个学生表，主键为学生id，这个表格中还存有学生的班主任相关信息，此时相关信息依赖班主任，需要拆分。</p>
</blockquote>
<h2 id="sql注入">SQL注入</h2>
<blockquote>
<p>本质上就是利用输入，对sql语句进行拼接，如拼接or 1 = 1的语句。在查询操作时在条件后拼接or 1 = 1 可以直接获取数据库的全部数据。</p>
<p>防止的方法：使用preparedStatement处理参数，本质上就是就是在参数处添加了单引号，避免参数直接作为表达式被拼接到sql中。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>智力题突击</title>
    <url>/2021/03/09/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%99%BA%E5%8A%9B%E9%A2%98%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="智力题突击">智力题突击</h1>
<h2 id="海量数据处理">海量数据处理</h2>
<h3 id="通用的数据结构方法">通用的数据结构/方法</h3>
<blockquote>
<p>布隆过滤器(Bloom filter)：即位数组+多个hash函数，求文件字符重复。位数组大小可以根据数学公式计算n为预估的数据量，p为希望的误判率。</p>
<figure>
<img src="/2021/03/09/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%99%BA%E5%8A%9B%E9%A2%98%E7%AA%81%E5%87%BB/布隆过滤器公式.png" alt="布隆过滤器公式"><figcaption aria-hidden="true">布隆过滤器公式</figcaption>
</figure>
<p>hash：往往用于将重复的记录整合，统计。也可以用于拆分小文件。</p>
<p>位图(bitmap)：可以用于对数据的快速判重。即创建一个最大值+1大小 / 8的整型数组，将数组的每一位用于判断数据是否存在。</p>
<p>堆：适用于找出海量数据的前n大的数。</p>
<p>双层桶划分：适用于第k大，中位数，不重复或可重复的数字。</p>
<p>外排序：适用于大数据的排序。</p>
</blockquote>
<h3 id="海量日志数据提取出某日访问百度次数最多的那个ip">海量日志数据，提取出某日访问百度次数最多的那个IP。</h3>
<blockquote>
<p>IP总数为2^32，约4G大小无法直接在内存中计算，可以考虑利用hash函数如将IP%1024，将不同的IP散列到不同的文件，然后对单个文件进行处理，如使用一个hashmap来统计，得到该文件中访问次数最多的IP，然后再将这1024个IP进行对比，找出总体最大的IP。</p>
</blockquote>
<h3 id="假设目前有一千万个记录这些查询串的重复度比较高虽然总数是1千万但如果除去重复后不超过3百万个单个记录大小0-255b请你统计最热门的10个查询串要求使用的内存不能超过1g">假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。单个记录大小0-255B），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</h3>
<blockquote>
<p>可以利用hash表将记录进行hash处理，以记录为key，以次数为value，大致可以将占用的空间只需 300w * 255 = 750M，然后转化为topk问题，可以维护一个容量为10的堆，遍历hash表，假设每个值都需要维护堆，则总时间复杂度为O(Nlog10)。</p>
</blockquote>
<h3 id="有一个1g大小的一个文件里面每一行是一个词词的大小不超过16字节内存限制大小是1m返回频数最高的100个词">有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h3>
<blockquote>
<p>和日志问题相同，也是遍历文件采用hash函数将文件拆分为5000个200B大小的小文件，然后统计各小文件中前100词频的词，再写入小文件，最后整合这些词频进行比较。</p>
</blockquote>
<h3 id="有10个文件每个文件1g每个文件的每一行存放的都是用户的query每个文件的query都可能重复要求你按照query的频度排序">有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h3>
<blockquote>
<p>依旧可以顺序读取10个文件，然后利用hash函数将其分为10个小文件，再统计小文件中query的频度，最后对各小文件进行归并排序即可。</p>
</blockquote>
<h3 id="给定ab两个文件各存放50亿个url每个url各占64字节内存限制是4g让你找出ab文件共同的url">给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url</h3>
<blockquote>
<p>方法1：先使用hash将a文件拆分为多个小文件，然后利用同样的hash对b进行处理也拆分为多个小文件，然后将a、b对应的小文件进行比对，如果发现url相同则输出到结果文件中，对全部的小文件进行处理最后即可得到相同的url。</p>
<p>方法2：使用布隆过滤器。4G内存可以映射4 * 1024 * 1024 * 1024 * 8 约340亿bit，然后将a的url利用布隆过滤器映射到这些bit上，然后再将b的url利用布隆过滤器进行筛选即可获知是否存在共同的url。这种方法存在一定的错误率。</p>
</blockquote>
<h3 id="在2.5亿个整数中找出不重复的整数注内存不足以容纳这2.5亿个整数">在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h3>
<blockquote>
<p>1G内存有1024 * 1024 * 1024 * 8 约85亿个bit，2.5亿个数若一个数使用2个bit，00表示没有出现，01表示出现一次，10表示出现多次。则存放2.5亿数只要5亿bit，约70MB，然后遍历这些数，修改bitmap。最后对bitmap进行查询即可知道哪些数是不重复的。</p>
</blockquote>
<h3 id="腾讯面试题给40亿个不重复的unsigned-int的整数没排过序的然后再给一个数如何快速判断这个数是否在那40亿个数当中">腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h3>
<blockquote>
<p>方法1：使用512M大小内存作为位图，可以大致存储40亿bit，每个bit用于表示数的状态，0表示出现过，1表示未出现。然后将给定的数，使用位图进行查询即可判断是否在那40亿个数中。</p>
<p>方法2：默认40亿个数是放在一个文件中，然后对40亿个数按最高位是否为0/1，划分成两个文件，再对这两个文件按次高位为0/1，划分出两个文件，直至全部都划分完毕。然后对于给定的数，只需要判断这个数是否可以找到对应文件即可。</p>
</blockquote>
<h3 id="现有两个各有20亿行的文件每一行都只有一个数字求这两个文件的交集">现有两个各有20亿行的文件，每一行都只有一个数字，求这两个文件的交集。</h3>
<blockquote>
<p>可以使用bitmap：数字上限为2^32 - 1约4G，则可以用512M空间作为bitmap，遍历一个文件，获取bitmap，然后使用bitmap对另一个文件进行判断即可。</p>
</blockquote>
<h3 id="海量数据中位数只有2g内存的pc机在一个存有10g个整数的文件从中找到中位数写一个算法">海量数据中位数，只有2G内存的pc机，在一个存有10G个整数的文件，从中找到中位数，写一个算法。</h3>
<blockquote>
<p>方法1：可以按最高位是否为1/0对数据进行拆分成两个文件，然后判断中位数在哪个文件中，然后对那个文件进行按次高位为0/1进行拆分，再判断中位数在哪个文件中，直到可以将数据读入pc进行排序计算中位数为止。</p>
<p>方法2：可以使用桶排序，假定整数为int32，即占32bit，取高8bit分桶，即分出255个桶，将桶写入磁盘中，然后依次统计桶数量，判定中位数在哪个桶中。然后将该桶读入内存找出中位数即可。</p>
</blockquote>
<h3 id="个玩家的战斗力要排名前500名而且需要实时更新怎么处理">100000个玩家的战斗力，要排名前500名，而且需要实时更新，怎么处理？</h3>
<blockquote>
<p>不能全部玩家的数据都实时更新，可以通过记录前1000/2000名玩家的数据并对其进行实时更新，从而排名前500名。而对于普通玩家可以在他们本机记录他们的战斗力成长情况，若成长太快超过一定阈值，可以利用一些机制让该玩家加入实现更新的队伍中。</p>
</blockquote>
<h2 id="智力题">智力题</h2>
<h3 id="匹马五条赛道选出前三需要几轮">25匹马，五条赛道，选出前三需要几轮？</h3>
<blockquote>
<p>先每5匹比一轮共5轮可以选从前5的马，假定排序为A1、B1、C1、D1、E1。此时可以排除D列、E列及A4、A5、B3/4/5、C2/3/4/5。且获知A1为第一。故只需在A2/3、B1/2、C1中取前二即可，故只需6轮。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">E</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">5</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="瓶水1瓶毒药10只老鼠毒药一天发作需要多久选出毒药">999瓶水，1瓶毒药10只老鼠，毒药一天发作，需要多久选出毒药？</h3>
<blockquote>
<p>即给每瓶水编号。从0到1000，可以使用<span class="math inline">\(2^{10}\)</span>表示，即每个老鼠代表一位。然后对应编号的水喂给对应编号的老鼠，最后看死的老鼠是哪几只从而判断出哪瓶药是有毒的。</p>
</blockquote>
<h3 id="的两个数把和告诉a积告诉ba说不知道是多少b也说不知道这时a说我知道了b接着说我也知道了问这两个数是多少">1-20的两个数把和告诉A,积告诉B，A说不知道是多少，B也说不知道，这时A说我知道了，B接着说我也知道了，问这两个数是多少？</h3>
<blockquote>
<p>由于开始时A、B都不知道，显然和至少有两种计算，积也至少有两种计算。</p>
<p>故积不可能为质数，按从小到大考虑，1,2,3,4。4不为质数，然后验证其加法是否存在多种，即2+2和1+3。故可知数可能为2，2。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>智力题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法突击</title>
    <url>/2021/03/09/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="算法突击">算法突击</h1>
<h2 id="排序算法">排序算法</h2>
<blockquote>
<p>快速排序<span class="math inline">\(O(nlogn)\)</span>、冒泡排序<span class="math inline">\(O(n^2)\)</span>、选择排序<span class="math inline">\(O(n^2)\)</span>、插入排序<span class="math inline">\(O(n^2)\)</span>、堆排序<span class="math inline">\(O(nlogn)\)</span>、归并排序<span class="math inline">\(O(nlogn)\)</span>、希尔排序<span class="math inline">\(O(n^{1.3})\)</span></p>
<p>计数排序<span class="math inline">\(O(n+k)\)</span>、桶排序<span class="math inline">\(O(n+k)\)</span>、基数排序<span class="math inline">\(O(d*(n+r))\)</span></p>
<p><strong>冒泡排序</strong>：即从小到大依次比较交换。</p>
<p><strong>选择排序</strong>：即先遍历选出最大/最小。</p>
<p><strong>插入排序</strong>：即从第1个数开始认为有序，遍历整个数组不断维护其中的有序部分。如a[0]=3，a[1]=1，按从小到大排序的话，遍历到a[1]时会将a[0]和a[1]交换位置。</p>
<p>希尔排序：</p>
<p><strong>归并排序</strong>：即先将数据拆分到只剩单个数为止，然后两两排序再合并。</p>
<p><strong>快速排序</strong>：即先选择一个基准值然后按基准值将数据分为左右两个部分，然后在这两个部分再执行此过程。</p>
<p><strong>堆排序</strong>：即构建数据构建堆。</p>
<blockquote>
<p>非比较排序</p>
</blockquote>
<p><strong>计数排序</strong>：构建数据的最大值创建对应大小的数组，然后遍历数据，访问到对应数据在对应数组位置加1，然后最后读取数组即可。</p>
<p><strong>桶排序</strong>：划分多个范围相同的区间，每个子区间自排序，最后合并。</p>
<figure>
<img src="/2021/03/09/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/桶排序.png" alt="桶排序"><figcaption aria-hidden="true">桶排序</figcaption>
</figure>
<p>基数排序：</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构突击</title>
    <url>/2021/03/07/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="数据结构突击">数据结构突击</h1>
<h2 id="树">树</h2>
<h3 id="二叉树">二叉树</h3>
<blockquote>
<p>即每个结点都带有左右子树的树结构</p>
</blockquote>
<h3 id="二叉搜索树">二叉搜索树</h3>
<blockquote>
<p>在二叉树的基础上需要满足任一子树，左孩子的值小于根节点值，右孩子的值大于根节点值。</p>
<p>优点：既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p>
<p>缺点：在特定情况下，如插入都是按序插入，会导致树结构退化为链表。查找效率下降。</p>
</blockquote>
<h3 id="二叉平衡树">二叉平衡树</h3>
<blockquote>
<p>特点：是高度平衡的二叉搜索树，要求左右子树高度差绝对值不超过1，且左右子树都是二叉搜索树。</p>
<p>优点：由于树高度平衡，让查找操作的时间复杂度变为O(logN)。</p>
<p>缺点：由于对树的平衡要求过高，导致每次插入和删除操作需要耗费大量资源对树进行平衡，耗费大量性能。</p>
<p>适用场景：读多写少的场景。</p>
</blockquote>
<h3 id="红黑树">红黑树</h3>
<blockquote>
<p>特点：基于二叉平衡树的优点和缺点，红黑树放宽了树的平衡条件。最终会让根到叶子节点的路径最长不超过最短的两倍。它的特点为：</p>
<p>​ 具有二叉查找树的特点。</p>
<p>​ 根节点是黑色的。</p>
<p>​ 每个叶子节点都是黑色的空节点，即叶子节点不存数据。</p>
<p>​ 任何相邻的节点不能同时为红色，即红色节点是被黑色节点隔开的。</p>
<p>​ 每个结点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点。</p>
<p>优点：红黑树对于平衡条件要求不是十分严格，让每次插入、删除操作的开销减少，且平衡条件也避免了像二叉搜索树退化成链表的情况，使得搜索操作时间复杂度是O(logN)。</p>
<p>适用场景：写频繁的场景。</p>
</blockquote>
<h3 id="b树">B树</h3>
<blockquote>
<p>是一种多路平衡查找树，为了针对磁盘等存储设备设计的。读取磁盘往往是以磁盘块为单位的，位于同一个磁盘块的数据会被一次性读出。InnoDB存储引擎中有页的概念，默认每个页大小为16KB。</p>
<p>一个m阶的B-Tree的特性：</p>
<p>​ 每个结点最多有m个孩子。</p>
<p>​ 除了根节点和叶子节点外，其他每个节点至少有Ceil(m/2)个孩子。</p>
<p>​ 若根节点不是叶子节点，则至少有2个孩子。</p>
<p>​ 所有叶子结点在同一层，且不含其他关键字信息。</p>
<p>​ 非叶子结点大致是由指针，关键字，数据组成。</p>
<p>操作：</p>
<p>​ 插入：B树的插入在<strong>叶结点</strong>，当结点空间满了，则分裂为两个相邻结点，中间关键字上移到父节点中。若父节点也满了，同样分裂并上移，直至根节点，<strong>若根节点也满了，则中间元素上移到新的根结点中，树的深度增加一层</strong>。</p>
<p>​ 删除：若没有左右孩子结点，则直接删除，否则将孩子结点中相近的结点上移到当前节点中。然后调整平衡性。</p>
<p>优点：经常访问的数据可能离根节点较低，需要的I/O查询次数少，从而效率高。</p>
<p>缺点：由于节点既存放数据又存放指针，导致每个节点可以指向的数据块数量少，从而导致树的高度高，且由于数据分布在各层，也导致查询数据的I/O次数不同，使得耗时难以估计。由于叶子之间没有联系，无法从一个叶子结点找到另一个叶子结点，故B-树难以进行范围查询。</p>
</blockquote>
<h3 id="b树-1">B+树</h3>
<blockquote>
<p>对B-树进行优化，将所有的数据都放在叶子结点，其他结点只存放关键字和孩子指针，且所有的叶子结点和相连的结点使用链表相连，便于范围查找和遍历。</p>
<p>优势：B+数在内部节点上不含数据信息，使得内部节点可以存放更多的索引信息，降低了树高，减少了I/O查询次数。且B+树的叶子结点是相连的，对树的遍历只需要一次线性遍历，而B-树需要每层递归遍历。</p>
<p>具体计算：</p>
<p>​ 以InnoDB为例，默认页大小为16KB，若主键占8B，指针占8B，一条记录占1KB大小，则每个页可以存放1K的索引信息，16条记录，若树高为一(即只有根节点和叶子节点)则可以获取的记录数为1K * 16 = 16K，树高为2则可以获取的记录为 16M，树高为3可以获取的记录为16G。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis突击</title>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/redis%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="redis突击">redis突击</h1>
<h2 id="redis为什么快">redis为什么快？</h2>
<blockquote>
<p>单线程：因为一开始的redis认为redis速度的瓶颈不在于cpu运算速度，而往往在于网络带宽和机器内存大小。所以redis主要使用单线程，编程简单且没有线程切换的开销。</p>
<p>数据存放在内存中。</p>
<p>使用了I/O多路复用技术，非阻塞I/O。</p>
</blockquote>
<h3 id="redis线程模型">redis线程模型</h3>
<blockquote>
<p>Redis处理网络请求是使用单线程Reactor模型，通过IO多路复用技术提高并发。</p>
<p>Redis内部使用file event handler，该处理器是单线程的，故redis叫做单线程模型。</p>
<p>客户端和redis的通信过程：</p>
<figure>
<img src="/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/redis%E7%AA%81%E5%87%BB/redis客户端操作流程.png" alt="redis客户端操作流程"><figcaption aria-hidden="true">redis客户端操作流程</figcaption>
</figure>
</blockquote>
<h2 id="redis数据结构">redis数据结构</h2>
<blockquote>
<p>API数据结构：String、Hash、List、Set、SortedSet、HyperLogLog(可以用于统计网页每天的用户访问量数据)、Geo、Bitmap(可以用来记录用户的在线状态，使用天为key，用户id作为offset)、Stream(主要用于消息队列)</p>
</blockquote>
<h3 id="redis底层数据结构">redis底层数据结构</h3>
<blockquote>
<p>SDS、dict、ziplist、quicklist、skiplist、intset。</p>
<p>SDS：redis自己实现的动态字符串。结构如下，该结构将字符串长度作为一个单独字段，使得每次查询字符串长度的时间复杂度为O(1)。</p>
<p>该字符串的优势：</p>
<p>​ 降低获取字符串长度的时间复杂度到O(1)。</p>
<p>​ API 是安全的，不会造成缓冲区溢出。即使用时会预先检测当前大小是否足够使用。</p>
<p>​ 减少了修改字符串时的内存重分配次数。</p>
<p>​ 兼容c字符串的同时，提高了一些字符串工具方法的效率。</p>
<p>​ 二进制安全（数据写入的格式和读取的格式一致）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line"> <span class="comment">//字符串真实长度</span></span><br><span class="line"> <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line"> <span class="comment">//字符串除头部和终止符外的长度，即已分配的长度</span></span><br><span class="line"> <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line"> <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dict：redis实现的类似哈希表结构。具体结构如下：</p>
<p>它和传统的哈希算法类似，采用拉链法来解决冲突。主要不同在于它使用增量式重哈希的方法进行重哈希。在需要扩展内存时避免一次性对所有key进行重哈希，而是将重哈希操作分散到对dict的各个增删改查操作中去。每次只对一部分key进行重哈希，每次重哈希之间不影响dict操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"> dictType *type;</span><br><span class="line"> <span class="keyword">void</span> *privdata;</span><br><span class="line"> <span class="comment">//为了增量式重hash，redis的dict结构包含两个哈希表</span></span><br><span class="line"> dictht ht[<span class="number">2</span>];</span><br><span class="line"> <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>ziplist：经过特殊编码的双向链表。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而 ziplist 却是将表中每一项存放在前后 <strong>连续的地址空间</strong> 内，一个 ziplist 整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p>
<p>优点：减少了两个指针空间开销，节约内存。</p>
<p>缺点：每次插入或修改可能引发realloc，导致内存拷贝，降低性能。</p>
<p>​ 当数据过多时查找操作开销大，性能低。</p>
<p>quicklist：是以ziplist为节点组成的双向链表，ziplist本身也是可以维持数据项先后顺序的列表，且是内存紧缩的列表。</p>
<p>设计思路：空间和时间的折中。双向链表便于两端的push和pop操作，但内存开销大。ziplist是连续内存，存储效率高但不利于修改。quicklist则将二者进行结合。可以通过list-max-ziplist-size配置quicklist的ziplist最大长度。</p>
<p>skiplist：跳表，是一种有序的数据结构，通过每个节点维持多个指向其他结点的指针，达到快速访问结点的目的。</p>
<p>intset：由整数组成的<strong>有序集合</strong>，从而在上面进行二分查找。其内存分配类似ziplist也使用连续内存空间。其用于存储元素都是整数的小集合。</p>
</blockquote>
<h3 id="api数据结构和底层数据结构的关联">API数据结构和底层数据结构的关联</h3>
<blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">API数据结构</th>
<th style="text-align: center;">限制</th>
<th style="text-align: center;">具体底层实现</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">string</td>
<td style="text-align: center;">512 MB</td>
<td style="text-align: center;">SDS</td>
</tr>
<tr class="even">
<td style="text-align: center;">list</td>
<td style="text-align: center;">最大长度 <span class="math inline">\(2^{32}-1\)</span></td>
<td style="text-align: center;">quicklist</td>
</tr>
<tr class="odd">
<td style="text-align: center;">set</td>
<td style="text-align: center;">最大容量 <span class="math inline">\(2^{32}-1\)</span></td>
<td style="text-align: center;">intset(小整数集) 、dict</td>
</tr>
<tr class="even">
<td style="text-align: center;">sorted set</td>
<td style="text-align: center;">最大容量 <span class="math inline">\(2^{32}-1\)</span></td>
<td style="text-align: center;">ziplist(小集合)、dict + skiplist</td>
</tr>
<tr class="odd">
<td style="text-align: center;">hash</td>
<td style="text-align: center;">最大KV容量 <span class="math inline">\(2^{32}-1\)</span></td>
<td style="text-align: center;">ziplist(小集合)、dict</td>
</tr>
<tr class="even">
<td style="text-align: center;">bitmap</td>
<td style="text-align: center;">512 MB</td>
<td style="text-align: center;">SDS</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="redis数据淘汰机制">redis数据淘汰机制</h2>
<blockquote>
<p>redis的回收过期对象策略，分为<strong>定期删除</strong>和<strong>惰性删除</strong>两种。</p>
<p><strong>定期删除</strong>即默认x时间随机抽取一些设置了过期时间的key去检查是否过期，过期了则删除。</p>
<p><strong>惰性删除</strong>即等到使用到这个key时再去检测是否过期，若过期则删除。</p>
<p>当redis内存使用超过一定限制时会进行内存淘汰，redis的内存淘汰策略：</p>
<p>​ 主要分为针对设置了过期时间key和未设置过期时间key。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">默认策略noeviction</th>
<th style="text-align: center;">到达阈值时再申请内存报错</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">allkeys-lru</td>
<td style="text-align: center;">对所有key采用LRU策略删除。(实际上是采样删除)</td>
</tr>
<tr class="even">
<td style="text-align: center;">volatile-lru</td>
<td style="text-align: center;">在设置过期时间的key中使用LRU策略删除</td>
</tr>
<tr class="odd">
<td style="text-align: center;">allkeys-random</td>
<td style="text-align: center;">在主键空间中，随机移除某个key</td>
</tr>
<tr class="even">
<td style="text-align: center;">volatile-random</td>
<td style="text-align: center;">在设置了过期时间的key中，随机删除某个key</td>
</tr>
<tr class="odd">
<td style="text-align: center;">volatile-ttl</td>
<td style="text-align: center;">在设置过期时间的key中，过期时间早的优先被删除</td>
</tr>
</tbody>
</table>
<p>随机淘汰、ttl淘汰即淘汰即将过期的数据、LRU淘汰最近最少使用的数据。</p>
</blockquote>
<h2 id="缓存击穿缓存雪崩缓存穿透">缓存击穿、缓存雪崩、缓存穿透</h2>
<blockquote>
<p><strong>缓存雪崩</strong>：本质上就是在redis中存放的大量key过期时间设置为相同时间，导致同一时间大批key都过期了，从而导致一瞬间大量请求都进入数据库中，使得数据库瞬间承受大量流量直接无法提供服务。</p>
<p>解决方案：在设置key的过期时间时添加一个随机初始值，让每个key的过期时间尽量分散。</p>
<p><strong>缓存穿透</strong>：指缓存中没有且数据库中也不存在的值被反复请求，如数据库采用自增id，显然都只能是正数，而请求不断访问负数id，会导致流量一直进入数据库，使数据库压力过大，无法提供服务。</p>
<p>解决方案：首先考虑能不能再未访问缓存前就拦截，比如在接口层面进行参数校验，判断id是否合法，用户是否正常。</p>
<p>​ 其次，利用布隆过滤器，将无法访问的数据库先加载到布隆过滤器中，当访问缓存时先通过布隆过滤器过滤，发现未命中才去访问redis。</p>
<p>​ 还可以在访问到无效key时，先给这个key附上一个临时值，让同时访问到这个key的用户可以临时使用缓存。</p>
<p><strong>缓存击穿</strong>：指缓存中本来存在的热点key，到了过期时间，大量请求直接访问到数据库，使得数据库压力过大，无法提供服务。</p>
<p>解决方案：本质上就是解决<strong>热点key</strong>问题，如果已经发现了热点key，可以将对应key的过期时间设置为永不过期。还可以通过设置互斥锁(redis分布式锁)来让请求串行化避免同时有大量请求打入数据库。</p>
<p>主要问题在于怎么确定热点key：</p>
<p>​ 根据业务需求提前找出热点key。</p>
<p>​ 当客户端发出请求时收集对应key数据，然后分析这些数据找出热点key。</p>
<p>​ 如果在redis集群前还设计了代理层，可以在代理层统计具体数据。</p>
<p>找出热点key后可以通过以下方法解决：</p>
<p>​ 采用二级缓存，即在本地JVM上创建一个hashmap存储缓存。</p>
<p>​ 可以对redis的key切片，即key+随机值均匀分布到多个redis实例上，访问时也随机访问即可。</p>
</blockquote>
<h2 id="redis集群部署">redis集群部署</h2>
<blockquote>
<p>主要由redis Sentinel哨兵集群和redis cluster集群。</p>
<p>redis sentinel哨兵集群：本质上就是一台redis实例作为主，多台redis实例作为从，每个实例中都有一个sentinel作为哨兵，且哨兵数目至少为3个。哨兵作用是查看主redis是否宕机了，若超过一半的哨兵认为主redis宕机，那么就会执行切换流程。哨兵用于监听主机消息，从机则是用于处理读请求，主机负责写请求。</p>
<p>而redis cluster集群：redis哨兵集群的改进版本，多机版本的redis，通过分槽来管理每个redis的数据命中，让数据可以分散到各个redis实例中。常见场景为3主3从，即将槽分为三个区间，每个redis主机负责一个区间，然后主机之间充当哨兵的作用，检测到某个主机宕机了，则让对应从机升级。</p>
</blockquote>
<h2 id="redis-持久化rdb和aof">redis 持久化RDB和AOF</h2>
<blockquote>
<p>因为redis集群部署时往往存在主从的概念，主从之间怎么传递数据呢？</p>
<p>首先这个问题要知道redis持久化的方式。</p>
<p>redis提供两种持久化的方式：RDB和AOF</p>
<p><strong>RDB</strong>：在指定时间间隔对数据进行快照全量备份。</p>
<p>​ 触发方式：</p>
<p>​ 命令触发：Save：阻塞当前redis服务器，直到持久化完成。</p>
<p>​ bgsave：fork一个子进程，由子进程负责持久化过程。</p>
<p>​ 自动触发：根据配置文件的save m n配置规则自动触发。</p>
<p>​ 从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点触发bgsave。</p>
<p>​ 执行debug reload时</p>
<p>​ 执行shutdown且没有开启aof时也会触发。</p>
<p>​ 数据恢复方式：将备份文件(dump.rdb)移动到redis安装目录并启动服务即可。</p>
<p>优点：RDB会产生多个数据文件，每个数据文件分别都代表了某一时刻Redis里的数据。且RBD对redis的性能影响较小，因为同步数据时只是fork了一个子进程进行持久化的，且数据恢复时比AOF来的快。</p>
<p>缺点：RDB是快照文件，默认5分钟或者更久时间才生成一次，导致五分钟内数据丢失。且若RDB生成数据快照时文件很大会导致客户端暂停几毫秒甚至几秒。</p>
<p><strong>AOF</strong>：相当于把每条指令作为日志，通过追加写入的方式写入到日志文件。类似binlog。</p>
<p>​ 一般来说AOF可以更好地保护数据不丢失，一般设置每隔1秒执行一次AOF持久化，redis会通过一个后台线程执行一次fsync操作。</p>
<p>​ 由于AOF是对指令作为日志进行写入，所以往往让AOF文件体积过大，redis对这种现象提供了AOF重写机制，但是即使执行重写操作也不会影响客户端对redis的读写，因为redis在重写rewrite aof时会对指令进行压缩，创建出一份需要恢复数据的最小日志出来。创建新日志时老日志文件还是照常写入，当新的merge的日志文件ready时，再交换新老日志文件即可。</p>
<p>优点：可以每秒一次数据持久化，让数据丢失最多不超过一秒，且日志写入是以追加写入的方式进行的，避免磁盘的随机写。</p>
<p>​ AOF文件一般是可读的方式进行写入的，打开AOF文件可以看到先前执行的操作。</p>
<p>缺点：数据相同时AOF的文件大小往往远大于RDB大小，AOF开启后，redis支持的写QPS比RDB支持的写QPS小。</p>
<p><strong>具体持久化选择</strong>：RDB+AOF，每隔一段时间使用RDB进行全量备份，然后数据恢复时利用RDB文件快速恢复，再使用AOF文件对RDB文件缺少的数据进行补充。</p>
</blockquote>
<h3 id="redis主从数据同步">redis主从数据同步</h3>
<blockquote>
<p>一般来说redis主机负责写入操作，redis从机负责读操作。二者数据同步就是利用redis持久化机制实现的。</p>
<p>当启动一个从机slave时，它会发送一个<strong>psync</strong>指令给主机，若这个从机是第一次连接到主机，主机会进行一次全量复制。主机启动一个线程生成RDB快照，然后把新的写请求都缓存到内存中，RDB文件生成后，主机会将RDB文件发送给从机，从机获取RDB后会将数据写入磁盘，然后加载到内存。最后主机将内存中缓存的新命令发送给slave进行同步。</p>
</blockquote>
<h2 id="redis常见用法">redis常见用法</h2>
<h3 id="假如redis里面有1亿个key其中有10w个key是以某个固定的已知的前缀开头的如何将它们全部找出来">假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h3>
<blockquote>
<p>使用keys指令，然后给定pattern即可查询出结果。</p>
<p>由于redis是单线程的，使用keys指令在数据量大时可能导致redis被堵塞，可以通过scan index MATCH pattern的形式来达到同样的目的。且scan由于可以设置下标，一次查询的key数据量不会过大，不容易堵塞redis。</p>
</blockquote>
<h3 id="redis实现分布式锁">redis实现分布式锁</h3>
<blockquote>
<p>通过设置setnx key和key的expire过期时间。</p>
</blockquote>
<h3 id="redis实现异步队列">redis实现异步队列</h3>
<blockquote>
<p>通过list结构，<strong>rpush</strong>生成消息，<strong>lpop</strong>消费消息，或者使用<strong>blpop</strong>消费消息，使得没有消息可以消费时可以堵塞住消费者。</p>
</blockquote>
<h3 id="redis实现延时队列">redis实现延时队列</h3>
<blockquote>
<p>通过redis的SortedSet结构，以时间戳作为score，消息内容作为key，通过ZADD KEY timestamp task来生产消息，消费者通过轮询ZRANGEBYSCORE KEY -inf +inf limit 0 1 WITHSCORES的方式来获取数据，然后比对时间戳消息，若存储的时间戳大于当前时间戳则说明还无须执行，让消费者sleep一段时间再轮询。</p>
<p>具体架构</p>
<figure>
<img src="/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/redis%E7%AA%81%E5%87%BB/延迟队列架构.png" alt="延迟队列架构"><figcaption aria-hidden="true">延迟队列架构</figcaption>
</figure>
<p>生产者通过hash算法将延迟任务分散到不同的redis key中避免一个key存储大量延时消息。</p>
<p>然后对每个redis key建立一个Event处理进程，所有的处理进程只负责分发消息，具体的业务逻辑则引入额外的消息队列进行处理。</p>
<p>Event进程则采用Zookeeper选主单进程部署的方式，避免Event进程宕机后，redis key消息堆积的情况。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发突击</title>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/java%E5%B9%B6%E5%8F%91%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="java并发突击">Java并发突击</h1>
<figure>
<img src="/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/java%E5%B9%B6%E5%8F%91%E7%AA%81%E5%87%BB/Users\SmallYe\Desktop\blog\source_posts\面试突击\java并发突击\CPU术语.png" alt="CPU术语"><figcaption aria-hidden="true">CPU术语</figcaption>
</figure>
<h2 id="volatile实现原理">Volatile实现原理</h2>
<blockquote>
<p>当字段被声明为volatile时，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p>本质上是通过编译后在指令后添加<strong>lock指令</strong>。lock指令的作用是：</p>
<p>​ 将当前处理器缓存行的数据写回系统内存。</p>
<p>​ 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</p>
</blockquote>
<h2 id="synchronized实现原理">Synchronized实现原理</h2>
<blockquote>
<p>synchronized实现同步的基础：Java中的每个对象都可以作为锁。</p>
<p>对于普通同步方法，锁住当前实例对象。</p>
<p>对于静态同步方法，锁住当前类Class对象。</p>
<p>对于同步方法块，锁住的是synchronized括号内配置的对象。</p>
<p>JVM规范中指出Synchronized实现的原理是<strong>基于进入和退出Moniter对象来实现方法同步和代码块同步</strong>，即在编译后将monitorenter指令插入到同步代码块后，将monitorexit插入到方法结束处和异常处。JVM保证每个monitorenter和monitorexit配对。</p>
</blockquote>
<h4 id="synchronized锁优化及实质">Synchronized锁优化及实质</h4>
<blockquote>
<p>synchronized用的锁是存在Java对象头中的。若对象是数组类型，虚拟机使用3个字宽存储对象头，非数组类型用2字宽存储对象头。</p>
<figure>
<img src="/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/java%E5%B9%B6%E5%8F%91%E7%AA%81%E5%87%BB/Users\SmallYe\Desktop\blog\source_posts\面试突击\java并发突击\Java对象头.png" alt="Java对象头"><figcaption aria-hidden="true">Java对象头</figcaption>
</figure>
<p>Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。</p>
<figure>
<img src="/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/java%E5%B9%B6%E5%8F%91%E7%AA%81%E5%87%BB/Users\SmallYe\Desktop\blog\source_posts\面试突击\java并发突击\MarkWord变化.png" alt="MarkWord变化"><figcaption aria-hidden="true">MarkWord变化</figcaption>
</figure>
<p>JDK1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在JDK6后锁共4中状态依次为：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>。这几个状态会随竞争情况逐渐升级，锁可以升级但不能降级。</p>
<p><strong>偏向锁</strong>：</p>
</blockquote>
<h2 id="线程创建的方式">线程创建的方式</h2>
<blockquote>
<p>继承thread类，重写run方法</p>
<p>实现runnable接口，重写run方法。</p>
<p>实现callable接口，实现call方法</p>
</blockquote>
<h2 id="线程池">线程池</h2>
<blockquote>
<p>为什么使用线程池？</p>
<p>​ 为了避免线程的创建、销毁导致的线程开销，采用线程池管理一定数量的线程达到可复用线程的效果。</p>
<p>Executors自带的线程池</p>
<p>​ <strong>newSingleThreadExecutor</strong>：单线程线程池，这个线程池只有一个线程在工作。</p>
<p>​ <strong>newFixedThreadPool</strong>：固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池最大大小。超出的线程会在队列中等待。</p>
<p>​ <strong>newCachedThreadPool</strong>：创建一个可缓存的线程池，当线程池大小超过了处理任务所需要的线程，会回收部分空闲线程，当任务增加时此线程池可以智能添加线程来处理任务。该线程池不会对大小进行限制。</p>
<p>​ <strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池，支持定时及周期性任务。</p>
<p>​ <strong>newSingleThreadScheduled</strong>：创建一个只有一个线程的线程池，支持定时及周期性任务。</p>
<p>​ <strong>newWorkStealingPool</strong>：创建一个拥有多个任务队列的线程池。</p>
<p>自带线程池的缺点，newSingleThreadExecutor和newFixedThreadPool创建了一个长度Integer.MAX_VALUE的阻塞队列，导致任务过多堆积时耗费大量内存，产生OOM错误。newCachedThreadPool和newScheduledThreadPool创建的线程池最大线程数量为Integer.MAX_VALUE，导致可能创建了大量的线程，消耗资源，甚至造成OOM。</p>
</blockquote>
<h2 id="自定义线程池">自定义线程池</h2>
<blockquote>
<p>自己创建线程池new ThreadPoolExecutor()可以传递参数：</p>
<p>​ corePoolSize：核心线程数量，即线程池会保持的线程数</p>
<p>​ maximumPoolSize：最大线程数量，即线程池</p>
<p>​ keepAliveTime：空闲线程最大存活时间</p>
<p>​ TimeUnit：时间单位</p>
<p>​ BlockingQueue：阻塞队列</p>
<p>​ ThreadFactory：线程工厂</p>
<p>​ RejectedExecutionHandler：拒绝策略</p>
</blockquote>
<h3 id="线程池执行execute的流程">线程池执行execute的流程</h3>
<blockquote>
<p>线程池状态有：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED</p>
<p>内部存在BlockingQueue即阻塞队列，阻塞队列是通过ReentrantLock实现的，其内部维护了一把锁。本质上就是在入队、出队等操作之前通过内部的锁上锁，操作结束后释放锁来完成的。</p>
<p>而操作时，入队、出队操作分为阻塞和非阻塞，阻塞操作如：当队列为空时若从阻塞队列中获取元素，则会被阻塞一定时间，再获取。这也是阻塞队列名字的来源。</p>
<p>当当前线程数少于核心线程数时会新增worker线程，以核心线程数为准。</p>
<p>若任务可以成功入队，则将任务入队，同时检测当前线程池状态，若为不是RUNNING状态则将任务移出队列且执行拒绝策略，若是RUNNING状态，且可用线程数为0则增加线程，以最大线程数为准。</p>
<p>若入队失败，则尝试创建新的worker，以最大线程数为准，若创建失败执行拒绝策略。</p>
</blockquote>
<h3 id="线程池拒绝策略">线程池拒绝策略</h3>
<blockquote>
<p>AbortPolicy：丢弃任务并抛出异常。</p>
<p>CallerRunsPolicy：判断当前线程池是否关闭，若未关闭则直接调用线程的run方法。</p>
<p>DiscardOldestPolicy：丢弃队列最前的任务，然后重新使用线程池执行被拒绝的任务。</p>
<p>DiscardPolicy：丢弃任务，什么也不做。</p>
<p>NewThreadRunsPolicy：创建一个线程去执行被丢弃的任务</p>
</blockquote>
<h2 id="juc">JUC</h2>
<h3 id="threadlocal">ThreadLocal</h3>
<blockquote>
<p>线程本地变量，创建一个线程独立的变量。</p>
<p>底层实现的原理：本质上是一个线程中存在一个ThreadLocalMap，用于存储ThreadLocal，该map的key为创建的ThreadLocal对象，而非Thread本身。</p>
<p>而<strong>内部存储k-v则是通过继承弱引用的Entry来实现的。</strong></p>
<p>get和set本质上也是hashmap类似的哈希计算获取对应数组位置存入，但是hashmap使用拉链法解决哈希冲突，ThreadLocal使用线性探测法解决。也存在扩容操作，一次扩容2倍。</p>
<p>而为什么ThreadLocal中<strong>Entry继承了弱引用WeakReference</strong>？</p>
<p>​ 因为若Entry也是强引用时，当外部线程不想使用该ThreadLocal时，即使停止引用，由于线程内部Entry是强引用且引用了ThreadLocal，那么ThreadLocal也不会被自动GC。而设置为弱引用，当外部线程不想使用时，GC可以在一次回收时将其回收，而ThreadLocalMap也设计了当发现key为null时清空value的操作。</p>
<p>为什么会内存泄漏？</p>
<p>​ 本质上是因为ThreadLocal和线程存活时间基本相同，而使用过程虽然使用弱引用，但是即使经过GC回收，还是会剩下key为null，value不为null的Entry存在于Map中。虽然ThreadLocal在执行操作时也会进行检测当前Entry key为null的位置，将其清除，但是这必须要通过我们主动调用，若没有调用则会一直存在。因此ThreadLocal对象使用结束后需要调用remove方法，使其从map中被移除，避免内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">  map.set(<span class="keyword">this</span>, value);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">  ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      T result = (T)e.value;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="abstractqueuedsynchronizeraqs">AbstractQueuedSynchronizer(AQS)</h3>
</blockquote>
<blockquote>
<p>AQS继承了AOS(AbstractOwnableSynchronizer)，AOS本质上就实现了对排他线程的保存。</p>
<p>内部通过state作为是否上锁的判断，当state为0时说明没有线程抢占到锁。可重入锁就是通过不断改变state实现的可重入。</p>
<p>内部维护了一个waitStatus，共有SIGNAL(-1表示表示后继结点需要unparking)、CANCELLED(1,表示该线程已经取消竞争)、CONDITION(-2节点正在等待)、PROPAGATE(表示头结点将唤醒的动作传播下去)、0(默认)的状态。</p>
<p>AQS中head结点没有使用，只起到标记的作用。</p>
<p>本质上只有两个方法acquire和release。如果是共享锁使用acquireShared和releaseShared</p>
<p>acquire如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先尝试获取资源，这里tryAcquire是由子类实现的。</p>
<p>如果没有成功获取则addWaiter，将线程放入等待队列的尾部，标记为独占模式。</p>
<p>acquireQueued当当前结点的前一个结点是头结点时会尝试抢占若抢占成功，头结点改为当前结点。抢占失败则将前驱结点的状态设为SIGNAL。</p>
<p>最后将线程挂起。</p>
<p>release：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用子类的tryRelease方法释放状态，当完全释放后，判断当前头结点waitStatus是否不为0，不为0则找出离头结点最近的且不为取消状态的结点进行unpark。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共享锁的话本质上就是将资源数目增多，每次抢占资源时会判断当前资源数目是否大于0，大于0则使用CAS抢占。抢占失败后执行doAcquireShared，类似独占锁的过程。先创建一个SHARABLE节点作为头结点，然后判断当前结点是否为头结点，若是头结点则进行抢占，抢占成功则根据当前资源数来决定是否还要进行抢占。抢占失败则将前驱结点设置的状态设置为SIGNAL。</p>
</blockquote>
<h3 id="reentrantlock">ReentrantLock</h3>
<blockquote>
<p>可重入锁本质上是针对一个线程的，当一个线程抢占成功锁之后，若线程内部还有进行锁操作，那么会将锁的state值增加，释放时则将该值减少，直到减少到0时又可以被重新抢占。</p>
<p>释放锁过程也是先判断逐步释放。判断当前释放锁之后锁状态是否为0，若为0则通过unpark方法唤醒队列中的后继线程。</p>
<p>java实现的锁的方式分为公平锁和非公平锁。</p>
<p>公平锁和非公平锁的队列都是基于ReentrantLock内部维护的Sync本质是个AQS。</p>
<p>公平锁的公平性体现在每次重新抢占时会先判断队列中是否存在等待线程，若存在则让队列的线程先抢夺。</p>
<p>非公平锁非公平体现在每次抢占时不会判断队列中是否存在等待线程，直接进行抢占。</p>
</blockquote>
<h2 id="synchronized和lock的区别">Synchronized和Lock的区别</h2>
<blockquote>
<p>加锁、解锁：</p>
<p>​ synchronized：自动加锁解锁。</p>
<p>​ lock：需要手动加锁、解锁。</p>
<p>性能上：</p>
<p>​ synchronized：没有优化前是悲观锁设计思想。性能差</p>
<p>​ lock：主要是乐观锁设置思想，如reentrantLock主要通过CAS操作抢夺锁。性能好</p>
<p>用法上：</p>
<p>​ 基本没区别，但是lock可以实现公平锁。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统突击</title>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="操作系统突击">操作系统突击</h1>
<h2 id="进程线程和协程">进程、线程和协程</h2>
<blockquote>
<p>进程是操作系统资源分配和调度的基本单位。每个进程有着自己的独立内存空间，不同进程之间使用进程间通信来通信。操作系统是以进程为单位分配系统资源(如CPU时间片、内存等资源)，进程是资源分配的最小单位。每个进程都有自己的地址空间，一般情况下，包括文本区域、数据区域和堆栈。</p>
<p>进程间通信的方法：</p>
<p>​ 管道：一种半双工的通信方式，数据只能单向流动，且只能在具有亲缘关系的进程间调用。</p>
<p>​ 消息队列：即将消息使用链表的形式存放在内核中并由消息队列标识符标识。</p>
<p>​ 信号量：本质上是一种计数器，可以用于控制多个进程对共享资源的访问。</p>
<p>​ 共享内存：映射一段能被其他进程所访问的内存，这个共享内存由一个进程创建，但由多个进程共享。它是最快的IPC方式，针对其他进程间通信效率低而设计的。</p>
<p>​ 信号：一种事件通知机制，进程可以通过发送信号给另一个进程，另一个进程则会根据收到的信号执行对应的处理方。</p>
<p>​ socket：</p>
<p>线程是依附于进程，是<strong>操作系统调度的最小单位</strong>。</p>
<p>线程间通信的方法：</p>
<p>​ 锁机制。</p>
<p>​ 信号量机制。</p>
<p>​ 信号机制。</p>
<p>​ voliate变量。</p>
<p>协程：不被操作系统内核所管理，完全是有程序所控制。</p>
</blockquote>
<h2 id="上下文切换过程">上下文切换过程</h2>
<blockquote>
<p>用户态到内核态什么时候切换？</p>
<p>​ 中断、系统调用、发生异常。</p>
<p>用户态内核态切换过程主要需要保存用户态的寄存器，返回时会切换回用户态。</p>
<p><strong>进程上下文切换发生的场景</strong>：</p>
<p>​ 1.运行中的进程执行完终止了，CPU 会释放出来，新的基础进程就可以被调度到CPU上运行了。</p>
<p>​ 2. 运行中的进程时间片用完，进程被挂起</p>
<p>​ 3.运行中的进程资源不足，进程被挂起</p>
<p>​ 4.运行中的进程执行Sleep方法主动挂起</p>
<p>​ 5.新进程优先级更高，运行中的进程被挂起</p>
<p>​ 6.发生硬件中断，运行中的进程会被中断挂起，转而执行内核中的中断服务程序。</p>
<p>进程上下文主要包含两个部分：<strong>寄存器如PC</strong>和<strong>操作系统所需的特定数据PCB</strong></p>
<p><strong>进程是由内核来管理和调度的，进程的切换只能发生在内核态。</strong>进程上下文包括虚拟内存、栈、全局变量等用户空间资源，还包括内核堆栈、寄存器等内核空间的状态。切换时需要保存的信息更多，而加入另一个进程的上下文时，也需要加载这个进程的虚拟内存和用户栈。</p>
<p>线程是操作系统调度的最小单位。同时线程会共享父进程的虚拟内存和全局变量等资源，因此父进程的资源加上线上自己的私有数据就叫做线程的上下文。</p>
<p>线程上下文切换：</p>
<p>​ 当线程属于同一个进程时，全局变量、虚拟内存不需要切换，只需要切换私有数据和寄存器等不共享的数据。</p>
<p>​ 当线程属于不同进程时，同进程切换。</p>
</blockquote>
<h2 id="调度算法">调度算法</h2>
<blockquote>
<p><strong>先来先服务调度算法FCFS</strong>、<strong>短作业（进程）优先调度算法SJF（非抢占）</strong>、<strong>基于时间片的轮转调度算法RR</strong>、<strong>多级反馈队列算法FB</strong></p>
</blockquote>
<h2 id="死锁的四个条件">死锁的四个条件</h2>
<blockquote>
<p><strong>互斥</strong>：某种资源一次只能运行一个进程访问。</p>
<p><strong>请求保持</strong>：一个进程占有资源，但还有资源没有满足。</p>
<p><strong>不可抢占</strong>：不可以去抢夺别人已拥有的资源。</p>
<p><strong>循环等待</strong>：存在一个进程链，每个进程都占有下一个进程所需的至少一种资源。</p>
</blockquote>
<h2 id="fork是如何创建子进程的">fork是如何创建子进程的？</h2>
<blockquote>
<p>fork会先为新进程创建和父进程值相同的内核栈、进程信息等，然后判断当前用户进程数是否超过数量，对父子进程进行区分，将部分描述符置为0，给进程分配对应的进程id，将进程设置为就绪状态，放入就绪队列，等待CPU调度。</p>
</blockquote>
<h2 id="硬中断和软中断">硬中断和软中断</h2>
<blockquote>
<p>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。硬中断可以直接中断CPU。它会引起内核中相关的代码被触发。</p>
<p>软中断的处理非常像硬中断。然而，它们仅仅是由当前正在运行的进程所产生的。一般而言软中断是I/O请求。</p>
<p>二者的区别：</p>
<p>​ 软中断是由运行的进程发出的，它会中断进程正在执行的代码，然后将请求发给内核。</p>
<p>​ 硬中断是由硬件产生的，它会中断CPU正在执行的代码。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯面经</title>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="腾讯面经">腾讯面经</h1>
<h2 id="腾讯云一面">腾讯云一面</h2>
<blockquote>
<p>1、自我介绍和项目介绍</p>
<p>2、我看你之前面过一次，为什么挂了，你相对上次来说有什么提高？</p>
<p>3、java内存结构及各功能</p>
<p>4、堆栈的线程安全问题</p>
<p>5、HashMap和CurrenthashMap(说了一会面试官没啥兴趣就换了个问题)</p>
<p>6、四次挥手</p>
<p>7、Java线程池</p>
<p>8、乐观锁和悲观锁</p>
<p>9、分布式锁</p>
<p>10、项目亮点</p>
<p>11、项目有没有进行压测？</p>
<p>12、说说熟悉的算法</p>
<p>13、数据库了解的情况</p>
<p>14、redis为什么快</p>
<p>15、多路复用</p>
<p>16、Netty 线程模型-reactor模型</p>
<p>17、你对微服务有什么理解？</p>
<p>18、你觉得怎么实现RPC？</p>
<p>19、自己的优缺点</p>
<p>20、反问</p>
</blockquote>
<h2 id="腾讯s2线一面">腾讯S2线一面</h2>
<blockquote>
<p>1、自我介绍和项目介绍</p>
<p>2、TCP和UDP的区别</p>
<p>3、TCP怎么实现可靠性的？</p>
<p>4、拥塞控制大概是怎么样的？</p>
<p>5、HTTPS会不会？大致流程</p>
<p>6、对称加密和非对称加密算法了解吗？</p>
<p>7、Java HashMap的hash算法及具体扩容逻辑。</p>
<p>8、为什么hash算法不直接使用取模？</p>
<p>9、数据库事务隔离级别</p>
<p>10、可重复读怎么实现的</p>
<p>11、操作系统进程通信</p>
<p>12、操作系统IO模型，BIO、NIO、AIO</p>
<p>13、大概讲一下select、poll、epoll。</p>
<p>14、IO多路复用复用了什么？</p>
<p>15、10个有序文件合并。</p>
<p>16、排序算法及分析</p>
<p>17、反问</p>
</blockquote>
<h2 id="腾讯s2线二面">腾讯S2线二面</h2>
<blockquote>
<p>1、自我介绍和项目介绍</p>
<p>2、HTTP请求方式有哪些</p>
<p>3、GET、POST区别</p>
<p>4、HTTPS会不</p>
<p>5、对称加密和非对称加密优劣势</p>
<p>6、Netty主从reactor模型</p>
<p>7、聊到select、poll、epoll说说区别</p>
<p>8、protobuf优势及原理</p>
<p>9、你自己测试过序列化框架的性能吗？</p>
<p>10、设计模式动态代理JDK代理和cglib代理具体怎么做的</p>
<p>11、redis怎么用的</p>
<p>12、一致性哈希知道吗？具体说说</p>
<p>12、聊聊对微服务的理解</p>
<p>13、zk至少几台集群？</p>
<p>14、zk选主算法会吗？ZAB/PAXOS</p>
<p>15、那你说说Raft吧</p>
<p>16、职业规划</p>
<p>17、聊天</p>
</blockquote>
<h2 id="携程一面">携程一面</h2>
<blockquote>
<p>1、写个二分找区间的题</p>
<p>2、http哪层、tcp哪层</p>
<p>3、三次握手、四次挥手</p>
<p>4、tcp客户端超时，服务端会报错吗或者说没有正常四次挥手流程服务端会报错吗？</p>
<p>​ 半关闭问题</p>
<p>5、new一个scanf对象，怎么JVM分配空间的？</p>
<p>​ Java new对象的过程：类加载过程(加载、验证、准备、解析、初始化)</p>
<p>6、对象除了分配到堆还能分配到哪？</p>
<p>7、无了</p>
</blockquote>
]]></content>
      <categories>
        <category>面试总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列突击</title>
    <url>/2021/03/03/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="消息队列突击">消息队列突击</h1>
<blockquote>
<p>常用的信息队列：rockketMQ、kafka</p>
</blockquote>
<h2 id="为什么使用消息队列">为什么使用消息队列?</h2>
<blockquote>
<p>异步：开发过程中往往会存在后一个步骤需要等待前一个流程执行的操作，如果使用正常流程开发会导致操作线性化占用大量时间。使用消息队列允许前者将自己的结果放入队列中，然后让接下来的流程自己去调用结果执行。</p>
<p>解耦：此外正常开发流程中还存在如果增加依赖者，需要手动修改代码，使用消息队列的话只需要主体将结果放入队列，依赖者自己去消费队列的信息即可，无须多余操作。</p>
<p>削峰：遇到大量并发时，如果直接访问数据库往往会导致数据库连接异常。此时选择先将请求放入消息队列中，让对应数据库系统根据自己的承载能力消费即可。</p>
</blockquote>
<h2 id="消息队列的消息可靠性">消息队列的消息可靠性</h2>
<blockquote>
<p>生产者发送消息丢失：</p>
<p>​ 一种方法是同步执行，然后等待消息发送，若发送失败则事务回滚。</p>
<p>​ 另一种是异步发送消息，设置回调函数，等待消息队列告知是否发送成功，若不成功则重新发送，失败一定次数后，考虑人工干预。</p>
<p>MQ本身丢失消息：</p>
<p>​ 定期存储。多机存储。存储时可以设置只有当n个从机都存储成功了才会告知生产者消息发送成功。</p>
<p>消费者丢失消息：</p>
<p>​ 消费者消费消息成功后给生产者发送ack信号。</p>
</blockquote>
<h2 id="消息队列不被重复消费">消息队列不被重复消费</h2>
<blockquote>
<p>本质上就是让消费操作重复执行也不影响结果，即幂等性。</p>
<p>主要看场景，如果消费需要修改数据库，那直接查看数据库中是否有这个数据若存在该数据则不执行插入。</p>
<p>若使用的是redis，则直接更新redis即可。</p>
<p>若是其他情况，往往需要维护一个全局唯一的id-消费消息的结构，或者放在redis中，消费者消费时先查询该结构，若没有查询结果则说明消息没有被消费过。</p>
</blockquote>
<h2 id="消息队列顺序消费">消息队列顺序消费</h2>
<blockquote>
<p>即生产者生成的消息需要被按序执行。</p>
<p>解决方案：消息队列中将这些需要按序执行的消息，放入一个队列中，让消费者消费时必须消费整个队列。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>自己的项目总结</title>
    <url>/2021/03/03/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="自己的项目总结">自己的项目总结</h1>
<h2 id="为什么使用protobuf">为什么使用protobuf？</h2>
<blockquote>
<p>因为protobuf兼容性好、序列化性能高、且序列化出的数据体积小，会降低网络通信的传输负担。</p>
<p>当然json的优点在于易读，且许多项目都是使用json传输的。</p>
<p>protobuf兼容性好的原因：</p>
<p>​ protobuf在编码消息时会把消息分为tag域和value域，tag域用于标注出这个value对应的类型，且protobuf解析时也是按照序号对应解析的，假如说服务端消息序号为1、2、3、4，而客户端使用的是旧消息1、2、4，此时在客户端接收到消息时客户端会发现缺失了一个3号位，此时读取tag就会获知这个是什么类型的数据，跳过对应位数解析即可。</p>
<p>protobuf序列化性能高的原因：</p>
<p>​ 主要是因为编码方式导致protobuf序列化过程中只需要进行数字的简单运算，同时protobuf还在框架层面上同编译器共同完成序列化，所以序列化速度非常快。</p>
<p>protobuf序列化出的数据体积小的原因：</p>
<p>​ protobuf采用T-L-V，即tag-length-value的编码方法来针对字符串。</p>
<p>​ protobuf采用T-V的结果来针对整数，其中tag的值会利用位运算先将序号左移3位然后或上对应的type值，减少空间占用。</p>
<p>​ 因为protobuf对于数字采用了特定的Varint编码。对于值越小的数字使用越少的字节表示。如对应int32的数字，如果数字较小，只使用了其中的8位，那么发送时也只会发送最后8位。</p>
</blockquote>
<h2 id="netty通讯时选择的是什么协议为什么选择这个协议">Netty通讯时选择的是什么协议？为什么选择这个协议？</h2>
<blockquote>
<p>选用TCP来实现的，因为认为TCP传输更加可靠。</p>
</blockquote>
<h3 id="使用tcp通讯时有没有遇到粘包问题怎么处理的">使用TCP通讯时有没有遇到粘包问题？怎么处理的？</h3>
<blockquote>
<p>粘包问题本质上是由于TCP自身是以流传输的发送传递数据的，而TCP默认又会开启Nagle算法，所谓Nagle算法就是TCP协议要求让一个连接中最多只能有一个未被确认的小分组，而对于后续的小分组采用累积最后合并发送的形式发送。这样就导致客户端分次发送的数据被服务端接收时变为连续的数据。</p>
<p>粘包问题有许多解决方案：</p>
<p>​ 规定每次发送消息只能发送固定长度的，未到固定长度的使用空白填补。</p>
<p>​ 消息利用特殊分隔符分隔，接收时利用分隔符进行拆分。</p>
<p>​ 在发送消息前在消息内容前添加消息长度字段，接收时利用长度字段进行接收。</p>
<p>我使用的是最后一种。</p>
</blockquote>
<h2 id="redis的使用">redis的使用</h2>
<h2 id="为什么使用zookeeper作为服务发现框架">为什么使用zookeeper作为服务发现框架？</h2>
<blockquote>
<p>可选项：redis、zookeeper(CP)、etcd(CP)、Eureka(AP)[juˈriːkə]。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础突击</title>
    <url>/2021/03/01/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/java%E5%9F%BA%E7%A1%80%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="java基础突击">java基础突击</h1>
<h2 id="java基本类型">java基本类型</h2>
<h3 id="各类型占的位数">各类型占的位数</h3>
<blockquote>
<figure>
<img src="/2021/03/01/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/java%E5%9F%BA%E7%A1%80%E7%AA%81%E5%87%BB/Users\SmallYe\Desktop\blog\source_posts\面试突击\java基础突击\java基本类型.png" alt="java基本类型"><figcaption aria-hidden="true">java基本类型</figcaption>
</figure>
<p>Byte、Short、Integer、Long：默认创建了数值为[-128,127]的相应类型的缓存数据，Character创建了数值在[0,127]范围内的缓存数据。</p>
<p>Boolean则是自定义两个static的Boolean值为TRUE、FALSE。</p>
</blockquote>
<h3 id="和equals">==和equals</h3>
<blockquote>
<p>没有覆盖equals方法时，二者相同。</p>
<p>"=="运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）</p>
</blockquote>
<h3 id="基本类型自动装箱和拆箱">基本类型自动装箱和拆箱</h3>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">		<span class="comment">//由于c、d都是直接赋值，会调用Integer.valueOf方法，获取缓存，返回true</span></span><br><span class="line">        System.out.println(c==d);</span><br><span class="line">		<span class="comment">//e、f值大于缓存区间了，返回false</span></span><br><span class="line">        System.out.println(e==f);</span><br><span class="line">		<span class="comment">//a+b先自动拆箱然后运算，==比较数值，返回true</span></span><br><span class="line">        System.out.println(c==(a+b));</span><br><span class="line">		<span class="comment">//a+b先自动拆箱然后运算，equals会先自动装箱，然后比较，Integer重写了equals，当传入Integer时，也是比较数值，返回true</span></span><br><span class="line">        System.out.println(c.equals(a+b));</span><br><span class="line">		<span class="comment">//a+b先自动拆箱然后运算，==比较数值，返回true</span></span><br><span class="line">        System.out.println(g==(a+b));</span><br><span class="line">		<span class="comment">//a+b先自动拆箱然后运算，equals会先自动装箱，然后比较，Long重写了equals，当传入Long时，也是比较数值，而此时传入Integer，返回false</span></span><br><span class="line">        System.out.println(g.equals(a+b));</span><br><span class="line">		<span class="comment">//a+b先自动拆箱然后运算，equals会先自动装箱，然后比较，Long重写了equals，当传入Long时，也是比较数值，返回true</span></span><br><span class="line">        System.out.println(g.equals(a+h));</span><br><span class="line">答案：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h3 id="java泛型">Java泛型</h3>
</blockquote>
<blockquote>
<p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>而泛型在Java中实现是使用伪泛型来实现的，即虽然声明的是ArrayList<String>但是最后实际上会进行类型擦除变为ArrayList。而String被擦除后会变为Object。</String></p>
</blockquote>
<h3 id="重写和重载">重写和重载</h3>
<blockquote>
<p>重载：方法名相同参数不同</p>
<p>重写：子类重写父类方法。</p>
<p>​ 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>
<p>​ 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</p>
<p>​ 构造方法无法被重写。</p>
</blockquote>
<h3 id="stringstringbuffer和stringbuilder">String、StringBuffer和StringBuilder</h3>
<blockquote>
<p>String：底层是final修饰的char数组。存在不可变特性。</p>
<p>为什么要不可变：1.复用hashcode避免重复计算。2.字符串是不可变的，才能实现字符串常量池，让同一个字符串可以从常量池中查找，实现资源复用。</p>
<p>3.因为字符串是不可变的所以它是线程安全的。</p>
<p>String的equals方法，先判断两个对象是否相等，若不相等再判断对象是否为String实例，若是遍历字符串逐一判断字符是否相等，全部相等则返回相等。</p>
<p>String计算hashcode：通过h = 31 * h + val[i];计算。</p>
<p>StringBuffer和StringBuilder都是AbstractStringBuilder的子类，本质都是一样的。</p>
<p>StringBuffer：线程安全，因为使用synchronized修饰。底层是没有final修饰的char数组，初始化时默认大小是16，通过append方法来添加字符，添加时需要判断当前size是否需要扩容，扩容机制为原char数组长度 * 2 + 2。然后添加时就是利用给定的目的数组和size偏移对数组进行复制。</p>
<p>StringBuilder：线程不安全。底层也是没有final修饰的char数组，初始化默认大小是16，通过append添加。</p>
</blockquote>
<h2 id="java容器">java容器</h2>
<h3 id="arrays.sort怎么排序的">Arrays.sort()怎么排序的？</h3>
<blockquote>
<p>根据排序对象分为两种：</p>
<p>​ 对于基本类型，使用DualPivotQuicksort.sort()</p>
<p>​ 对于数量小于QUICKSORT_THRESHOLD = 286的数组，再进行分类，若小于INSERTION_SORT_THRESHOLD = 47，使用leftmost再选择排序模式，模式分为插入排序和改进的插入排序。</p>
<p>​ 若大于INSERTION_SORT_THRESHOLD = 47，则使用DualPivotQuicksort双轴快排。</p>
<p>​ 而对于数量较大的，先判断数组是否为高度结构化，若不是高度结构化则使用DualPivotQuicksort，否则使用归并排序。</p>
<p>​ 对于实现了Comparable接口的类型，使用ComparableTimSort.sort()。</p>
<p>​ 对于数量小于MIN_MERGE = 32的数组，使用二分插入排序。</p>
<p>​ 对于数量大于MIN_MERGE的数组，使用timSort排序(大量优化的归并排序)。</p>
</blockquote>
<h3 id="arraylist具体实现">ArrayList具体实现</h3>
<blockquote>
<p>默认容量10，底层是数组，默认实现的拷贝方式是浅拷贝。</p>
<p>add方法：</p>
<p>​ 让size+1，然后判断是否需要扩容，如果初始化时没有参数则让size同默认值比较，否则直接让size和当前数组长度比较，若大于则进行扩容。</p>
<p>​ 扩容即将旧数组长度扩大1.5倍然后转化为新数组长度，通过newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);的位运算加速计算。</p>
<p>​ 若扩容后的值小于size，则让值变为size，若扩容后的值大于数组最大长度，则判断size是否大于数组最大长度，若大于则扩容后的值为Integer.MAX_VALUE，否则为数组最大长度。</p>
<p>​ 扩容具体操作则是使用Arrays.copyOf()，本质上就是System.arraycopy()。属于浅拷贝。</p>
</blockquote>
<h3 id="vector">Vector</h3>
<blockquote>
<p>本质上就是将常用的方法使用synchronized锁住，只是扩容机制不同。</p>
<p>Vector初始化时可以初始化每次扩容的大小，若没有设置该值则每次扩容一倍，否则每次扩容对应大小。</p>
</blockquote>
<h3 id="linkedlist">LinkedList</h3>
<blockquote>
<p>底层是链表。</p>
</blockquote>
<h3 id="collections.synchronizedlist">Collections.SynchronizedList</h3>
<blockquote>
<p>类似Vector，但是可以将不同的List转化为线程安全的List，底层是通过Synchronized(mutex)，在synchronized块中调用List的通用方法实现的。</p>
</blockquote>
<h3 id="copyonwritearraylist">CopyOnWriteArrayList</h3>
<blockquote>
<p>适用于读多写少的场景，因为每次操作需要复制数组。·</p>
<p>底层使用ReentrantLock在add操作时上锁，add操作结束后释放。正如名字所说，每次添加操作都需要在原数组的基础上复制一个大小增加对应长度的数组进行使用。</p>
<p>remove时也需要上锁，也是在原数组的基础上复制一个大小减少对应长度的数组进行使用。</p>
<p>其计算hashcode的方法类似String，也是使用h = 31 * h + 对应对象的hashcode;</p>
</blockquote>
<h2 id="基础知识点">基础知识点</h2>
<h3 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h3>
<blockquote>
<p>浅拷贝拷贝对象时如果对象中含有其他对象，则只会拷贝这些对象的引用，如果对其中对象进行修改会相互影响。</p>
<p>深拷贝即当拷贝对象中含有其他对象时，会创建一个另外的对象，让两个对象互不影响。</p>
<p>实现深拷贝的方式：</p>
<p>​ 要被拷贝的类实现clonable接口，并且让这个类中对应对象的类也实现clonable接口，然后重写clone方法，被拷贝对象的clone方法需要将对应对象的clone赋值给该对象。如：this.a = a.clone();</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis突击</title>
    <url>/2021/03/01/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/mybatis/</url>
    <content><![CDATA[<h1 id="mybatis突击">mybatis突击</h1>
<h2 id="和">#{}和$</h2>
<blockquote>
<p>#{} mybatis会创建PreparedStatement参数占位符，并使用占位符安全地设置参数。</p>
<p>${} mybatis不会执行转义，可以在sql插入一个不转义的字符串。</p>
<p>如果需要输入大量特殊字符，可以使用&lt;[CDATA[ ]]&gt; 标签。</p>
</blockquote>
<h2 id="常见标签">常见标签</h2>
<blockquote>
<p><resultMap>、<association>、<sql>、<sql>标签里面还有一些如<if>、<trim>之类的用于动态sql。</trim></if></sql></sql></association></resultMap></p>
</blockquote>
<h2 id="mybatis流程">Mybatis流程</h2>
<blockquote>

</blockquote>
<h2 id="dao代理">dao代理</h2>
<blockquote>
<p>mybatis使用JDK动态代理实现。mapper的方法不能重载，因为Mybatis是使用包名+类+方法名作为key去查找xml的sql执行的。</p>
<p>JDK动态代理是基于接口的代理。不实现接口的话可以使用cglig的动态代理。</p>
<p>JDK动态代理本质上就是根据接口的方法产生一个继承了Proxy类实现了需要代理接口的代理子类，该子类中存在代理接口的方法对象，而这些方法对象会在静态块利用反射进行创建，而调用执行方法时会使用this.h.ivoke调用执行，其中h即为实现动态代理时的InvactionHandler。</p>
<p>缺点：要求方法实现接口。</p>
<p>cglib动态代理是基于代理类的思想实现的。代理过程会生成一个需要被代理的类B对象。也会创建对应的方法。但是在方法invoke时cglib做了fast class的优化，jdk动态代理invoke时是使用反射的技术进行调用方法的，而cglib则会随着方法的调用产生fast class，产生了一个对应方法的具体实现，使用时利用index映射关系找到对应方法，直接执行，不需要执行反射过程。</p>
<p>缺点：不能代理final方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>网络突击</title>
    <url>/2021/03/01/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E7%BD%91%E7%BB%9C%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="网络突击">网络突击</h1>
<h2 id="http相关">Http相关</h2>
<h3 id="概述">概述</h3>
<blockquote>
<p>HTTP基于TCP/IP通信协议传递数据。</p>
<p>HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。</p>
<p>HTTP是无连接的：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。引出Keep-alive</p>
<p>HTTP是媒体独立的：只要客户端和服务器知道如何处理数据内容，任何数据都可以从HTTP发送。通过content-type指定类型。</p>
<p>HTTP是无状态的：指协议对于事务的处理没有记忆能力。意味着后续处理如果需要前面的信息必须重传。从而引出的Session。</p>
</blockquote>
<h3 id="http事务-http请求命令-响应码">Http事务 = http请求命令 + 响应码</h3>
<blockquote>
<p>http事务是http请求的最小处理单元。</p>
<p>请求报文和响应报文。</p>
</blockquote>
<h4 id="请求报文">请求报文</h4>
<blockquote>
<p>请求行+请求头+请求体</p>
<p>请求行内容为：</p>
<p>​ 请求方法 + 请求的URL地址 + Http协议版本</p>
<p>​ 请求方法有：</p>
<p>​ HTTP1.0：GET(请求指定页面信息并返回主体)、POST(向指定资源提交数据)、HEAD(请求指定页面头)</p>
<p>​ HTTP1.1：OPTIONS(允许客户端查看服务端性能)、PUT(客户端提交数据代替服务端)、DELETE(请求服务端删除指定页面)、TRACE(回显服务端收到的请求) 、CONNECT (HTTP1.1中预留给能够将连接改为管道方式的代理服务)</p>
<p>请求头内容为属性，用于让服务端获知客户端信息，以下为常见属性：</p>
<p>​ accept：告知服务端可以接受的文件格式。如application/json</p>
<p>​ accept-language：浏览器支持的语言</p>
<p>​ accept-encoding：指定浏览器可以支持的web服务器返回的内容压缩编码类型。</p>
<p>​ User-Agent：用户代理，用于查看用户是使用什么访问的。</p>
<p>​ Cookie：HTTP请求发送时会把请求域名下所有的cookie值都发给服务端。</p>
<p>​ Cache-Control：设置缓存相关。no-cache代表不接受缓存，max-age表示客户端希望接受存在时间不大于该值的资源。</p>
<p>​ connection：表示是否需要持久连接，keep-alive表示使用持久连接。http1.1默认使用。</p>
<p>​ host：指定请求的服务器的域名和端口号</p>
<p>请求体一般是用来传递参数。</p>
</blockquote>
<h4 id="响应报文">响应报文</h4>
<blockquote>
<p>响应行 + 响应头 + 响应体</p>
<p>响应行内容为：</p>
<p>​ HTTP协议版本 + 状态码及描述</p>
<p>常见状态码：</p>
<p>​ 1xx：表示服务器收到请求但需要请求者继续操作。</p>
<p>​ 2xx：成功，操作被成功接收并处理。</p>
<p>​ 3xx：重定向。</p>
<p>​ 4xx：客户端错误，请求包含语法错误或无法完成请求。</p>
<p>​ 5xx：服务器错误。</p>
<p>​ 具体：</p>
<p>​ 200 OK：处理成功</p>
<p>​ 206 Partial Content：断点续传时使用，本质上就是客户端在header上设置一个Content-Range 标识当前传输的位置，服务端根据这个位置来响应。</p>
<p>​ 301 Moved Permanently：请求的资源已被永久移动到新URI。</p>
<p>​ 302 Moved Temporarily：资源被临时移动到新URI。</p>
<p>​ 303 See Other：重定向到另外页面</p>
<p>​ 304 Not Modified：未修改，服务端不会返回数据。让客户端访问缓存。</p>
<p>​ 400 Bad Request：客户端请求语法错误。</p>
<p>​ 401 Unauthorized：请求未经授权。</p>
<p>​ 403 Forbidden：禁止访问</p>
<p>​ 404 Not Found：找不到页面</p>
<p>​ 500 Internal Server Error：服务端出现内部错误。</p>
<p>​ 502 Bad Gateway：网关错误。</p>
<p>响应头：</p>
<p>​ Cache-Control：告知客户端怎么控制缓存。类似请求头。值可以为no-cache，max-age</p>
<p>​ content-encoding：压缩编码格式。</p>
<p>​ Content-Type：文件类型</p>
<p>​ Location：重定向</p>
<p>​ date：时间</p>
<p>​ set-cookie：xx=yyy；Max-Age=3600；Version=1；当中Max-Age是用于设置cookie的保存时间。</p>
<p>响应体就是服务端返回给客户端的信息，如html页面，json之类。</p>
</blockquote>
<h3 id="get和post的区别">GET和POST的区别</h3>
<blockquote>
<p>本质上除了语义不同之外没有区别，但浏览器实现时区别如下：</p>
<p>​ get可以被缓存、get请求可以被收藏为书签，post不行。</p>
<p>​ get的数据url可见，post不会。</p>
<p>​ get长度有限制、post没有</p>
<p>​ get请求刷新回退都没有影响、post数据会被重新提交</p>
</blockquote>
<h3 id="cookiesessiontoken">Cookie、Session、Token</h3>
<blockquote>
<p>本质上都是用于存储用户信息的。</p>
<p>cookie是浏览器层面储存的一种k-v结构数据，当发送请求给服务端时可以把cookie发送给服务端。但是由于cookie是存储在浏览器上的，所以cookie往往不能用来存储用户的私密数据。</p>
<p>session则是在服务端层面存储用户信息，服务端在使用session时往往会产生一个特殊的sessionId，然后将这个id交给客户端，客户端每次访问服务端时带上这个id即可。但是由于session存储在服务端，所以如果有大量用户时服务端往往会消耗大量资源来存储session，并且如果是多服务端的结构，还需要采用一定操作来保证session的存储。</p>
<p>token=header密文+payload密文+签名：本质上是将用户第一次发送的用户名+密码的信息进行签名加密然后再发还给用户，而用户浏览器则保存这个信息，在之后的访问过程每次带上这个token供服务端验证。可以防止CSRF(跨站请求伪造)攻击，即在页面中放入一些恶意链接，这些链接会指向如转账之类的功能，由于浏览器发送请求时会默认带上cookie，所以导致请求通过校验被执行。而使用token浏览器就不会默认发送，从而防止csrf攻击。验证时服务端将两个密文解密再签名同自带的签名进行比对判断是否通过认证。此外还可以对payload密文解密来判断token是否过期。</p>
</blockquote>
<h3 id="http工作流程">HTTP工作流程</h3>
<blockquote>
<p>DNS域名解析-&gt;TCP三次握手-&gt;发起HTTP请求-&gt;服务器响应HTTP请求-&gt;浏览器解析HTML并请求资源-&gt;浏览器渲染页面</p>
<p>DNS既用TCP又用UDP，使用53号端口。</p>
<p>在域名解析时使用UDP。因为解析的数据少，UDP较快。</p>
<p>而在域名服务器之间执行数据同步时会使用TCP。因为此时数据量大，TCP是可靠连接，保证数据准确性。</p>
<p>DNS域名解析流程：</p>
<p>​ 搜索浏览器自身DNS缓存-&gt;搜索操作系统自身DNS缓存-&gt;读取host文件-&gt;向本地DNS服务器发起域名解析请求。</p>
<p>​ 本地DNS先向根域名服务器-&gt;顶级域名服务器-&gt; 权限域名服务器得到结果返回。</p>
</blockquote>
<h3 id="http发展流程">HTTP发展流程</h3>
<blockquote>
<p><strong>http0.9</strong>：只支持get，服务端只能返回html格式，参数过程只支持文字。</p>
<p><strong>http1.0</strong>：增加了post和head，支持发送任何格式的内容，增加了请求头、状态码，权限缓存相关内容。</p>
<p>缺点：每个TCP只能发送一个请求，发送完毕连接关闭，使用成本高。队头堵塞，即请求大量资源时耗时较长的资源会影响之后的资源处理。</p>
<p><strong>http1.1</strong>：引入了Connection： keep-alive让连接持久，还加入了如put、delete、connect之类的请求方式。另外引入了管道机制，支持客户端将多个HTTP请求放入一个TCP连接中，管理请求的顺序，一定程度上解决了队头堵塞。</p>
<p>缺点：keep-alive虽然可以复用部分连接，但是域名分片的情况下还是要建立多个connection。管道机制要求返回结果是按序的，即使后面的处理成功了，但服务端返回时还是需要按客户端请求的顺序响应，即需要等待前面结果完成。协议开销大，协议头里内容过多且基本不变，增加了传输负担。</p>
<p><strong>http2.0</strong>：基于SPDY。目的是通过支持请求和响应的多路复用来减低延迟。</p>
<p>​ http1.x是文本协议，而http2.0使用二进制化分帧的方式，将传输的信息分割为更小的帧，并采用二进制编码的方式，首部信息放入Header frame，Request body放入Data frame，这样会对信息进行顺序标识。而且http2.0在每个TCP连接中承载多个双向流通的流，每个流都有一个独一无二的标识，而流就是由二进制帧组成的，二进制帧的头部信息会标识自己属于哪个流。这样使得服务器可以并行传输数据。从而实现了多路复用。</p>
<p>​ http2.0可以给流设置优先级使得重要请求可以被优先处理。</p>
<p>​ 此外http2.0还使用了首部压缩技术，对于一条连接使用首部表来维护key-value，若增加新的key-value则加入表尾，避免每次请求都需要携带首部。此外还对首部使用了HPACK算法压缩。</p>
<p>​ 不仅如此http2.0还支持服务器主动推送，即先请求服务器，服务器不用解析就可以直接将预先设置好的内容推送给客户端。</p>
<p><strong>http3.0</strong>：基于QUIC协议，底层使用UDP通信。实现了机制：</p>
<p>​ 虽然http2.0在TCP的基础上实现了多路复用，但由于TCP的机制，每个流在发送时可能被拆成多个包(TCP分段)，举例S1、S2被拆为p1.1、p1.2、p1.2和p2.1、p2.2、p2.3，而发送过程又是乱序发送的，如p1.1、p1.2、p2.1、p1.3、p2.2、p2.3，这样可能导致的问题：假设p1.3一直超时，等待重传，阻塞了S2的信息。而因为http3.0是基于UDP的没有这个问题，所以可以实现真正的多路复用。</p>
<p>​ 自定义连接机制：TCP连接是用4元组(源IP、源端口、目的IP、目的端口)的形式标注的，其中一个元素改变就需要建立连接，而HTTP3.0基于UDP实现了自己的连接机制，使用64位的随机数来作为ID来标识。且UDP是无连接的，所以当ip或者端口变化的时候，只要ID不变，就不需要重新建立连接。</p>
<p>​ 自定义重传机制：由于TCP实现超时重传是使用序号机制，而超时的包和重发的包序列号一直，导致无法估计超时的准确时间。QUIC自定义了一个序列号，每次发送包时增加1，同时定义了offset的概念，判断两个包是否相同，这样可以准确估计超时的时间。</p>
</blockquote>
<h3 id="http和https">HTTP和HTTPS</h3>
<blockquote>
<p>HTTP是超文本文件传输协议通信使用明文传输，HTTPS则是基于HTTP协议通过SSL(处于TCP/IP协议与各种应用层协议之间)或TLS(前身是SSL)提供加密处理数据、验证对方身份及数据完整性保护。</p>
<p>HTTPS的特点：</p>
<p>​ 内容加密：采用混合加密技术，中间者无法直接查看明文内容。</p>
<p>​ 验证身份：通过证书认证客户端访问的是自己的服务器。</p>
<p>​ 保护数据完整性：防止传输的内容被中间人冒充或篡改。</p>
<p>Https流程：</p>
<p>​ 1.客户端向服务器发送请求，提供如下信息：</p>
<p>​ 支持的协议版本，如TLS1.0。一个客户端产生的随机数，稍后用于生成“对话秘钥”。支持的加密算法，如RSA。支持的压缩算法。</p>
<p>​ 2.服务器收到请求后，向客户端做出回应，内容包括：</p>
<p>​ 确认使用的加密通信协议版本，如TLS1.0。一个服务器生成的随机数，用于生成对话秘钥。确认使用的加密方法。服务器证书。</p>
<p>​ 3.客户端收到服务器回应后会验证服务器证书。若证书不是可信机构颁布、或证书域名和实际域名不一致、或证书已经过期则会警告访问者。</p>
<p>​ 4.若证书没有问题，客户端取出证书中的公钥，然后向服务器发送消息：</p>
<p>​ 一个随机数，用于服务器公钥加密，防止窃听。</p>
<p>​ 编码改变通知，表示随后的信息都将用双方商定的加密方法和秘钥发送。</p>
<p>​ 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用于服务器校验。</p>
<p>​ 5.服务端回应，当服务端收到客户端的第三个随机数后，计算生成本次会话的会话密钥，然后向客户端发送信息：</p>
<p>​ 编码改变通知，表示随后的信息将用双方商定的加密方法和密钥发送。</p>
<p>​ 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p>
<p>证书验证过程：CA机构在签发证书的时候，都会使用自己的私钥对证书进行签名，如果我们使用的是购买的证书，那么很有可能，颁发这个证书的CA机构的公钥已经预置在操作系统中。这样浏览器就可以使用CA机构的公钥对服务器的证书进行验签，验签之后得到的是CA机构使用sha256得到的证书摘要，客户端就会对服务器发送过来的证书使用sha256进行哈希计算得到一份摘要，然后对比之前由CA得出来的摘要，就可以知道这个证书是不是正确的，是否被修改过。</p>
</blockquote>
<h2 id="socket的建立流程">Socket的建立流程</h2>
<blockquote>
<p>服务端socket创建socket -&gt; bind -&gt; listen -&gt;accept -&gt; read/write -&gt; close</p>
<p>客户端创建socket -&gt; connect -&gt; read/write -&gt; close</p>
</blockquote>
<h2 id="tcp和udp">TCP和UDP</h2>
<h3 id="tcp和udp的区别">TCP和UDP的区别</h3>
<blockquote>
<p>TCP是面向连接的，UDP是无连接的。</p>
<p>TCP消耗资源较大，UDP消耗资源较少。</p>
<p>TCP是字节流传输，UDP是数据报传输。</p>
<p>TCP可靠性高，UDP不保证消息可靠性。</p>
<p>TCP可以进行流量控制，UDP不具有流量控制的能力。</p>
<p>TCP适用于对于消息准确性和顺序要求较高的场景，UDP应用于对于通信效率、准确性要求相对较低的场景。</p>
</blockquote>
<h3 id="tcp是怎么保证可靠性的">TCP是怎么保证可靠性的？</h3>
<blockquote>
<p>1、使用报文里的校验和字段。</p>
<p>2、使用了序列号机制，即每次发送报文都会附上相应的序列号，而接收到请求的那方会发送ACK对报文进行确认，同时ACK也会附带对应应答的序列号，此时发送方就可以对接收到ACK附带的序列号进行检测。若序列号正确再发送其他的报文，若错误则重发。</p>
<p>3、超时重传：即报文在发出一定时间内未收到接收方的，发送方就会重传。</p>
<p>4、三次握手和四次挥手机制。</p>
<p>5、流量控制：由于接收端处理数据的速度是有限的，为了不让过多的数据让接收端无法处理，tcp报文中有个窗口大小字段，可以让接收端在接收报文，发出ACK信号时附上该值，让发送方及时调整。</p>
<p>6、拥塞控制：流量控制是发送方接收方之间，而拥塞控制是相对整个网络通信环境的。TCP采用<strong>慢启动、拥塞避免和快恢复、快重传</strong>的方式来降低网络拥塞的可能。此外还有<strong>BIC、CUBIC、BBR拥塞控制</strong>。</p>
<p>​ <strong>慢启动</strong>：即开始阶段，当在一个RTT时间内，每收到一个确认即让拥塞窗口大小增加1，直到超过了阈值大小。</p>
<p>​ <strong>拥塞避免</strong>：超过阈值后会当一个RTT时间内，只让拥塞窗口大小增加1。</p>
<p>​ <strong>慢恢复</strong>：当遇到网络拥塞，即出现丢包时会将拥塞窗口大小直接变为1，让阈值减半，然后进行慢启动过程。</p>
<p>​ <strong>快重传</strong>：要求接收方，每收到一个失序的报文段就立即发出重复确认。收到连续三个冗余ACK，则重新发送报文段。因为TCP使用累积确认的机制，即接收端受到比期望序号大的报文，会重复发送最近一次确认的报文段的确认信号。一般和快恢复配合使用。</p>
<p>​ <strong>reno快恢复</strong>：当遇到三个连续重复ack时，让阈值减半，拥塞窗口大小变为阈值，然后将拥塞窗口大小+3，重传丢失的报文段，如果再收到重复ACK则拥塞窗口再+1，直到收到新数据包的ACK，将窗口设置为阈值，进入拥塞避免状态。</p>
<p>​ <strong>new_reno快恢复</strong>：reno快恢复只会对一个包丢失进行处理，若丢失了许多包导致的三个重复ACK，则会让拥塞窗口大小连续下降。这种算法本质上是当丢失多个包时如果接收到其中一个包，只会发出部分ACK，直到接收到所有丢失的包才发出完整的ACK，此时才结束快恢复状态，进入拥塞避免。</p>
<p>​ <strong>BIC</strong>：在reno版本的拥塞控制中，进入拥塞避免状态时，每过一个RTT才让拥塞窗口自增1，当RTT很长时，达到最佳拥塞窗口的时间很长。而BIC算法会将发生丢包的那个拥塞窗口大小视为Wmax，降到一半阈值大小的拥塞窗口大小视为Wmin，利用二分法去探寻当前最佳窗口大小。而当十分逼近Wmax时，此时可以认为网络环境变好，需要探寻更大的窗口，这时利用之前二分的反过程来探寻新窗口。显然RTT时间短的连接会更早达到上限，故而该算法是抢占带宽的算法。</p>
<p>​ <strong>CUBIC</strong>：本质上就是将RTT这个因子从分析过程中抽取出来，通过数学的手段利用数学公式将BIC的过程拟合出来。通过调节公式的参数来调整窗口调整的速度。</p>
<p>​ <strong>BBR</strong>：将网络拥塞和丢包区分开，因为丢包可能是因为传输错误。而BBR的主要目的是为了在存在一定丢包率的网络链路上拆分利用带宽，以及降低网络链路上buffer占用率，从而降低延迟。原有算法的缺点：使用丢包作为判断发送网络拥塞的条件，使用窗口判断会导致缓冲区膨胀的问题，导致网络延迟和由于缓冲区被占满导致丢包的问题。</p>
<p>​ BBR通过不考虑丢包来解决第一个问题，通过利用估计带宽和延迟来避免直接，而带宽和延迟不能同时测量，因为带宽大之后延迟变高，延迟低带宽则低。BBR选择交替测量，用一段时间内的带宽极大值和延迟极小值来作为估计值。</p>
<p>​ BBR算法阶段：startup慢启动阶段 -&gt; Drain排空阶段 -&gt; Probe_BW带宽探测阶段 -&gt; Probe_RTT延迟探测阶段</p>
<p>​ 慢启动阶段：类似于原本的慢启动，指数增加发送速率，当连续三次发现投递率不再增长，说明管道被填满，进入Drain排空阶段。</p>
<p>​ 排空阶段：指数降低发送速率，将多发送的buffer排空。</p>
<p>​ 带宽探测阶段：排空后，进入稳定状态，BBR改变发送速率进行带宽探测，先在一个RTT时间增加发送速率探测最大带宽，若RTT没有变化，减小发送速率排空发送的包，后六个周期使用更新后的估计带宽发送。</p>
<p>​ 延迟探测阶段：BBR每过10秒，如果估计延迟不变进入延迟探测阶段，BBR在这段时间内发送查看固定为4。</p>
</blockquote>
<h3 id="tcp握手与挥手">TCP握手与挥手</h3>
<h4 id="tcp三次握手">TCP三次握手</h4>
<blockquote>
<p>三次握手的流程：</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A发送SYN信号及A的初始序号x，此时A进入SYN_SEND状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">B接收到了A发送的SYN信号与A初始序号x，需要对SYN信号发送ACK应答且应答序号为x+1，同时也向A发出SYN信号和自己的序号y，然后进入SYN_RECV状态</td>
</tr>
<tr class="odd">
<td style="text-align: center;">A接收到服务端发送的SYN和ACK信号，会发送ACK信号并将序号设为y+1，然后发送给客户端，发送完毕后A进入ESTABLISHED状态，完成三次握手。</td>
<td style="text-align: center;">B收到ACK也进入ESTABLISHED状态</td>
</tr>
</tbody>
</table>
<p><strong>为什么不是四次握手，如将B的SYN信号和ACK信号拆开发送</strong>。原因：避免资源浪费。</p>
<p><strong>为什么B需要等待A的ACK信号？即为什么不是两次握手？</strong>原因：本质上为了避免旧重复连接造成资源浪费的问题，若B发出SYN和ACK信号后直接进入ESTABLISHED状态，假定A、B先前存在连接，然后断开了连接，而此时B在之后的一段时间中收到了A早期发送的SYN信号，若B直接进入ESTABLISHED状态，此时显然A是没有连接需求的，也不会向B发送数据，而B也不知道这一点，这样就会浪费掉连接资源。而使用三次握手，A、B之间存在序列号，若发生之前的情况，B会对A发出信号和自己的ACK序号，此时A收到ACK时就会发现自己当前的序列号不能和B的ACK对应，就会给B发送RESET信号，从而避免资源浪费。并且三次握手也可以双方的序列号被可靠的同步。</p>
<p>第三次握手时就可以携带数据了。</p>
<p><strong>SYN攻击</strong>：即随机IP访问服务器发送大量SYN请求。导致服务器的SYN接收队列即未连接队列被占满。</p>
<p>解决方法：</p>
<p>​ tcp建立连接时分为syn队列和accept队列，可以启用tcp_syncookies ，当syn队列被占满时，会给客户端将一个cookie值放入序列号字段中，当客户端发送ACK正确时，直接将连接放入accept队列，然后等待accept函数被调用。</p>
</blockquote>
<h4 id="tcp四次挥手">TCP四次挥手</h4>
<blockquote>
<p>四次挥手的流程：</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A发送FIN信号及自己的序列号给B，然后进入FIN_WAIT1状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">B接收到了A发送的FIN信号会向A发送ACK，然后进入CLOSE_WAIT状态</td>
</tr>
<tr class="odd">
<td style="text-align: center;">客户端收到ACK信号进入FIN_WAIT2状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">一段时间后，服务端发送完数据，就会给客户端发送FIN报文，此时服务端进入LAST_ACK状态</td>
</tr>
<tr class="odd">
<td style="text-align: center;">当客户端接收到FIN信号时发送ACK信号给服务端，此时客户端会进入TIME_WAIT状态。若超过2MSL没有收到回复则客户端关闭连接进入CLOSED状态。</td>
<td style="text-align: center;">当服务端接收到ACK信号时会关闭连接进入CLOSED状态</td>
</tr>
</tbody>
</table>
<p><strong>为什么断开连接需要四次挥手？</strong></p>
<p>​ 因为TCP连接是全双工的，所以必须保证每个方向都单独进行关闭。当客户端想关闭自己这方的连接时，服务端可能还需要发送消息，故客户端只能先发送FIN，然后等待服务端完成了自己操作后发出FIN才完成一个连接两个方向的关闭。</p>
<p><strong>为什么客户端发送ACK信号后还需要等待2MSL长度的时间？</strong></p>
<p>​ 主要有两个原因：</p>
<p>​ 1、如果ACK信号在传输过程中丢失了，客户端可以等待服务端重新发送FIN报文，此时再发送ACK报文来保证连接被正常关闭。</p>
<p>​ 2、2MSL时间是网络TCP生存时间的两倍，设置这个时间是为了给服务器足够的超时重传时间，也让客户端可以等待网络中在之前连接中发出的包全部消失。</p>
</blockquote>
<h5 id="time_wait相关问题">TIME_WAIT相关问题</h5>
<blockquote>
<p>为什么要有TIME_WAIT状态。主要有两个原因：</p>
<p>​ 1、如果ACK信号在传输过程中丢失了，客户端可以等待服务端重新发送FIN报文，此时再发送ACK报文来保证连接被正常关闭。</p>
<p>​ 2、2MSL时间是网络TCP生存时间的两倍，设置这个时间是为了给服务器足够的超时重传时间，也让客户端可以等待网络中在之前连接中发出的包全部消失。</p>
<p>TIME_WAIT/CLOSE_WAIT状态过多怎么办？</p>
<p>​ CLOSE_WAIT和TIME_WAIT状态的连接也会占用服务端的fd，可能超过Linux fd上限。可以通过调节Linux对应time wait参数，如net.ipv4.tcp_timestamps时间戳、net.ipv4.tcp_tw_recycle快速回收(会导致NAT网络冲突，因为NAT网络识别时只有一个host，而不同客户端timestamps可能不同，快速回收机制会丢弃timestamps非递增的包)、net.ipv4.tcp_tw_reuse重用机制。</p>
</blockquote>
<h3 id="tcp半打开半关闭半连接">TCP半打开、半关闭、半连接</h3>
<blockquote>
<p>半打开：一方异常关闭，另一方不知情，处于半打开的状态。</p>
<p>​ 解决方案：当不知情的一方发送数据给异常关闭方时，异常关闭方会发送RST信号，要求重置连接。</p>
<p>​ TCP也提供了心跳机制，通过开启SO_KEEPALIVE并设置对应参数来配置。开启心跳后TCP服务端会定期发送心跳包，若没有响应则隔更短的时间连续发送若干次，从而获知客户端断开连接了，从而及时关闭连接。</p>
<p><strong>既然TCP也有心跳机制，为什么应用层还往往要设计心跳机制呢？</strong></p>
<p>​ 主要原因：TCP心跳是在传输层的机制，而且只能判断当前连接是否出现异常，无法反应应用层的情况。而我们在应用层设计的心跳机制往往是为了判断应用能否正常提供服务。而且如果服务不是使用TCP传输，应用层自制心跳机制也会加强应用的通用性</p>
<p>半关闭：对应四次挥手的FIN_WAIT2状态。</p>
<p>半连接：主动发起握手的一方不发最后一次ACK，使得服务端处于SYN_RECV状态。存在SYN泛洪攻击。</p>
</blockquote>
<h2 id="其他协议">其他协议</h2>
<h3 id="arp协议">ARP协议</h3>
<blockquote>

</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O模型及I/O线程模型</title>
    <url>/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="io模型及io线程模型">I/O模型及I/O线程模型</h1>
<h2 id="io模型">I/O模型</h2>
<h3 id="阻塞型iobio">阻塞型I/O(BIO)</h3>
<blockquote>
<p>线程调用recvfrom，持续等待直到复制完成。</p>
<figure>
<img src="/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/阻塞型IO.png" alt="阻塞型IO"><figcaption aria-hidden="true">阻塞型IO</figcaption>
</figure>
<p>优点：程序简单</p>
<p>缺点：每个连接需要独立进程/线程，并发量大时维护程序的线程切换开销大。</p>
</blockquote>
<h3 id="非阻塞型io">非阻塞型I/O</h3>
<blockquote>
<p>线程调用recvfrom，不持续等待，而是不断轮询操作系统内核。</p>
<figure>
<img src="/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/非阻塞型IO.png" alt="非阻塞型IO"><figcaption aria-hidden="true">非阻塞型IO</figcaption>
</figure>
<p>优点：不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，不用阻塞等待，实时性较好。</p>
<p>缺点：轮询占用大量CPU时间，系统资源利用率低。</p>
</blockquote>
<h3 id="io多路复用nio">I/O多路复用(NIO)</h3>
<blockquote>
<p>如select、poll、epoll，用一个描述符管理多个描述符，同时管理多个I/O操作，当有事件发生时才堵塞进行复制。</p>
<figure>
<img src="/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/NIO.png" alt="NIO"><figcaption aria-hidden="true">NIO</figcaption>
</figure>
<p>优点：节省大量系统资源。</p>
<p>缺点：在并发量低时延迟较多线程+堵塞I/O更高，因为I/O多路复用对单个连接需要进行两次系统调用。</p>
</blockquote>
<h3 id="信号驱动型io">信号驱动型I/O</h3>
<blockquote>
<p>使用信号来驱动，当数据准备好时进程会受到一个信号，在信号处理函数中处理数据。</p>
<figure>
<img src="/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/信号驱动型IO.png" alt="信号驱动型IO"><figcaption aria-hidden="true">信号驱动型IO</figcaption>
</figure>
<p>优点：线程没有在等待数据时被阻塞，提高资源利用率。</p>
<p>缺点：信号I/O在大量I/O操作时可能会因为信号序列溢出导致无法通知。</p>
</blockquote>
<h3 id="异步ioaio">异步I/O(AIO)</h3>
<blockquote>
<p>类似于信号驱动I/O，但是AIO会在内核完成了数据复制操作后才给线程发送信号，线程无须等待。</p>
<figure>
<img src="/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/异步IO.png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>优点：异步I/O充分利用DMA，让I/O操作和计算重叠。</p>
<p>缺点：AIO需要操作系统支持，目前AIO在linux中还不完善，且AIO代码编写复杂。</p>
</blockquote>
<h2 id="io线程模型">I/O线程模型</h2>
<h3 id="传统阻塞-io-服务模型">传统阻塞 I/O 服务模型</h3>
<blockquote>
<p>采用阻塞式I/O获取输入数据，每个连接都需要独立的线程完成数据输入、业务处理、数据返回的完整操作。</p>
<p>缺点：</p>
<p>​ 并发数较大时需要大量线程。</p>
<p>​ 连接后若没有数据会被阻塞在read操作上。</p>
</blockquote>
<h3 id="reactor模式">Reactor模式</h3>
<blockquote>
<p>I/O复用结合线程池</p>
<p>主要组件为Reactor、Acceptor、Handler</p>
<p>非阻塞同步网络模型。</p>
</blockquote>
<h4 id="单线程reactor">单线程reactor</h4>
<blockquote>
<p>Reactor对象通过select监控请求事件，收到事件后通过Dispatch分发。</p>
<p>若是连接事件通过Acceptor处理。然后创建一个Handler处理连接后的事件</p>
<p>若不是连接事件则交给Handler处理。</p>
<p>优点：单线程不用考虑线程切换开销。</p>
<p>缺点：只有一个线程无法完全发挥多核CPU的性能。</p>
</blockquote>
<h4 id="多线程reactor">多线程reactor</h4>
<blockquote>
<p>优化了Handler，handler只负责数据读取，然后将数据分发给worker线程处理，worker线程处理完成后将结果返回给handler。</p>
<p>优点：充分利用多核CPU处理能力</p>
<p>缺点：多线程数据共享和访问比较困难。reactor负责承担所有事件响应，容易成为瓶颈。</p>
</blockquote>
<h4 id="主从reactor模型">主从Reactor模型</h4>
<blockquote>
<figure>
<img src="/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/主从reactor.png" alt="主从reactor"><figcaption aria-hidden="true">主从reactor</figcaption>
</figure>
<p>主Reactor负责将新连接分发给Acceptor，然后主Reactor将连接分发给从reactor。从reactor会将连接加入连接队列进行监听，并创建一个handler用于处理。新事件发生时，从reactor会调用连接对应的handler进行处理，handler负责数据读取，而业务仍交给worker处理。</p>
<p>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</p>
</blockquote>
<h3 id="proactor模型">Proactor模型</h3>
<blockquote>
<figure>
<img src="/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/proactor模型.png" alt="proactor模型"><figcaption aria-hidden="true">proactor模型</figcaption>
</figure>
<p>异步网络模型。</p>
<p>组件：Proactor Initiator、Proactor 、Handler 、AsyOptProcessor。即一个初始化器，一个注册器，一个proactor，一个handler</p>
<p>流程：initiator创建Proactor 、Handler ，然后Proactor 和Handler 都通过AsyOptProcessor注册到内核。</p>
<p>AsyOptProcessor处理注册请求，并处理I/O操作。</p>
<p>AsyOptProcessor完成I/O操作后会通知Proactor，Proactor根据不同的事件类型回调不同的Handler进行业务处理。</p>
<p>优点：效率较reactor模型更高。</p>
<p>缺点：编程更加复杂。</p>
<p>​ 内存使用更加困难。</p>
<p>​ 需要操作系统支持。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>C10K问题的解决及I/O多路复用</title>
    <url>/2021/02/28/netty%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/C10K%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8F%8AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="c10k问题的解决及io多路复用">C10K问题的解决及I/O多路复用</h1>
<h2 id="c10k问题">C10K问题</h2>
<blockquote>
<p>即网络通信时单机服务器保持的TCP连接数超过10K即1万，导致服务器压力过大无法承载。</p>
</blockquote>
<h2 id="发生c10k问题的原因">发生C10K问题的原因</h2>
<blockquote>
<p>本质上是操作系统的问题，操作系统使用的都是传统阻塞I/O模型，处理方式都是requests per thread，导致并发10K和并发100的关键在于CPU。</p>
</blockquote>
<h2 id="解决方法">解决方法</h2>
<blockquote>
<p>原始的TCP连接需要一个线程/进程处理一个连接。</p>
<p>改进为同一个线程/进程处理多个连接。即使用I/O多路复用技术</p>
</blockquote>
<h2 id="io多路复用技术的发展">I/O多路复用技术的发展</h2>
<h3 id="原始情况">原始情况</h3>
<blockquote>
<p>最简单的思路为利用循环挨个处理每个连接，每个连接对应一个socket，当所有socket都有数据时这个方法可行，但若某个socket没有数据会导致线程/进程被阻塞。</p>
</blockquote>
<h3 id="select">Select</h3>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数会传递readset、writeset、exceptset，即读事件、写事件、异常事件，使用fd_set来告知内核同时监控多个文件句柄，最后是timeout是时间参数，可以分为三种情况：一直等待某个描述字直到事件就绪回调、等待到某个时间若某个描述字事件不就绪则不等待、根本不等待某个描述字。</p>
<p>回调后可以通过FD_ISSET 来逐个查看fd_set中的句柄状态，当连接数大时效率较低，因此select存在句柄管理上限。</p>
<p>且fd_set只有一个字段关注事件和发生事件，使用前往往要初始化。</p>
<p>此外fd_set在调用select时需要反复在用户态和内核态传递。</p>
</blockquote>
<h3 id="poll">Poll</h3>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>本质上和select没有区别，都需要轮询，但是poll没有最大文件描述符的限制</p>
<p>pollfd存在事件字段和发生事件字段，使用前不用重复初始化。</p>
<p>此外pollfd在调用poll时需要反复在用户态和内核态传递。</p>
</blockquote>
<h3 id="epoll">Epoll</h3>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll的句柄，用于管理size个监听数目，返回一个fd值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// epoll的事件注册函数，会先注册需要监听的事件类型，epfd为epoll_create的返回值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// 等待事件的发生，只会返回需要处理的事件文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll_event在用户态和内核态的传递只需要在epoll_ctl进行一次。</p>
<p>且事件触发时只会返回触发事件的文件描述符，避免遍历全部的文件描述符。</p>
<p>有ET模式和LT模式</p>
<p>​ ET模式：边缘触发，当状态发生时才通知，每个事件仅通知一次，所以程序必须立即处理该事件。</p>
<p>​ LT模式：水平触发，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件，下次调用epoll_wait时操作系统还会再次向应用程序通知此事件。</p>
</blockquote>
<h2 id="c10m">C10M</h2>
<blockquote>
<p>即并发量上升到10M，此时瓶颈变为了操作系统。</p>
<p>可能的解决方案：</p>
<p>​ 让数据报直接传递到业务逻辑，不经过linux协议栈。</p>
<p>​ 自己管理内存，如将内存预留一部分，并使用更大的内存分页进行管理。</p>
<p>​ 多线程核间绑定，将线程同处理器核心进行绑定，最大化核心Cache利用，实现无锁设计，避免线程切换开销。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>网络</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>1.JAVA内存管理</title>
    <url>/2021/02/20/JVMKnowledge/1.JAVA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="java内存管理">JAVA内存管理</h1>
<h2 id="java内存区域">Java内存区域</h2>
<h3 id="总览">总览</h3>
<blockquote>
<p>堆+栈+程序计数器</p>
<p>堆: 方法区 + 堆</p>
<p>栈: 虚拟机栈 + 本地方法栈</p>
</blockquote>
<figure>
<img src="/2021/02/20/JVMKnowledge/1.JAVA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Java内存区域.png" alt="Java内存区域"><figcaption aria-hidden="true">Java内存区域</figcaption>
</figure>
<h3 id="各部分的作用">各部分的作用</h3>
<h4 id="程序计数器">程序计数器</h4>
<blockquote>
<p>是当前线程所执行的字节码的行号指示器。各线程均有一个程序计数器。如果执行的是Java方法，则程序计数器记录的值为正在执行的虚拟机字节码的地址。若执行的是本地方法，则此时程序计数器的值为undefined。该区域没有规定任何OutOfMemoryError情况。</p>
</blockquote>
<h4 id="java虚拟机栈">Java虚拟机栈</h4>
<blockquote>
<p>生命周期和线程一致，且是线程私有的。当每个方法被执行时，Java虚拟机栈就会创建一个栈帧来保存局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>局部变量表用于存储各种Java虚拟机的<strong>基本数据类型</strong>、<strong>对象引用</strong>(reference类型，不等同与对象本身，可以是对象起始地址的引用指针，也可以是指向一个代表对象句柄或其他与此对象有关的位置)和<strong>returnAdress类型</strong>(指向了一条字节码指令的地址)。在虚拟机栈中，这些数据类型都是用变量槽来表示的。其中64位的long和double占两个变量槽，其他的均只占一个变量槽。局部变量表的大小在<strong>编译期间</strong>就已经完成，故方法所需栈帧分配的局部变量表空间是完全确定的，且不会发生改变。这里空间是指变量槽数，不是具体字节/比特数。</p>
<p>当调用的方法是非static方法时，局部变量表中第0索引的Slot变量槽默认是this关键字指向的对象。</p>
<p>可能出现的异常：</p>
<p>​ StackOverflowError：线程请求栈深度超过虚拟机允许的深度。</p>
<p>​ OutOfMemoryError：当虚拟机栈容量可以动态拓展时，不能申请到足够的内存。</p>
</blockquote>
<h4 id="本地方法栈">本地方法栈</h4>
<blockquote>
<p>和虚拟机栈类似，虚拟机栈为虚拟机执行Java方法服务，而本地方法栈是为虚拟机使用到的本地方法服务。</p>
</blockquote>
<h4 id="java堆">Java堆</h4>
<blockquote>
<p>Java堆是虚拟机所管理的内存中最大的一块。它是被所有线程共享的一块内存区域，在虚拟机启动时创建。java堆的唯一目的就是存放对象实例。它也是垃圾收集器管理的内存区域。大部分垃圾收集器都是基于分代收集理论设计的。</p>
<p>从分配内存的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区。</p>
<p>可能出现的异常：</p>
<p>​ OutOfMemoryError：Java堆中没有内存完成实例分配，且堆无法再拓展。</p>
</blockquote>
<h4 id="方法区">方法区</h4>
<blockquote>
<p>HotSpot：JDK8后使用在本地内存中实现的元空间来代替JDK7中永久代还剩余的内容，JDK6之前使用永久代来实现方法区。</p>
<p>方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>这个区域的回收目标主要是针对常量池的回收和对类型的卸载。</p>
<p>可能出现的异常：</p>
<p>​ OutOfMemoryError：方法区无法满足新的内存分配需求。</p>
</blockquote>
<h5 id="运行时常量池">运行时常量池</h5>
<blockquote>
<p>运行时常量池是方法区的一部分。该部分用于存放编译器生成的各种字面量与符号引用即常量池表。</p>
</blockquote>
<h4 id="直接内存">直接内存</h4>
<blockquote>
<p>直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。</p>
<p>如JDK1.4引入的NIO可以使用Native函数分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作。</p>
<p>本机的直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存大小及处理器寻址空间的限制。</p>
</blockquote>
<h2 id="hotspot虚拟机对象相关内容">HotSpot虚拟机对象相关内容</h2>
<h3 id="对象创建">对象创建</h3>
<blockquote>
<p>步骤分为：类加载检查 -&gt; 分配内存 -&gt; 初始化 -&gt; 对象设置 -&gt; 等待执行构造函数</p>
<p>类加载检查：当Java虚拟机遇到一条字节码new指令时，首先检查这个指令的参数是否可以从常量池地位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。若没有执行相应类的类加载过程。</p>
<p>分配内存：类加载完成后对象所需内存大小可以完全确定，分配内存的方法分为指针碰撞法和空闲列表法。</p>
<p>​ 指针碰撞法：将Java堆的内存视为绝对规整，使用过的内存在一边，未使用过的内存在另一边，分配内存时只需要将指针朝未使用过的内存那边移动即可。该方法要求垃圾收集器需要有空间压缩整理能力。</p>
<p>​ 空闲列表法：Java堆的内存中使用过的内存和未使用过的内存交错在一起，需要维护一个列表记录哪些内存块可用。</p>
<p>分配内存时需要考虑并发问题：即当A利用指针分配内存但还为修改指针位置时，B也使用原来的指针分配内存。解决该问题可以使用CAS加失败重试或把内存操作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为TLAB(本地线程分配缓冲)，只有本地缓冲区的内存用完了，分配新缓冲区时才需要同步锁定。</p>
<p>初始化：虚拟机将分配到的内存空间都初始化为0值。</p>
<p>对象设置：将对象信息如对象是哪个类的实例、如何找到类的元数据信息、对象的GC分代年龄等存入对象的对象头中。</p>
<p>等待执行构造函数：虚拟机等到执行了<init>()方法，完成对对象的全部初始化，此时对象才算被完全的构造出来。</init></p>
</blockquote>
<h3 id="对象内存布局">对象内存布局</h3>
<blockquote>
<p>存储布局划分为三个部分：对象头、实例数据、对齐填充(padding)</p>
<p>对象头可以分为两类：</p>
<p>​ 一类存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。被称为Mark Word。</p>
<p>​ 另一类为类型指针，即对象指向它的类型元数据的指针。Java虚拟机通过这个指针来确定该对象是哪个类的实例。若对象为Java数组，对象头中还要一块用于记录数组长度的数据。</p>
<p>实例数据：即对象真正存储的有效信息，无论是从父类继承还是子类自己定义的字段。存储顺序可以通过(-XX:FieldsAllocationStyle参数)及字段在源码中定义顺序来调整。HotSpot默认分配顺序会将相同宽度的字段分配到一起存放，如longs/doubles。</p>
<p>padding：即填充部分，无意义，只是用于将数据对齐。</p>
</blockquote>
<h3 id="对象访问定位">对象访问定位</h3>
<blockquote>
<p>Java程序会通过栈上的reference数据来操作栈上的具体对象。</p>
<p>主流的访问方式分为句柄和直接指针：</p>
<p>​ 句柄：Java堆中可能划分出一块内存作为句柄池，reference存储的就是对象的句柄地址，而句柄包含对象实例数据与类型数据各自具体的地址信息。</p>
<p>​ 直接指针：reference存储的就是对象地址，访问对象本身不需要多一次间接访问。</p>
<p>​ 两者的优点：句柄访问的优势在于reference存储的是稳定的句柄地址，对象被移动(垃圾回收时对象常常需要被移动)时只需要改变句柄中实例数据指针即可。直接指针的优势在于速度更快，减少了一次指针定位的开销。</p>
</blockquote>
<h2 id="触发异常的情况">触发异常的情况</h2>
<h3 id="java堆内存的outofmemoryerror异常">Java堆内存的OutOfMemoryError异常</h3>
<blockquote>
<p>不断创建对象且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象。</p>
</blockquote>
<h3 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h3>
<blockquote>
<p>-Xss设置栈容量。</p>
<p>1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。</p>
<p>创建太多线程也会导致OutOfMemoryError异常。</p>
</blockquote>
<h2 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出</h2>
<blockquote>
<p>运行时常量池，从JDK7开始后原本存放到永久代的字符串常量池被移动到Java堆中。</p>
<p>-XX：PermSize和-XX：MaxPermSize限制永久代大小。</p>
<p>方法区溢出会在运行时产生大量的类时出现，OutOfMemoryError。</p>
</blockquote>
<h3 id="本机直接内存溢出">本机直接内存溢出</h3>
<blockquote>
<p>大小默认与Java堆最大值一致。可以通过-XX：MaxDirectMemorySize参数指定。</p>
<p>直接或间接(NIO)使用了太多是Unsafe::allocateMemory()分配过多的直接内存会触发OutOfMemoryError异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2.垃圾收集</title>
    <url>/2021/02/20/JVMKnowledge/2.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="垃圾收集">垃圾收集</h1>
<blockquote>
<p>垃圾收集的步骤：判断对象是否存活(可回收) -&gt;</p>
</blockquote>
<h2 id="判断对象存活">判断对象存活</h2>
<h3 id="引用计数">引用计数</h3>
<blockquote>
<p>在对象中添加一个引用计数器，当一个地方有引用它时计数器值加一；引用失效时，计数器值就减一。计数器为0的对象是不可能再被引用的。</p>
<p>存在循环引用的问题</p>
<p>Java中没有使用。</p>
</blockquote>
<h3 id="可达性分析算法">可达性分析算法</h3>
<blockquote>
<p>基本思路：通过一系列称为GC Roots的根对象作为起始点集，当某个对象到起始点集间没有任何引用链相连时，这个对象就是不可能再被使用的。</p>
<p>Java中固定可作为GC Roots的对象：</p>
<p>​ 在虚拟机栈中引用的对象，如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p>
<p>​ 在方法区类静态属性引用的对象，如Java类引用类型静态变量。</p>
<p>​ 在本地方法栈中JNI(Native方法)引用的对象。</p>
<p>​ Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(NullPointExcepiton、OutOfMemoryError）还有系统类加载器。</p>
<p>​ 所有被同步锁持有的对象。</p>
<p>​ 反应Java虚拟机内部情况的JM XBean、JVMTI中注册的回调、本地代码缓存等。</p>
<p>除了固定GC Roots集合外，根据用户选用的垃圾收集器及当前回收的内存区域不同，还可以有其他对象加入。</p>
<p>被判定为不可达的对象还不会被立即回收。真正回收需要经历至少两个标记过程：</p>
<p>​ 若对象在进行可达性分析后分析没有和GC Roots相连接的引用链，会被第一次标记。随后进行一次筛选，若这个对象没有覆盖finalize方法或该方法已经被虚拟机调用，则没有必要执行finalize方法。</p>
<p>​ 若需要执行finalize方法，则会将对象放入F-Queue队列中，然后自动启用线程执行队列中对象的finalize方法。执行后收集器会对队列中对象进行第二次小规模标记，若对象在finalize方法中重新和引用链上的任何一个对象建立关联，第二次标记时它会被移除即将回收的集合。否则，它通常要被回收。</p>
</blockquote>
<h2 id="回收方法区">回收方法区</h2>
<blockquote>
<p>主要回收废弃的常量和不再使用的类型。</p>
<p>回收常量要求：当前常量进入了常量池，且当前系统没有任何一个对象的值是该常量。</p>
<p>回收类型的条件：</p>
<p>​ 该类所有的实例已经被回收。</p>
<p>​ 加载该类的类加载器被回收。</p>
<p>​ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</blockquote>
<h2 id="引用的概念">引用的概念</h2>
<blockquote>
<p>Java的引用在JDK1.2后分为强引用、软引用、弱引用、虚引用。</p>
<p>强引用：最传统的引用的概念，只有强引用关系存在，垃圾收集器就永远不回收被引用的对象。</p>
<p>软引用：描述一些还有用但非必须的对象。只被软引用关联的对象，在系统将要发生内存溢出异常时，会将这些对象列入回收访问进行第二次回收，若回收还没有足够内存，抛出内存溢出异常。</p>
<p>弱引用：描述非必须的对象，被弱引用关联的对象只能生存到下一次垃圾收集发送为止。</p>
<p>虚引用：最弱的引用关系。无法通过虚引用来取得一个对象实例，为对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p>
</blockquote>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<blockquote>
<p>可以分为引用计数式垃圾收集和追踪式垃圾收集。</p>
<p>Java主流虚拟机中只有追踪式垃圾收集。</p>
</blockquote>
<h3 id="分代收集理论">分代收集理论</h3>
<blockquote>
<p>弱分代假说：绝大多数对象都是朝生夕灭的。</p>
<p>强分代假说：熬过越多次垃圾收集过程的对象越难消灭。</p>
<p>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</p>
<p>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</p>
<p>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</p>
<p>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。</p>
<p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</p>
</blockquote>
<h3 id="标记-清除算法">标记-清除算法</h3>
<blockquote>
<p>先标记所有需要回收的对象，标记完成后统一回收掉所有被标记的对象。</p>
<p>存在的问题：</p>
<p>​ 若Java堆中包含大量对象，且大部分都是需要被回收的，需要进行大量的标记清除动作。</p>
<p>​ 内存空间碎片化，标记、清除后会产生大量不连续的内存碎片。</p>
</blockquote>
<h3 id="标记-复制">标记-复制</h3>
<blockquote>
<p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。</p>
<p>半区复制：将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块内存用完了，将还存活着的对象复制到另一块上，然后将已使用过的内存空间一次清理掉。</p>
<p>Appel式回收：分为1块Eden，两块Survivor，分配时使用1块Eden，1块Survivor。回收时将存活的对象放入另一块Survivor中，清理之前使用的Eden和Survivor。内存只浪费了1块Survivor。</p>
<p>优点：当多数对象是可回收的情况时，算法复制的对象少，且分配内存时不用考虑有空间碎片的复杂情况，实现简单。</p>
<p>缺点：浪费了内存空间。</p>
</blockquote>
<h3 id="标记-整理算法">标记-整理算法</h3>
<blockquote>
<p>一般是针对老年代对象。标记完成后不是直接对可回收对象进行清理，而是让所有存活的对象都想内存空间一端移动，然后直接清理掉边界外的内存。</p>
<p>缺点：移动过程耗时较长。</p>
<p>优点：不用考虑内存碎片化问题，降低了内存分配器及内存访问器的复杂度。</p>
</blockquote>
<h2 id="hotpot算法细节">Hotpot算法细节</h2>
<blockquote>
<p>根节点枚举(使用一个OopMap记录)</p>
<p>安全点(到达安全点时将引用关系收集到OopMap，主动式中断和抢占式中断)</p>
<p>安全区域(类似于安全点的扩展)</p>
<p>记忆集和卡表：</p>
<p>​ 记忆集：为了解决对象跨代引用问题，建立的从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<p>​ 卡表：以卡精度实现的记忆集。每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p>
<p>写屏障：为了在机器码的层面将维护卡表的动作放到每个赋值操作之中。赋值操作会在写屏障的覆盖范围中，赋值前部分为写前屏障，赋值后部分为写后屏障，一般来说，都是在写后屏障执行卡表的更新。</p>
<p>卡表带来的高并发问题：伪共享，由于CPU的缓存系统是缓存行为单位存储的，当多线程修改互相独立的变量时，若这些变量刚好共享同一个缓存行，就会互相影响。为了避免这个问题，简单的解决方案是先检查卡表标记，当卡表元素未被标记时才将其标记变脏。</p>
<p>并发的可达性分析：扫描过程时垃圾收集器和用户线程存在并发问题，，可用的解决方法有增量更新(插入引用时记录，扫描完成后以记录的再扫描)、原始快照(删除引用时记录，扫描完成时按记录的再扫描)。</p>
</blockquote>
<h2 id="经典垃圾收集器">经典垃圾收集器</h2>
<h3 id="serial收集器">Serial收集器</h3>
<blockquote>
<p>单线程、简单高效、是所有收集器里额外内存消耗最小的，但是进行垃圾收集时必须暂停其他所有工作线程。</p>
<p>新生代采用复制算法暂停所有用户线程，老年代采用标记-整理算法暂停所有用户线程。</p>
</blockquote>
<h3 id="parnew收集器">ParNew收集器</h3>
<blockquote>
<p>是Serial收集器的多线程并行版本。可以和CMS收集器配合使用。</p>
<p>新生代采用多线程复制算法暂停所有用户线程，老年代采用标记-整理算法暂停所有用户线程。</p>
</blockquote>
<h3 id="parallel-scavenge收集器">Parallel Scavenge收集器</h3>
<blockquote>
<p>基于标记-复制算法实现的新生代收集器，也是能够并行收集的多线程收集器。</p>
<p>而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)，吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。</p>
<p>-XX：MaxGCPauseMillis：允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值，会降低吞吐量。</p>
<p>-XX：GCTimeRatio：值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</p>
<p>-XX：+UseAdaptiveSizePolicy：一个开关参数，开启后可以自动调节参数。</p>
</blockquote>
<h3 id="serial-old收集器">Serial Old收集器</h3>
<blockquote>
<p>是Serial收集器的老年代版本，是一个单线程收集器，使用标记-整理算法。</p>
</blockquote>
<h3 id="parrallel-old收集器">Parrallel Old收集器</h3>
<blockquote>
<p>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法。</p>
</blockquote>
<h3 id="cms收集器">CMS收集器</h3>
<blockquote>
<p>是一种以获取最短回收停顿时间为目标的收集器。它是基于标记-清除算法实现的。其运作过程分为4步：</p>
<p>​ 初始标记(需要stop the world)</p>
<p>​ 并发标记</p>
<p>​ 重新标记(需要stop the world)</p>
<p>​ 并发清除</p>
<p>缺点：</p>
<p>​ CMS收集器对处理器资源非常敏感。会因为占据了一部分线程导致应用程序变慢。CMS默认启动回收线程为(处理器核心数量 + 3 )/4。导致处理器核心&lt;4时占用的性能过多。</p>
<p>​ CMS处理器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”，从而引发Full GC。因为标记结束后，很可能产生新垃圾，CMS无法在当次收集时处理，只能留到下次。所以CMS需要预留一部分空间给并发收集时程序运行使用，可以通过-XX：CMSInitiatingOccupancyFraction来调节。</p>
<p>​ 由于CMS是基于标记-清除算法实现的，会产生大量空间碎片。当碎片过多，大对象很难分配，触发Full GC。-XX：+UseCMS-CompactAtFullCollection:开关参数，让CMS触发Full GC时进行碎片整理。</p>
</blockquote>
<h3 id="garbage-first收集器">Garbage First收集器</h3>
<blockquote>
<p>简称G1，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。它是一款主要面向服务端应用的垃圾收集器。</p>
<p>在G1之前的垃圾收集器垃圾收集的范围要么是整个新生代，要么是整个老年代，要么就是Full GC，G1则是面向堆内存任何部分来组成回收集，衡量标准是哪块内存中存放的垃圾数量最多。</p>
<p>它开创了基于Region的堆内存布局。相当于将堆内存划分为大小相同的连续独立区域，每个区域按需要划分出空间。Region中还要特殊的Humongous区域，专门用于存储大对象。G1将大小超过一个Region容量一半的对象就判定为大对象。超过整个Region容量的对象会被存放到n个连续的Region中。</p>
<p>流程：</p>
<p>​ 初始标记</p>
<p>​ 并发标记</p>
<p>​ 最终标记</p>
<p>​ 筛选回收</p>
</blockquote>
<h3 id="低延迟垃圾收集器">低延迟垃圾收集器</h3>
<blockquote>
<p>Shenandoah收集器</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap分析</title>
    <url>/2021/02/20/JavaBasicKnowledge/ConcurrentHashMap/</url>
    <content><![CDATA[<h1 id="concurrenthashmap">ConcurrentHashMap</h1>
<h2 id="初始化">初始化</h2>
<blockquote>
<p>无参构造</p>
<p>带初始容量的构造</p>
<p>带初始容量和负载因子的构造</p>
<p>带初始容量和负载因子及并发级别的构造：并发级别会规定初始化时最少需要的大小</p>
<p>传入Map的构造</p>
</blockquote>
<h2 id="put操作">Put操作</h2>
<blockquote>
<p>先计算key的hash值，然后判断当前是否存在table，若不存在table则调用initTable方法，这里使用了线程相关及CAS</p>
<p>若存在table判断则判断当前桶位是否为null，为null则创建新结点插入，这里使用CAS锁(会有ABA问题)</p>
<p>然后判断当前结点hash值是否为MOVE，(本质上就是判断当前结点是否为ForwardingNode)，若为MOVE则帮助扩容(此时已经有线程在执行扩容操作了)。</p>
<p>若不是则进行插入操作，此时使用synchronized(f)将当前结点锁住，然后再次判断当前结点f是否为需要插入的位置。</p>
<p>插入完成后判断bitcount是否超过TREEIFY_THRESHOLD，若超过则树化。</p>
<p>最后让集合的大小加一，使用了同步方法。</p>
</blockquote>
<h2 id="inittable">initTable</h2>
<blockquote>
<p>sizeCtl为-1时表示在初始化</p>
<p>当table为空或table长度为0时无限循环，判断此时sizeCtl是否小于0，(当一个线程抢夺成功后会让sizeCtl值为-1，其他线程抢占失败后会进入Thread.yield())，抢夺成功的线程则会判断当前sc值是否大于0，若大于0说明初始化时传入了初始容量，使用该容量创建数组，然后将sc值改为当前容量的0.75。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">     Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">             <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">             Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">             table = tab = nt;</span><br><span class="line">             sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         sizeCtl = sc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容">扩容</h2>
</blockquote>
<blockquote>
<p>sizeCtl &lt; 0时表示在扩容</p>
<p>sizeCtl在扩容时高16位表示扩容标识，低16位表示并行扩容线程数+1。</p>
<p>计算扩容戳本质上是计算当前table长度的前导0个数再或运算一个1000 0000 0000 0000。目的是让sizeCtl在移位后变为负数。</p>
<p>帮助扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line"><span class="comment">// 当table不为空且当前结点为ForwardingNode且当前结点存在nextTable时</span></span><br><span class="line"><span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">(nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//产生扩容戳</span></span><br><span class="line"><span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"><span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">      (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">       sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">       transfer(tab, nextTab);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nextTab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的扩容方法：</p>
<p>先利用CPU数和当前table大小同最小区间间隔进行比较，如果小于最小区间间隔则将间隔设置为MIN_TRANSFER_STRIDE即16。</p>
<p>具体扩容则是每个线程抢夺table的一个区间区间大小为设置的区间间隔大小，如[nextIndex - stride，nextIndex - 1]，抢夺区间的操作使用CAS。</p>
<p>每个线程对于对应区间都会进行依次操作，这里使用synchronized来锁住当前操作的结点。</p>
<p>处理完成后，最后一个正在进行的线程会判断设置finishing标志，最终完成扩容，并设置sizeCtl为原table的1.5倍，即新table的0.75倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="tips">tips</h2>
<blockquote>
<p>最大容量为2^30，默认容量16，默认并发级别16(为了兼容之前的版本)，默认负载因子0.75。最大数字大小Integer.MAX_VALUE - 8。</p>
<p>树阈值8，链表阈值6。最小树化容量64(只有大于该值时才会树化)</p>
<p>若key为null，会报空指针异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>容器</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap分析</title>
    <url>/2021/02/20/JavaBasicKnowledge/HashMap/</url>
    <content><![CDATA[<h1 id="hashmap">HashMap</h1>
<h2 id="hashmap初始化">HashMap初始化</h2>
<blockquote>
<p>初始化时可以设置初始大小和负载因子。默认负载因子0.75，默认容量为16。</p>
<p>HashMap的threshold为负载因子 * 容量。</p>
</blockquote>
<h2 id="hashmap的get方法">HashMap的get方法</h2>
<blockquote>
<p>就是根据传入的key求出对应的hash值，然后根据hash值和数组长度-1进行&amp;运算获得对应下标位置，获取位置后判断当前结点是树结点还是链表结点，从而采取不同的处理方式。</p>
</blockquote>
<h2 id="hashmap的remove方法">HashMap的remove方法</h2>
<blockquote>
<p>根据传入的key求出对应hash值，找到对应桶位，然后根据对应结点的类型为树结点还是链表结点，根据不同结点的类型执行不同的删除操作。链表需要改变指向，树则需要再次平衡。</p>
</blockquote>
<h2 id="hashmap的resize方法">HashMap的resize方法</h2>
<blockquote>
<p>先判断当前是否有table，如果没有table且未设置初始大小，则初始化容量为默认值，阈值为默认值 * 负载因子的数组。若设置了初始大小则初始化容量为设置的大小的二次幂值的数组。</p>
<p>若存在table，先判断旧容量是否大于最大值，若大于则设置阈值为Integer.MAX_VALUE，返回table，否则判断旧容量左移1位后是否不超过最大容量且判断当前容量是否超过默认容量16，若不超过最大容量且当前容量超过默认容量则将旧阈值左移一位。否则将计算newCap * loadFactor，判断新容量是否大于最大容量，若不大于则使用newCap * loadFactor作为新阈值，使用newCap作为数组的新容量。</p>
<p>创建完新数组后，需要将旧table的数据复制到新table之中。</p>
<p>复制的过程：</p>
<p>​ 遍历桶位，若某个桶位只有一个元素则直接根据hash值&amp;新数组容量-1判断需要插入到新数组的什么位置。</p>
<p>​ 若该元素是树结点则使用spilt方法，插入到新数组。</p>
<p>​ 若桶位存在多个链表结点，则大致流程为使用4个指针来记录新旧两个数组的头尾链表位置。即先记录头位置，然后将头位置赋值给尾位置，利用尾位置不断连接结点，最后将头结点赋值给桶位元素。</p>
</blockquote>
<h2 id="hashmap的put方法">HashMap的put方法</h2>
<blockquote>
<p>获取已存在的table，若当前table不存在则resize一个table，若存在则找到对应桶位，根据结点类型采取不同的插入操作，对于链表，插入完成后还会判断当前桶位元素个数是否大于树化阈值，若大于则将桶树化。对于树结点，插入时需要进行平衡。最后插入完成后，判断当前HashMap元素个数是否大于总阈值，若大于则resize扩容。</p>
</blockquote>
<h2 id="tips">tips</h2>
<blockquote>
<p>jdk8后，HashMap红黑树和链表转化是根据泊松分布的，链表转化为树阈值为8，树退化为链表阈值为6。</p>
<p>且红黑树的排序是根据节点的hashcode大小，对于实现了Comparable接口的则使用compare方法来比较。</p>
<p>hashmap默认负载因子0.75，默认容量为16，最大容量为2^30次方，且容量必须为2的次幂大小，因为使用位运算来执行取模操作。</p>
<p>hashmap在操作时会自增modcount，若在遍历时对hashmap执行了操作，则会由于modcount改变而抛出异常。</p>
<p>HashMap线程非安全，HashTable线程安全，ConcurrentHashMap线程安全。</p>
<p>HashTable本质是上是将各方法都加上了synchronized。</p>
</blockquote>
<h2 id="面试题">面试题</h2>
<h3 id="key为null时执行put操作数据放在哪个桶位">key为null时，执行put操作，数据放在哪个桶位？</h3>
<blockquote>
<p>key为null时HashMap求出的hash值为0，故放在第0个桶位。</p>
</blockquote>
<h3 id="hashmap的hash函数为什么需要将hash值移位并异或">HashMap的hash函数为什么需要将hash值移位并异或？</h3>
<blockquote>
<p>注释里有说，为了让高位的hash值对数据产生影响。</p>
</blockquote>
<h3 id="为什么hashmap内部的散列表数组长度一定是2的次方数">为什么HashMap内部的散列表数组长度一定是2的次方数？</h3>
<blockquote>
<p>让查找位置时使用数组长度-1的值会对应2进制的000011111111，后位均为1，提高HashMap的散列性。</p>
</blockquote>
<h3 id="hashmap内部的散列表结构什么时候初始化初始化大小有几种情况">HashMap内部的散列表结构，什么时候初始化？初始化大小有几种情况？</h3>
<blockquote>
<p>构造方法共四种：无参构造、传入初始容量、传入初始容量及负载因子、传入Map</p>
<p>传入Map时会调用resize会初始化。</p>
<p>resize时会初始化。</p>
</blockquote>
<h3 id="hashmap为什么需要扩容扩容又是如何实现的">HashMap为什么需要扩容，扩容又是如何实现的？</h3>
<blockquote>
<p>因为数组过小，会导致插入时会插入到同一个桶位导致查询效率下降，故用空间换时间的方式优化。</p>
</blockquote>
<h3 id="jdk8为什么hashmap引入红黑树">JDK8为什么HashMap引入红黑树？</h3>
<blockquote>
<p>因为数据增大时链表的查询速度低。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程相关</title>
    <url>/2021/02/20/JavaBasicKnowledge/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程">多线程</h1>
<h2 id="进程和线程">进程和线程</h2>
<blockquote>
<p>进程是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位。</p>
<p>通常一个进程中包含多个线程，一个进程至少含一个线程。线程是CPU调度和执行的单位。</p>
</blockquote>
<h3 id="java创建线程的方式">JAVA创建线程的方式</h3>
<blockquote>
<ol type="1">
<li>继承Thread类，重写run方法。调用是使用start方法调用，若使用run方法调用则变为单线程。</li>
<li>实现runnable接口，重写run方法，执行线程需丢入runnable接口实现类，调用start方法。(避免使用继承)</li>
<li>实现callable接口，需要返回值类型，重写call方法，需要抛出异常。(可以返回结果，可以抛出异常)<img src="/2021/02/20/JavaBasicKnowledge/%E5%A4%9A%E7%BA%BF%E7%A8%8B/实现callable.png" alt="实现callable"></li>
</ol>
</blockquote>
<h2 id="java线程的状态">Java线程的状态</h2>
<blockquote>
<p>NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</p>
<p>NEW：线程还没有启动。</p>
<p>RUNNABLE：线程已经在jvm中运行了，但可能还在等待操作系统的处理器之类的资源。</p>
<p>BLOCKED：线程等待monitor lock。</p>
<p>WAITING：正在等待另一个线程执行的状态。</p>
<p>TIMED_WAITING：有着指定特定等待时间等待另一个线程执行的状态。</p>
<p>TERMINATED：线程终止，线程已经结束执行。</p>
<p>线程分为用户线程和守护线程(Daemon)，虚拟机必须确保用户线程执行完毕，虚拟机不用等待守护线程执行完毕。可以通过调用线程的setDaemon(true)，将某个线程变为守护线程</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发相关内容</title>
    <url>/2021/02/20/JavaBasicKnowledge/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="并发相关">并发相关</h1>
<h2 id="可见性">可见性</h2>
<blockquote>
<p>由于内存读取速度和CPU处理速度不匹配的问题，所以往往在CPU和内存之间存在缓存机制，而多个线程执行程序时，会先从内存中读取数据放入CPU缓存中，并且在程序执行的过程中往往不会对数据进行及时更改。导致两个线程之间的数据存在不可见的问题。如子线程使用一个boolean变量来循环，此时主线程改变了该变量，但子线程却不一定会退出循环。</p>
<p>java中使用volatile解决这个问题。</p>
</blockquote>
<h2 id="原子性">原子性</h2>
<blockquote>
<p>一系列操作是不可拆分的。</p>
<p>如count++指令；</p>
<p>会对应汇编的三条指令：</p>
<p>​ count值加载到CPU寄存器</p>
<p>​ 寄存器中+1操作</p>
<p>​ 结果写入操作</p>
</blockquote>
<h2 id="有序性">有序性</h2>
<blockquote>
<p>编译时会进行优化。</p>
<p>int a = 6;</p>
<p>int b = 10;</p>
<p>优化时可能顺序交换了，导致问题。如下可能导致操作1和操作2互换位置，操作3和操作4互换位置，从而使得x = y = 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            a = <span class="number">1</span>; <span class="comment">//操作1</span></span><br><span class="line">            x = b; <span class="comment">//操作2</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            b = <span class="number">1</span>; <span class="comment">//操作3</span></span><br><span class="line">            y = a; <span class="comment">//操作4</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(a + <span class="string">&quot;---&quot;</span> + b + <span class="string">&quot;---&quot;</span> + x + <span class="string">&quot;---&quot;</span> + y + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="happens-before原则">happens-before原则</h2>
</blockquote>
<blockquote>
<p>happens-before原则定义如下： 1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</p>
<p>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</p>
<p>管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</p>
<p>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</p>
<p>线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p>
<p>线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</p>
<p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</p>
<p>传递规则：这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</p>
<p>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</p>
</blockquote>
<h2 id="线程池">线程池</h2>
<blockquote>
<p>可缓存线程池 Executors.newCachedThreadPool()</p>
<p>​ 无上限</p>
<p>定长线程池 Executors.newFixedThreadPool()</p>
<p>​ 最大线程数即为设定的线程数</p>
<p>单线程的线程池 Executors.newSingleThreadExecutor()</p>
<p>​ 只容许一个线程</p>
<p>计划任务线程池 Executors.newScheduledThreadPool()</p>
<p>​ 定时任务。</p>
<p>自定义线程池 ExecutorService myPool = new ThreadPoolExecutor();</p>
<p>线程池可以传入callable对象和runnable对象。</p>
<p>runnable没有返回值和异常，callable可以有返回值也可以抛出异常</p>
<p>submit方法可以获得future对象，用于获取线程返回值和异常。</p>
</blockquote>
<h4 id="底层实现">底层实现</h4>
<blockquote>
<p>调用poolExecutor.execute(t1);方法时会执行的逻辑如下</p>
<p>当当前线程数小于核心线程数数，调用addWorker方法</p>
<p>addWorker方法主要判断了当前线程池状态，当线程池状态符合条件(处于Runing且数量小于规定数量时)，利用CAS操作判断是否可以添加新线程。</p>
<p>若成功添加则调用new Worker创建新线程。然后利用ReentrantLock，锁定，并判断当前线程池状态是否为running，同时检查是否已经启动，若为running且未启动，则将worker添加到workers中(本质是个HashSet<Worker>)，更新largestPoolSize，然后启动线程。返回结果。</Worker></p>
<p>这里启动线程的方法调用的实际上是worker的runWorker方法，该方法会判断(task != null || (task = getTask()) != null)，当当前worker存在任务或任务队列中存在任务时，worker会依次执行beforeExecute，task.run()，afterExecute方法，这个流程会加锁(使用Acquire和Release)</p>
<p>getTask方法则本质上会使用阻塞队列的take方法，阻塞获取任务，或调用设定了超时时间的poll方法，获取任务。</p>
<p>当没有可执行任务时，processWorkerExit，从workers中移除worker。</p>
<p>当当前线程数大于核心线程数，会判断当前线程池状态是否为runnning，且能否成功添加到任务队列中。若成功入队，再次检查当前线程池状态是否符合running，若不是则移除任务。</p>
<p>若无法入队，且当前线程数大于核心线程数，则尝试addWorker，若还不成功则reject任务，reject方式为自己选择的策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="juc工具">juc工具</h2>
</blockquote>
<h3 id="countdownlatch">CountDownLatch</h3>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>在线程中调用cdl.countdown()</p>
<p>主线程使用cdl.await()</p>
<p>只有当cdl变为0时才能触发await后的操作。</p>
</blockquote>
<h3 id="cyclicbarrier">CyclicBarrier</h3>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>先设置栅栏大小，然后在线程中调用cb.await()可以同时等待设置大小个数的线程执行完操作再运行。可以重复使用。</p>
<p>也可以如下初始化，在等待完成时自动执行runnable的run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="semaphore">Semaphore</h3>
<blockquote>
<p>信号量，通过acquire方法和release实现类似锁的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>
<h3 id="phaser">Phaser</h3>
</blockquote>
<blockquote>
<p>可以随时注册，注销</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">9</span>);</span><br><span class="line"><span class="comment">//执行register后，上限值从9变为10</span></span><br><span class="line">phaser.register();</span><br><span class="line">phaser.arriveAndAwaitAdvance();</span><br><span class="line"><span class="comment">//执行以下方法后，下一轮的上限值从10变为9</span></span><br><span class="line">phaser.arriveAndDeregister();</span><br></pre></td></tr></table></figure>
<p>当最后一个线程到达10时，线程会同时唤醒并运行。同时触发onAdvance方法，该方法可以通过自己创建一个phaser类继承Phaser，重写onAdvance方法，然后创建phaser时传入自己的类，即可。</p>
</blockquote>
<h3 id="exchanger">Exchanger</h3>
<blockquote>
<p>线程之间数据交换。需要两个线程都调用此方法，不然会阻塞。只能用于两个线程之间。</p>
<p>exchanger.exchange("xxxx")；</p>
<p>Exchanger<String> exchanger 创建时需要使用泛型。</String></p>
</blockquote>
<h2 id="forkjoin并行计算框架">ForkJoin并行计算框架</h2>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Long time1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// fork 拆解, join 合并</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(<span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">100000000</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get().toString());</span><br><span class="line"></span><br><span class="line">            Long time2 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(time2 - time1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(end - start &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 拆解</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end ; i++)&#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 拆分</span></span><br><span class="line">                <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">                CountTask leftTask = <span class="keyword">new</span> CountTask(start, mid);</span><br><span class="line">                CountTask rightTask = <span class="keyword">new</span> CountTask(mid + <span class="number">1</span>,end);</span><br><span class="line">                <span class="comment">// 拆分任务</span></span><br><span class="line">                invokeAll(leftTask,rightTask);</span><br><span class="line"><span class="comment">//                leftTask.fork();</span></span><br><span class="line"><span class="comment">//                rightTask.fork();</span></span><br><span class="line">                <span class="comment">//获取结果</span></span><br><span class="line">                <span class="keyword">long</span> leftResult = leftTask.join();</span><br><span class="line">                <span class="keyword">long</span> rightResult = rightTask.join();</span><br><span class="line"><span class="comment">//                System.out.println(leftResult + &quot;----&quot; + rightResult);</span></span><br><span class="line">                sum = leftResult + rightResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拆解任务的阈值,如何定义一个任务是最小任务</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="threadlocal">ThreadLocal</h2>
</blockquote>
<blockquote>
<p>线程本地变量，创建一个线程独立的变量。</p>
<p>底层实现的原理：本质上是一个线程中存在一个ThreadLocalMap，用于存储ThreadLocal，该map的key为创建的ThreadLocal对象，而非Thread本身。</p>
<p>get和set本质上也是hashmap类似的哈希计算获取对应数组位置，存入。也存在扩容操作，一次扩容2倍。</p>
<p>ThreadLocal对象使用结束后需要调用remove方法，使其从map中被移除，避免在线程复用时拿到了上次的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">  map.set(<span class="keyword">this</span>, value);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">  ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      T result = (T)e.value;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized">synchronized</h2>
</blockquote>
<blockquote>
<p>同步普通方法，同步的是this</p>
<p>同步静态方法，同步的是类</p>
<p>同步代码块</p>
</blockquote>
<h2 id="reentrantlock">ReentrantLock</h2>
<blockquote>
<p>可重入锁，即自己加了锁还可以再次加锁，如a.lock(); xxxx; a.lock(); a.unlock(); a.unlock();</p>
<p>tryLock() 返回是否拿到锁了。</p>
</blockquote>
<h2 id="readwritelock">ReadWriteLock</h2>
<blockquote>
<p>读写锁一般如下使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">lock.readLock().lock();</span><br><span class="line">lock.writeLock().lock();</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Object类分析</title>
    <url>/2021/02/20/JavaBasicKnowledge/Object/</url>
    <content><![CDATA[<h1 id="object类">Object类</h1>
<blockquote>
<p>Object类是Java中未指定父类的类的默认继承类，也可以说是所有类的祖先。本文档编写目的为通过查看Java源码来加强自己对Object类的理解。不涉及native实现的方法。</p>
</blockquote>
<h4 id="registernatives">registerNatives()</h4>
<blockquote>
<p>native实现，目的是在底层创建对应的java本机函数使JVM找到native方法</p>
</blockquote>
<h4 id="getclass">getClass()</h4>
<blockquote>
<p>返回当前对象运行时对应的类对象，且这个类是静态类型擦除后的结果。如T-&gt;Object;List<String>-&gt;List</String></p>
</blockquote>
<h4 id="hashcode">hashCode()</h4>
<blockquote>
<p>返回当前对象的hash值，在同一个程序执行中，约定当对象相同时即执行equals方法比较的信息不被更改时，不管调用几次hashcode方法，均要返回相同的值。但不要求不同程序产生相同的hashcode</p>
<p>如果两个对象可通过equals方法判定相同，则调用hashcode方法会产生两个相同的值。</p>
<p>如果两个对象通过equals方法判定不同，也不要求hashcode方法产生两个不同的值，但如果产生不同的值会提升哈希表的性能。</p>
<p>如果可以的话，不同对象应该有不同的hash值，这个通常可以根据将对象在内存中的地址转化为整数来实现，但不强制要求。</p>
</blockquote>
<h4 id="equals">equals()</h4>
<blockquote>
<p>判断某些对象是否equals to调用该方法的对象。</p>
<p>实现了非空对象引用上的等价关系判断。</p>
<p>四个特性:自反、对称、传递、一致。</p>
<p>自反: x.equals(x) == true</p>
<p>对称: x.equals(y) == y.equals(x)</p>
<p>传递: x.equals(y), y.equals(z) ------&gt; x.equals(z)</p>
<p>一致: 只要用于equals比较的信息不被改变，则不管调用几次equals方法其值总是不变的。</p>
<p>非空对象引用同null比较值总是为false。</p>
<p>对象之间equals比较只有两个对象是完全相同即地址一致时才会返回true。</p>
<p>为了维持hashcode的原则，在重写equals方法的时候，往往需要重写hashcode方法。</p>
</blockquote>
<h4 id="clone">clone()</h4>
<blockquote>
<p>根据对象的类复制一个对象的副本。</p>
<p>往往有</p>
<p>​ x.clone() != x;</p>
<p>​ x.clone().getClass() == x.getClass()</p>
<p>​ x.clone.equals(x) == true</p>
<p>​ 通常返回的clone对象都是调用super.clone得到的。</p>
<p>​ clone的对象需要和被clone的对象相互独立。这便要求对被clone对象中所有可变属性进行复制，并用副本的引用替换对这些对象的引用。</p>
<p>Object类的clone方法</p>
<p>​ 首先需要继承Cloneable接口。数组类型默认实现了Cloneable接口，且T类型的数组clone的结果的类型为T，需要注意的时，数组clone是直接复制原数组的值即对象引用只是将引用拷贝了，故为浅拷贝。</p>
<p>Object对象没有实现Cloneable接口，故对Object对象使用clone会产生异常。CloneNotSupportedException</p>
</blockquote>
<h4 id="tostring">toString()</h4>
<blockquote>
<p>返回对象的字符串表示形式。往往需要重写这个方法。</p>
<p>这个方法的默认表现为“类名+@+hashcode的十六进制表示”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="notify">notify()</h4>
<blockquote>
<p>唤醒正在wait()该线程所拥有的对象的一个线程。如果有多个线程都在wait该对象，则随机唤醒一个线程，由具体实现决定。</p>
<p>被唤醒的线程只有在对象没有被锁定的情况下才能执行。且被唤醒的线程仍然需要以通常的方式同其他线程竞争对象的使用权，没有其他特权。</p>
<p>该方法只能由当前具有对象使用权的线程调用，获取对象使用权的方式</p>
<p>​ 1.执行对象的synchronize修饰的方法</p>
<p>​ 2.执行synchronize修饰的代码段。</p>
<p>​ 3.执行synchronize修饰的静态方法。</p>
<p>未拥有对象monitor的线程调用会抛出IllegalMonitorStateException异常。</p>
</blockquote>
<h4 id="notifyall">notifyAll()</h4>
<blockquote>
<p>唤醒正在wait()该线程所拥有的对象的所有线程。</p>
</blockquote>
<h4 id="waitlong-timeout">wait(long timeout)</h4>
<blockquote>
<p>让当前线程等待一段时间，直到被notify/notifyAll/一段时间过后唤醒。</p>
<p>调用该方法的线程必须有对象的monitor。</p>
<p>该方法会让线程进入该对象的等待集中，然后放弃对该对象的所有同步声明。 出于线程调度目的，该线程被禁用，并且在发生以下四种情况之一之前一直处于休眠状态：</p>
<ol type="1">
<li>某些线程调用了notify方法并恰好唤醒该线程。</li>
<li>某些线程调用了notifyAll方法。</li>
<li>某些线程调用了interrupt方法。</li>
<li>一段特定时间过去。若为设置特定时间线程会等到被notify为止。</li>
</ol>
<p>从wait方法返回的对象和线程的同步状态会和调用该方法时的状态完全相同。</p>
<p>存在虚假唤醒(spurious wakeup)的问题需要在while中调用wait来避免。</p>
<p>如果该线程在等待之前，或等待期间被另一个线程调用该线程的interrupt()方法，那么当被interrupt线程获得锁之后，会立刻抛出InterruptedException异常，我们可以对这个异常进行捕获，然后处理，以实现线程的唤醒和通信。</p>
<p>wait方法将当前线程放入该对象的等待集中，只会解锁该对象，若当前线程还锁定了其他对象，那么这些对象不会被解锁。(死锁)</p>
</blockquote>
<h4 id="waitlong-timeout-int-nanos">wait(long timeout, int nanos)</h4>
<blockquote>
<p>同一个参数的wait基本一致，但可以输入纳秒级的精度。实际上只是nanos大于0直接让timeout++而已。</p>
</blockquote>
<h4 id="wait">wait()</h4>
<blockquote>
<p>不支持超时自动唤醒。相当于wait(0)</p>
</blockquote>
<h4 id="finalize">finalize()</h4>
<blockquote>
<p>当资源不可达时GC会自动调用对象的finalize方法</p>
<p>这个方法内部可以执行任何操作，包括让这个对象重新可达。但往往只是执行清除操作，如中断I/O连接。</p>
<p>Java编程语言对于所有的对象都不能够保证哪个线程会调用它的finalize方法。然而可以保证一点，调用终结方法的线程必然不会被任何用户可见的同步锁锁住。如果一个没有被捕获的异常在执行终结方法时被抛出，异常会被忽略并且哪个对象的终结过程会被终止。</p>
<p>调用该方法后，java虚拟机会再次判断对象是否可达，若仍不可达对象往往会被摧毁。</p>
<p>finalize()方法不会调用多次。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基本类</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="数据链路层">数据链路层</h1>
<h2 id="数据链路层基本概念">数据链路层基本概念</h2>
<blockquote>
<p>数据链路层的需要解决的问题:</p>
<p>​ 向网络层提供一个定义良好的服务接口。</p>
<p>​ 处理传输错误。</p>
<p>​ 调节数据流，保证慢速的接收方不会被快速的发送方淹没。</p>
<p>使用的信道类型:点对点信道、广播信道</p>
<p>链路:一条点到点的物理线路段，中间没有任何其他的点。</p>
<p>数据链路:除物理线路外，还要有通信协议来控制数据的传输，而实现这些协议的硬件和软件加入到链路上就构成了数据链路。</p>
<p>最常用的方法就是使用适配器(即网卡)来实现这些协议的硬件和软件，一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
</blockquote>
<h2 id="帧">帧</h2>
<blockquote>
<p>数据链路层传送的是帧</p>
</blockquote>
<h2 id="数据链路层的三个基本问题">数据链路层的三个基本问题</h2>
<h3 id="封装成帧">封装成帧</h3>
<blockquote>
<p>就是在一段数据的前后分别添加首部(SOH)和尾部(EOT)。即形成帧首部+帧的数据部分+帧尾部的结构，帧首部和尾部的重要作用就是帧定界。其中帧的数据部分一般不能超过1500(最大传输单元MTU)。为什么最大一般为1500？这是网络带宽和传输效率的统一决定的，MTU太大导致传输时间过长，MTU过小会导致传输效率不高(因为帧的头尾需要占14 + 4个字节)。</p>
<p>接收方会判断收到的帧是否含有头尾部分，若无此部分则会丢弃该数据帧。</p>
</blockquote>
<h3 id="透明传输只知道数据但不知道数据是如何传输的">透明传输(只知道数据但不知道数据是如何传输的)</h3>
<blockquote>
<p>帧的头尾是使用ASCII码的可打印字符集之外的字符组成，若传输的数据不是仅由ASCII码的可打印字符组成时会导致帧的数据部分中可能出现帧尾，会导致接收方提前判断帧结束，且丢弃部分数据。</p>
<p>解决方法:发送端的数据链路层会在数据出现SOH与EOT的前面插入一个字符“ESC"用于转义，若转义字符中也出现在数据中则应该在转义字符前插入一个转义字符，接收端在将数据传送给网络层时会删除其中用于转义的字符。</p>
</blockquote>
<h2 id="差错控制">差错控制</h2>
<blockquote>
<p>比特差错:1可能变为0,0可能变为1。</p>
<p>误码率:传输错误的比特占所传输比特总数的比率称为误码率。</p>
<p>循环冗余检验(CRC)可以做到无差错接收。检验到有差错的帧就丢弃。CRC是一种无比特差错，而不是无传输差错的检测机制。</p>
<p>可靠传输还需要确认和重传机制</p>
</blockquote>
<h2 id="点到点的数据通信">点到点的数据通信</h2>
<blockquote>
<p>PPP协议是全世界使用最多的数据链路层协议</p>
<p>PPP协议的组成部分(由顶到底)</p>
<p>​ NCP网络控制协议</p>
<p>​ LCP链路控制协议</p>
<p>​ 类似于HDLC高级数据链路控制协议，但PPP面向字节而不是面向比特</p>
<p>PPP协议应该满足的要求:</p>
<p>​ 简单、封装成帧、支持多种网络层协议、多种类型链路、差错检测、检测连接状态、最大传送单元、网络层地址协商、数据压缩协商</p>
<p>PPP协议不需要满足的要求:</p>
<p>​ 纠错、流量控制、序号、多点线路、半双工或单工链路</p>
<p>PPP协议的帧格式:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">F(7E)</th>
<th style="text-align: center;">A(FF)</th>
<th style="text-align: center;">C(03)</th>
<th style="text-align: center;">协议</th>
<th style="text-align: center;">消息部分(IP数据报)</th>
<th style="text-align: center;">FCS</th>
<th style="text-align: center;">F(7E)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">一个字节</td>
<td style="text-align: center;">一个字节且为固定值</td>
<td style="text-align: center;">一个字节且为固定值</td>
<td style="text-align: center;">用于表示消息字段中是什么类型的消息</td>
<td style="text-align: center;">不超过1500</td>
<td style="text-align: center;">两个字节</td>
<td style="text-align: center;">一个字节</td>
</tr>
</tbody>
</table>
<p>实现透明传输的方式:</p>
<p>​ 如果是字节传递数据时可以通过插入转义字符并在转义字符0x7D后的一个字符用0x20异或来实现透明传输。</p>
<p>​ 如果采用同步通信，比特流传递数据时，通过零比特填充法，连续5个1在其中插入0。</p>
<p>不使用序号和确认机制的原因</p>
<p>​ 在数据链路层出现的差错的概率不大时使用比较简单的PPP协议较为合理。</p>
<p>​ 在因特网环境下，PPP的信息字段放入的数据是IP数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</p>
<p>​ 帧检验序列FCS字段可保证无差错接受。</p>
</blockquote>
<h2 id="使用广播信道的数据链路层">使用广播信道的数据链路层</h2>
<h3 id="局域网的拓扑">局域网的拓扑</h3>
<blockquote>
<p>星型网、总线网、环形网、树型网</p>
</blockquote>
<h3 id="局域网的特点与优点">局域网的特点与优点</h3>
<blockquote>
<p>主要特点:网络为一个单位所拥有且地理位置和站点数目均有限。</p>
<p>主要优点:具有广播功能，从一个站点可以很方便地访问全网。局域网的主机可以共享连接在局域网上的各种硬件和软件资源。</p>
<p>便于系统的拓展和逐渐演变，各设备的位置可以灵活调整和改变。</p>
<p>提高了系统的可靠性、可用性和生存性。</p>
</blockquote>
<h3 id="以太网通信使用的协议-----csmacd协议">以太网通信使用的协议-----CSMA/CD协议</h3>
<blockquote>
<p>CSMA/CD协议特点:</p>
<p>多点接入:表示许多计算机以多点接入的方式连接在一根总线上。</p>
<p>载波监听:是指每个站在发送数据之前先要检测总线上是否有其他计算机在发送数据，如果有则暂时不发送数据，避免发生碰撞。</p>
<p>​ 通过总线上的电压摆动来判断当前总线上是否存在多个计算机同时发送数据的情况</p>
<p>争用期:最先发送数据帧的站，在发送数据帧后至多经过2t(两倍的端到端时延)即可知道发送的数据帧是否遭受了碰撞。</p>
<p>最短有效帧长:争用期(2t)内可发送的总字节数------64字节。</p>
<p>发生碰撞怎么解决:</p>
<p>​ 推迟一个随机时间再发送，其中基本退避时间为2t，参数k = min(当前重传次数，10)，倍数为r = 1到2^k - 1，重传时延即为r倍的基本退避时间，若重传次数超过16次，则丢弃该帧并向高层报告。</p>
</blockquote>
<h2 id="以太网的其他信息">以太网的其他信息</h2>
<blockquote>
<p>两个标准:DIX Ethernet V2、802.3标准</p>
<p>以太网和数据链路层的两个子层:</p>
<p>​ 逻辑链路控制子层LLC</p>
<p>​ 媒体接入控制子层MAC</p>
<p>以太网提供的访问是不可靠的交付，接收到有差错的数据帧就丢弃，其他什么也不做</p>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各个工作站使用的还是CSMA/CD协议，集线器工作在物理层。</p>
</blockquote>
<h2 id="信道利用率计算">信道利用率计算</h2>
<blockquote>
<p>争用期长度为2t，帧长为L(bit)，数据发送速率为C(b/s)，帧的发送时间为L/C=T0 (s)</p>
<p>信道利用率的参数a = t/T0，故帧长不能太短(为了增大T0)，以太网连线不能太长(为了减小t)。无碰撞的理想情况下，极限信道利用率为</p>
<p><span class="math display">\[S_{max} = T_0 / (T_0 + t) = 1 /(1+a)\]</span></p>
</blockquote>
<h2 id="mac地址">MAC地址</h2>
<blockquote>
<p>硬件地址又称为物理地址，或MAC地址</p>
<p>MAC帧格式(MAC层)</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">目的地址</th>
<th style="text-align: center;">源地址</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">数据</th>
<th style="text-align: center;">FCS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">6个字节</td>
<td style="text-align: center;">6个字节</td>
<td style="text-align: center;">2个字节</td>
<td style="text-align: center;">46~1500</td>
<td style="text-align: center;">4个字节</td>
</tr>
</tbody>
</table>
<p>​ 帧检验序列FCS字段可保证无差错接受。</p>
<p>传到物理层会在前端插入8个字节表示帧开始。</p>
<p>无效的MAC帧:</p>
<p>​ 帧长度不为整数个字节。</p>
<p>​ 用收到的帧检验序列FCS查出有差错。</p>
<p>​ 数据字段的长度不在46~1500字节之间。</p>
<p>​ 有效的MAC帧长度不在64~1518字节之间。</p>
<p>​ 无效的MAC会直接丢弃，以太网不负责重传。</p>
<p>帧间最小间隔为9.6us，相当于96bit的发送时间，目的是为了使刚刚收到数据帧的站接受缓存来得及清理，做好接收下一帧的准备。</p>
</blockquote>
<h2 id="使用网桥拓展以太网">使用网桥拓展以太网</h2>
<blockquote>
<p>优点:过滤通信量、扩大物理范围、提高了可靠性、可互连不同的物理层、不同MAC子层和不同速率的局域网。</p>
<p>缺点:存储转发增加了时延、MAC子层并没有流量控制功能、具有不同MAC子层的网段桥接在一起时时延更大、网桥只适合于用户数不太多和通信量不太大的局域网，否则有时会因传播过多的广播信息产生网络拥塞。</p>
<p>记录的原理:A发出的帧送到网桥，网桥可以记录下哪个接口对应于A，将A的地址放入转发表中，对于不在转发表中的地址采用广播手段进行信息传输，对于在转发表中的地址，则根据记录的地址发送。</p>
</blockquote>
<h2 id="以太网的不同类型">以太网的不同类型</h2>
<blockquote>
<p>速率达到/超过100Mb/s的以太网叫高速以太网</p>
<p>100BASE-T以太网(快速以太网)</p>
<p>​ 在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE 802.3的CSMA/CD协议(半双工时)。</p>
<p>​ 可以在全双工的方式下工作且无冲突发生，不使用CSMA/CD协议，MAC帧格式仍是802.3标准规定的。最短帧长不变，但最大电缆长度减小到100m，帧间时间间隔变为0.96us。</p>
<p>吉比特以太网</p>
<p>​ 允许在1Gb/s下全双工和半双工两种方式工作。使用802.3协议规定的帧格式，在半双工方式下使用CSMA/CD,兼容10BASE-T和100BASE-T</p>
</blockquote>
<h2 id="滑动窗口协议">滑动窗口协议</h2>
<blockquote>
<p>一位滑动窗口协议 停----等式</p>
<p>回退N协议</p>
<p>选择重传协议</p>
</blockquote>
<h2 id="mac层各协议">MAC层各协议</h2>
<blockquote>
<p>ALOHA：想发就发，冲突后随机时间发。</p>
<p>分槽ALOHA：时间槽开始时发，冲突后随机时间发。</p>
<p>1坚持CSMA：监听到空闲一定发，信道忙则一直监听到空闲为止。冲突后随机时间重复此过程。</p>
<p>非坚持CSMA：监听到空闲一定发，信道忙则随机时间再监听。冲突后随机时间重复此过程。</p>
<p>p坚持CSMA：监听到空闲p概率发，信道忙则下一个时间槽再监听，1-p概率下一个时间槽再发送。</p>
<p>CSMA/CD：空闲则直接发送，若忙则等待到通道空闲。检测到冲突终止传输，随机等待一段时间后重新开始监听。则带冲突检测。802.3中使用1坚持-二进制后退的CSMA/CD。</p>
<p>CSMA/CA：空闲时等待一定时间发送，先发送帧，然后接收方会给发送方发送一个确认帧。若发送方没有收到确认帧或遇到冲突则二进制回退再发送。</p>
</blockquote>
<h2 id="无线局域网协议">无线局域网协议</h2>
<blockquote>
<p>存在问题：隐藏终端和暴露终端。</p>
<p>发送方先发送RTS(Request to send)，接收方收到RTS回应CTS(Clear to send)。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC4%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h1 id="网络层">网络层</h1>
<h2 id="网络层传输单元为数据报">网络层传输单元为数据报</h2>
<h2 id="网络层提供的两种服务">网络层提供的两种服务</h2>
<blockquote>
<p>网络层关注的是如何将分组从源端沿着网络路劲送达目的端。</p>
<p>它向运输层通过了虚电路服务和数据报服务。</p>
<p>计算机通信的过程中可靠交付由端系统负责，而不是网络负责。</p>
<p>虚电路服务</p>
<p>​ 通过指定数据的逻辑连接，向端系统保证了数据的按序到达，免去了端系统在顺序控制上的开销。</p>
<p>​ 逻辑上的连接而非真正建立了一条物理连接。</p>
<p>数据报服务</p>
<p>​ 网络层向上提供简单灵活的、<strong>无连接的</strong>、尽最大努力交付的数据报服务。</p>
<p>​ 优点:传输网络不提供端到端的可靠传输服务，使得网络造价降低，运行方式灵活，适用多种应用。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">两个服务对比</th>
<th style="text-align: center;">虚电路服务</th>
<th style="text-align: center;">数据报服务</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">思路</td>
<td style="text-align: center;">可靠通信由网络保证</td>
<td style="text-align: center;">可靠通信由用户主机保证</td>
</tr>
<tr class="even">
<td style="text-align: center;">连接的建立</td>
<td style="text-align: center;">必须有</td>
<td style="text-align: center;">不需要</td>
</tr>
<tr class="odd">
<td style="text-align: center;">终点地址</td>
<td style="text-align: center;">仅在连接建立阶段使用，每个分组使用短的虚电路号</td>
<td style="text-align: center;">每个分组都要有终点的完整地址</td>
</tr>
<tr class="even">
<td style="text-align: center;">分组的转发</td>
<td style="text-align: center;">属于同一条虚电路的分组均按照同一路由进行转发</td>
<td style="text-align: center;">每个分组独立选择路由进行转发</td>
</tr>
<tr class="odd">
<td style="text-align: center;">当结点出故障时</td>
<td style="text-align: center;">所有通过出故障结点的虚电路均不能工作</td>
<td style="text-align: center;">出故障的结点可能丢失分组，一些路由可能发生变化</td>
</tr>
<tr class="even">
<td style="text-align: center;">分组的顺序</td>
<td style="text-align: center;">总数按发送顺序到达终点</td>
<td style="text-align: center;">到达终点时不一定按发送顺序</td>
</tr>
<tr class="odd">
<td style="text-align: center;">端到端的差错处理和流量控制</td>
<td style="text-align: center;">可以由网络负责,也可以由用户主机负责</td>
<td style="text-align: center;">由用户主机负责</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="网际协议ip">网际协议IP</h2>
<h3 id="虚拟互联网">虚拟互联网</h3>
<blockquote>
<p>网络互连的设备:</p>
<p>​ 概念:中间设备又称为中间系统或中继系统</p>
<p>​ 物理层中继系统:转发器。</p>
<p>​ 数据链路层中继系统:网桥或桥接器。</p>
<p>​ 网络层中继系统:路由器。</p>
<p>​ 网络层以上的中继系统:网关。</p>
<p>网络层协议:IP协议最主要。与IP协议配套的协议:</p>
<p>​ ARP地址解析协议。(位于底层)解析MAC地址</p>
<p>​ RARP逆地址解析协议。(位于底层)</p>
<p>​ ICMP网际控制报文协议。(位于顶层)报告网络故障</p>
<p>​ IGMP网际组管理协议。(位于顶层)</p>
</blockquote>
<h2 id="ipv4地址组成">IPv4地址组成</h2>
<blockquote>
<p>IPv4地址由32位IP组成，其中分为网络ID和主机ID。主机ID不能全为0(全0表示网段)也不能全为1(全1表示广播)</p>
<p>A类地址:前8位为网络ID，后24位为主机ID。 0xxxxxxx | x....x 1~126 (127的地址用于做循环测试，本机地址)</p>
<p>B类地址:前16位为网络ID，后8位为主机ID。 10x.....x | x....x 128~191</p>
<p>C类地址:前24位为网络ID，后8位为主机ID。 110x....x | x...x 192~223</p>
<p>D类组播使用。 1110| x.....x(多播地址) 224~239</p>
<p>E类研究使用。 1111| x.....x(保留为今后使用) 240~255</p>
<p>特殊的几个地址:</p>
<p>​ 127.0.0.1 本地环回地址</p>
<p>​ 169.254.0.0 微软在无法自动获取IP时自动分给计算机的IP地址。</p>
<p>​ 保留的私网地址。</p>
<ul>
<li>10.0.0.0 ------ 10.255.255.255</li>
<li>172.16.0.0 ------ 127.31.255.255</li>
<li>192.168.0.0 ------- 192.168.255.255</li>
</ul>
</blockquote>
<h2 id="子网掩码的作用">子网掩码的作用</h2>
<blockquote>
<p>同IP地址作与运算，得到的结果用于判断两个IP是否位于同一网段，从而判断这两个IP的信息交换是否要通过路由器。</p>
<p>可以用于屏蔽IP地址的主机ID部分，来凸显IP地址的网络ID部分，借此判断两个IP能否直接信息交换。</p>
<p>还可以将大的IP网络划分为若干小的网络。(划分子网、等分划分/边长划分)</p>
<p>超网:通过子网掩码把若干个小网络合并为一个大网络。</p>
</blockquote>
<h2 id="ip地址与mac地址">IP地址与MAC地址</h2>
<blockquote>
<p>网络层以上使用IP地址，链路层及以下使用MAC地址</p>
<figure>
<img src="/2021/02/20/computerNetwork/%E7%AC%AC4%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/IP地址和MAC地址.png" alt="IP地址和MAC地址"><figcaption aria-hidden="true">IP地址和MAC地址</figcaption>
</figure>
<p>相比于IP数据报，MAC帧增加了</p>
<p>交换机基于数据帧的MAC地址转发数据帧，路由器基于数据包的IP地址转发数据包。</p>
<p>数据包在传输过程不变，过网络设备数据帧要用新的物理层地址重新封装。</p>
<p>MAC地址决定了数据帧下一跳哪个设备接收，而IP地址决定了数据包的起点和终点</p>
</blockquote>
<h2 id="协议">协议</h2>
<blockquote>
<p>ARP协议:将IP地址转化为物理地址。会使用到广播。</p>
<p>RARP协议:将物理地址转化为IP地址。</p>
<p>ARP欺骗。</p>
</blockquote>
<h2 id="ip数据报">IP数据报</h2>
<blockquote>
<p>IP数据报的首部和数据两部分组成。首部的前一部分是固定，共20字节，是所有IP数据报必须具有的。</p>
<figure>
<img src="/2021/02/20/computerNetwork/%E7%AC%AC4%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/IP地址.png" alt="IP地址"><figcaption aria-hidden="true">IP地址</figcaption>
</figure>
<p>在首部的固定部分的后面是一些可选字段，其长度是可变的。</p>
<p>各字段</p>
<p>0-4位版本(表示为IPv4/IPv6) 4-8位首部长度(最小值为固定长度部分共20个字节。可表示最大15个单位，一个单位4个字节，故首部最大60个字节) 8-16区分服务(数据包所需的服务，定义优先级) 16-32总长度(数据包总大小，一般为1500)</p>
<p>标识(每产生一个数据包就增加1) 标志(判断数据包是否分片) 片偏移(偏移量单位为8个字节)</p>
<p>TTL生存时间值，指定IP包被路由器丢弃之前允许通过的最大网段数量。</p>
<p>协议用于指明上层协议是什么，如ICMP、TCP、UDP等。</p>
<p>首部校验和用于校验数据报是否可用。计算过程:发送端把数据报首部的信息拆成许多单字，然后初始校验和为0，将校验和同这些单字进行反码运算求和，结果取反码即为校验和。接收方重复此过程，若结果为0则保留，不为0则直接丢弃。</p>
<p>源地址、目的地址即为IP地址。</p>
<p>可选字段用于支持排错、测量及安全等措施</p>
</blockquote>
<h2 id="数据路由">数据路由</h2>
<blockquote>
<p>数据路由在不同网段转发数据报。能去能回--------网络畅通。</p>
<p>负载均衡</p>
</blockquote>
<h2 id="icmp协议">ICMP协议</h2>
<blockquote>
<p>报文类型:ICMP差错报告报文、ICMP询问报文</p>
<p>报文前四个字节格式统一共3个字段:类型、代码、检验和，接着的四个字节内容与ICMP的类型有关。</p>
<p>差错报告报文共五种:终点不可达、源点抑制(发数据报的速度过快)、时间超过、参数问题、改变路由/重定向。</p>
<p>询问报文有两种:回送请求和回答报文、时间戳请求和回答报文。</p>
</blockquote>
<h2 id="动态路由协议">动态路由协议</h2>
<blockquote>
<p>RIP最早的动态路由协议，周期性广播，30s广播一次。跳数16次。</p>
</blockquote>
<h2 id="ospf协议开放式最短路径优先---动态路由协议">OSPF协议(开放式最短路径优先)---动态路由协议</h2>
<h2 id="bgp------外部网关协议">BGP ---- 外部网关协议</h2>
<blockquote>
<p>不同自治系统的路由器之间交换路由信息的协议</p>
<p>报文类型：</p>
<p>OPEN</p>
<p>UDDATE</p>
<p>KEEPALIVE</p>
<p>NOTIFICATION</p>
<p>ROUTE-REFRESH</p>
<p>重要属性：</p>
<p>AS-PATH: 包含前缀通告所经过的AS序列</p>
<p>NEXT-HOP(下一跳): 开始一个AS-PATH的路由器接口，指向下一跳AS.</p>
</blockquote>
<h2 id="nat和pat">NAT和PAT</h2>
<blockquote>

</blockquote>
<h2 id="igmp-组播多播">IGMP 组播/多播</h2>
<h2 id="dhcp">DHCP</h2>
<blockquote>

</blockquote>
<h2 id="arp">ARP</h2>
<blockquote>
<p>默认网关为网络上的最低地址，如192.32.65.0/24的默认网关为192.32.65.1</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>概论</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC1%E7%AB%A0-%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="概论">概论</h1>
<h2 id="网络大小划分">网络大小划分</h2>
<blockquote>
<p>个域网</p>
<p>局域网：用于企业时被称为企业网络</p>
<p>城域网</p>
<p>广域网</p>
<p>互联网</p>
</blockquote>
<h2 id="报文的不同称呼">报文的不同称呼</h2>
<blockquote>
<p>网络层中叫数据包/包</p>
</blockquote>
<h1 id="因特网边缘部分的通信方式">因特网边缘部分的通信方式</h1>
<blockquote>
<h4 id="客户服务器方式-cs">客户服务器方式 C/S</h4>
<h4 id="对等方式-p2ppeer-to-peer">对等方式 P2P(peer to peer)</h4>
<p>既是服务器又是客户机</p>
</blockquote>
<h1 id="数据交换方式">数据交换方式</h1>
<blockquote>
<h4 id="电路交换---面向连接">电路交换---面向连接</h4>
<p>交换机位于中心，需要连接时会通过电路连接两个主机。</p>
<p>建立连接:申请占用通信资源。</p>
<p>通话:一直占用通信资源。</p>
<p>释放连接:释放通信资源</p>
<p>适用于数据量很大的实时传输，核心路由器之间可以用电路交换</p>
<h4 id="报文交换">报文交换</h4>
<p>报文一般比分组长的多</p>
<p>报文发送时间长</p>
<h4 id="分组交换计算机使用的方式">分组交换:计算机使用的方式</h4>
<p>发送端对报文进行拆分成不同小组，添加首部组合成一个数据然后发送给接收端。</p>
<p>接收端对数据进行拆除首部，然后根据首部的信息将收到的数据组合成报文</p>
</blockquote>
<h1 id="局域网和广域网不单单从覆盖范围划分还要从使用的技术是什么">局域网和广域网不单单从覆盖范围划分，还要从使用的技术是什么</h1>
<blockquote>
<p>局域网 自己购买设备、自己维护、带宽固定 距离100米内</p>
<p>广域网 花钱买服务、花钱买带宽</p>
</blockquote>
<h1 id="网络的拓扑结构">网络的拓扑结构</h1>
<blockquote>
<p>总线型、环形、星型、树型、网状结构</p>
</blockquote>
<h1 id="网络工作方式">网络工作方式</h1>
<blockquote>
<p>资源子网、通信子网、接入网</p>
</blockquote>
<h1 id="计算机网络的性能">计算机网络的性能</h1>
<blockquote>
<p>速率:主机在数字信道传送数据位数的速率，也成为data rate 或bit rate。</p>
<p>带宽:数据信道所能传送的最高数据率。</p>
<p>吞吐量:单位时间内通过某个网络的数据量。</p>
<p>时延:</p>
<blockquote>
<p>发送时延 数据块长度/信道带宽</p>
<p>传播时延:信道长度/信号在信道上的传播速率</p>
<p>处理时延:在</p>
<p>排队时延:在接收方主机处等待的时间</p>
</blockquote>
<p>时延带宽积 :传播时延 * 带宽</p>
<p>往返时间RTT:从发送方发送数据开始到发送方收到接收方确认。</p>
<p>利用率:</p>
<blockquote>
<p>信道利用率 = 有数据通过时间 / (有 + 无数据通过的时间)</p>
<p>网络利用率：信道利用率加权平均值</p>
</blockquote>
<p>非性能指标:费用、质量、标准化、可靠性、可扩展性、可升级性、管理与维护</p>
</blockquote>
<h1 id="计算机网络的体系结构">计算机网络的体系结构</h1>
<blockquote>
<p>OSI(开放式系统互联)七层模型:分层有利于标准化，且分层后各层之间的变化不会影响到其他层，尽量降低了相互之间的依赖。</p>
<p>物理层:规定电压、接口标准</p>
<p>数据链路层:输入如何封装，添加物理层地址，MAC</p>
<p>网络层:选择最佳路径，IP地址编址</p>
<p>传输层:可靠传输(建立会话)、不可靠传输(不建立会话)、流量控制。</p>
<p>会话层:服务和客户端建立的会话。 netstat -nb</p>
<p>表示层:加密、压缩、编码，开发人员考虑。</p>
<p>应用层: 能够产生网络流量，能够和用户交互的应用程序。</p>
</blockquote>
<h1 id="网络排错">网络排错</h1>
<blockquote>
<p>需要从底层到高层逐一排查</p>
</blockquote>
<h1 id="网络安全和osi参考模型的关系">网络安全和OSI参考模型的关系</h1>
<blockquote>
<p>物理层安全</p>
<p>数据链路层安全:ADSL、无线AP</p>
<p>网络层安全</p>
<p>应用层安全: SQL注入漏洞、上传漏洞</p>
</blockquote>
<h1 id="一些基本概念">一些基本概念</h1>
<blockquote>
<p>实体:交换信息的硬件或软件进程。</p>
<p>协议:控制两个对等实体通信的规则。</p>
<p>服务:下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能。</p>
<p>服务访问点:相邻两层实体间交换信息的地方。</p>
<p>AP接入点和无线路由器和基站作用相差不大，主要负责中继无线计算机之间的数据包，还负责中继无线计算机和Internet之间的数据包。</p>
<p>IEEE802.11俗称WIFI。以太网IEEE802.3。</p>
<p>将两个或多个网络连接起来并提供必要转换的机器，其硬件和软件方面的总称是网关。路由器就是一个网关，在网络层交换数据包。</p>
<p>不可靠的无连接服务通常称为数据报服务。</p>
</blockquote>
<h1 id="tpcip">TPC/IP</h1>
<blockquote>
<p>五层模型:</p>
<p>应用层:</p>
<blockquote>
<p>数据单元:传输数据单元PDU</p>
</blockquote>
<p>运输层:</p>
<blockquote>
<p>数据单元:报文</p>
</blockquote>
<p>网络层:</p>
<blockquote>
<p>数据单元:(IP数据报/IP分组/包)</p>
</blockquote>
<p>数据链路层:</p>
<blockquote>
<p>数据单元:数据帧</p>
</blockquote>
<p>物理层:</p>
<blockquote>
<p>数据单元:比特010101</p>
</blockquote>
</blockquote>
<h1 id="osi参考模型">OSI参考模型</h1>
<blockquote>
<p>应用层:</p>
<p>​ 所有可以和用户交互产生网络流量的程序。</p>
<p>​ 文件传输FTP、电子邮件SMTP、万维网HTTP</p>
<p>表示层</p>
<p>​ 用于处理两个通信系统中交换信息的表示方式。</p>
<p>​ 数据格式变换、数据加密解密、数据压缩和恢复</p>
<p>​ JPEG、ASCII</p>
<p>会话层</p>
<p>​ 向表示层实体/用户进程提供建立连接并在连接上有序地传输数据。</p>
<p>​ 建立、管理、终止会话。</p>
<p>​ 使用检验点可以使会话在通信失效时从检验点/同步点进行恢复通信，实现数据同步。</p>
<p>​ ADSP、ASP</p>
<p>传输层</p>
<p>​ 负责主机中两个进程的通信，即端到端的通信。传输单位是报文/用户数据报</p>
<p>​ 可靠传输、不可靠传输</p>
<p>​ 差错控制</p>
<p>​ 复用分用</p>
<p>网络层</p>
<p>​ 路由选择</p>
<p>​ 流量控制</p>
<p>​ 差错控制</p>
<p>​ 拥塞控制</p>
<p>数据链路层 加上报头和报尾。</p>
<p>​ 把网络层传下来的数据报组装成帧</p>
<p>​ 差错控制</p>
<p>​ 流量控制</p>
<p>​ 接入控制</p>
<p>​ SDLC、HDLC、PPP、STP</p>
<p>物理层</p>
<p>​ 在物理媒体上实现比特流的透明传输</p>
<p>​ 定义接口特性</p>
<p>​ 定义传输模式</p>
<p>​ 定义传输速率</p>
<p>​ 比特同步</p>
<p>​ 比特编码</p>
<p>​ RJ45、802.3</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux介绍及基本指令</title>
    <url>/2021/02/20/Linux/Linux%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux介绍及基本指令">Linux介绍及基本指令</h1>
<h2 id="linux区别">Linux区别</h2>
<blockquote>
<p>Ubantu：分为用户版和服务器版。</p>
<p>​ 用户版，有着良好的用户界面，有强大的软件支持。</p>
<p>​ 服务器版比较少用。</p>
<p>Debian：系统十分稳定，内核非常小。</p>
<p>RedHat：是一个商用的操作系统，性能非常好，软件支持也非常好。</p>
<p>Centos：基本上相当于RedHat的复刻版本。免费。</p>
</blockquote>
<h2 id="根目录下各目录对应的功能">根目录下各目录对应的功能</h2>
<h2 id="在linux中获取帮助">在linux中获取帮助</h2>
<blockquote>
<p>man 命令名：查看命令的操作说明</p>
<p>命令行 --help：查看命令的语法</p>
</blockquote>
<h2 id="linux基本命令">Linux基本命令</h2>
<blockquote>
<p>ls：查看当前目录中所有文件及目录</p>
<p>ll：查看当前目录内所有文件及目录详细信息。详细信息具体查看方式。以drwxr-xr-x为例(第一个字符拆出，然后每三个字符表示一个内容)：</p>
<p>d：文件类型，目录。rwx：拥有者权限，可读，可写，可执行。r-x：用户组权限，可读，不可写，可执行。r-x：其他组权限，可读，不可写，可执行。</p>
<p>具体文件类型有：d：路径。<em>-</em>：文件。 l ：连接(快捷方式)。b：表示可按块随机读写的设备。c：设备文件里的串行端口设备，如键盘、设备。</p>
<p>表示权限的三个字符可以用0~7的数字表示。如rwx为7，r-x为5。</p>
<p>ls -al：查看所有文件及目录包括隐藏目录。</p>
<p>pwd：查看当前所在层级</p>
<p>echo xxx：打印xxx</p>
<p>date：查看日期</p>
<p>cal：查看日历</p>
<p>grep xxx：用于查看包含xxx的对象。</p>
<p>curl 网址：向对应网址发出http请求。curl -i www.baidu.com ：向百度首页发出请求，会返回响应头。</p>
<p>history：查看先前输入过的命令。</p>
<p>df：查看磁盘使用情况。</p>
</blockquote>
<h2 id="文件基本命令">文件基本命令</h2>
<blockquote>
<p>vi xxx：打开临时记事本，基本可以认为是创建文件。</p>
<p>mkdir xxx：创建文件夹</p>
<p>rm -rf xxx：删除目录。</p>
<p>cp a b ：把a文件复制到b处</p>
<p>mv a b ：把a文件移动到b处（也可以当做重命名使用）</p>
<p>tail -number xx：查看文件最后number行内容(可以用于监控日志使用tail -F/-f xxx)-F，-f分别为追踪文件名和追踪文件索引。</p>
<p>cat xxx：查看文件内容，往往伴随着grep使用如 cat a.txt | grep "a:xxx"。</p>
<p>less xxx：查看文件一页的内容。</p>
<p>find xxx：查找文件(可以查找所有文件)。</p>
<p>whereis xx：查找命令所在目录(只能查找二进制类的文件)。</p>
<p>which xxx：在PATH变量指定的路径中搜索指定的系统命令的位置。</p>
<p>sh xxx.sh：执行shell命令。这种执行sh文件不需要本身具有权限。</p>
<p>path/xxx.sh：执行shell命令。sh文件本身需要有权限。(如./xxx.sh其中.表示当前目录)</p>
</blockquote>
<h2 id="文件解压缩">文件解压缩</h2>
<blockquote>
<p>zip -r 压缩后路径加名字 需要压缩的文件：压缩，如zip -r a.zip a.txt。这个命令需要yum install zip</p>
<p>unzip -d 解压缩到的路径 解压缩的包：解压缩，如unzip -d . a.zip。这个命令需要yum install unzip。</p>
<p>tar -cvf 压缩后路径加名字 需要压缩的文件：压缩，如tar -cvf a.txt。</p>
<p>tar -zcvf 压缩后路径加名字 需要压缩的文件：压缩，如tar -zcvf a.txt。压缩后占的空间更少</p>
<p>tar -xvf 解压缩到的路径 解压缩的包：解压缩，如tar -xvf a.txt。</p>
<p>tar -zxvf 解压缩到的路径 解压缩的包：压缩，如tar -zxvf a.txt。</p>
<p>tar的参数：c：表示create，即压缩，z：约等于zip，即打包后空间会更小，v：压缩后展示压缩包中文件名字。f：表示结束。x：extract，即解压缩。</p>
<p>b：表示查看压缩包内容。其中c、x、b同时只能存在一个。</p>
</blockquote>
<h2 id="文件传输">文件传输</h2>
<blockquote>
<p>scp 目录加文件名 用户名@IP地址:目录加文件名：将文件传输利用网络传输到另一个服务器。如scp ./a.txt root@10.0.2.6:~/b.txt</p>
</blockquote>
<h2 id="进程管理命令">进程管理命令</h2>
<blockquote>
<p>top ：查看当前系统使用情况。</p>
<p>ps：查看进程情况。</p>
<p>ps aux：查看所有正在执行的进程。经常和grep配合使用。如ps aux | grep "top"</p>
<p>lsof -i:port ：根据端口号查看进程。需要yum install lsof</p>
<p>kill 进程号：杀死进程。</p>
<p>kill -9 进程号：强制杀死进程。</p>
<p>service xxx start：启动服务。</p>
<p>service xxxx stop：关闭服务。</p>
</blockquote>
<h2 id="权限管理命令">权限管理命令</h2>
<blockquote>
<p>chmod xxx aaa：设置aaa的权限为xxx。第一个x为拥有者权限，第二个x为用户组权限，第三个x为其他组权限。如chmod 777 a.txt：表示将a.txt的权限均设为可读、可写、可执行。</p>
</blockquote>
<h2 id="软件安装命令">软件安装命令</h2>
<blockquote>
<p>yum install xxxx：安装xxxx</p>
<p>yum install ifconfig -y：安装时自动同意。</p>
</blockquote>
<h2 id="安全相关命令">安全相关命令</h2>
<blockquote>
<p>systemctl disable firewalld ：关闭防火墙。</p>
</blockquote>
<h2 id="关机命令">关机命令</h2>
<blockquote>
<p>shutdown：关机</p>
<p>reboot：重启</p>
<p>poweroff：关机</p>
<p>halt：进入系统停止的模式，屏幕可能保留一些信息，取决于电源管理模式。</p>
<p>systemctl suspend：休眠</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC2%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="物理层">物理层</h1>
<h2 id="物理层的基本概念">物理层的基本概念</h2>
<blockquote>
<p>尼奎斯特定理 $ C = 2Blog_2V $ 。C为最大数据速率，B为带宽频率，V为离散等级。</p>
<p>香农定理<span class="math inline">\(C = B log_2(1+S/N)\)</span> 。S/N是信噪比，<span class="math inline">\(10log_{10}S/N\)</span>为分贝，B为带宽频率，C为最大数据速率。</p>
</blockquote>
<h3 id="物理层的主要任务">物理层的主要任务</h3>
<p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流。</p>
<p>确定与传输媒体的接口的一些特性:</p>
<blockquote>
<p>机械特性:如接口形状、大小、引线数目</p>
<p>电气特性:如规定电压范围</p>
<p>功能特性:如规定-5V表示0</p>
<p>过程特性/规程特性:规定建立连接时各个相关部件的工作步骤</p>
</blockquote>
<h2 id="数据通信的基础知识">数据通信的基础知识</h2>
<blockquote>
<p>单向通信/单工通信 ---------只能有一个方向的通信而没有反方向的交互，如电台</p>
<p>半双工通信---------通信双方都可以发送消息，但不能双方同时发送。如对讲机</p>
<p>全双工通信--------通信的双方-可以同时发送和接收消息。如电话</p>
<p>数据比特流传输距离较短,用解调器变为模拟信号后传输距离会加长。</p>
<p>数据--------传送消息的实体</p>
<p>信号--------数据的电气/电磁表现</p>
<p>​ 模拟信号--------连续</p>
<p>​ 数字信号---------离散</p>
<p>码元----------在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p>
<p>信号调制方法:调幅、调频、调相</p>
</blockquote>
<h2 id="物理层下的传输媒体">物理层下的传输媒体</h2>
<h3 id="导向传输媒体">导向传输媒体</h3>
<blockquote>
<p><span class="math display">\[
常用传输频率10^4-------- 10^{16}
\]</span></p>
<p>双绞线:</p>
<p>​ 屏蔽双绞线STP</p>
<p>​ 无屏蔽双绞线UTP</p>
<p>同轴电缆:</p>
<p>​ 50Ω同轴电缆用于数字传输，基带同轴电缆</p>
<p>​ 75Ω同轴电缆用于模拟传输，宽带同轴电缆</p>
</blockquote>
<h2 id="信道复用技术">信道复用技术</h2>
<blockquote>
<p>频分复用:每个用户使用不同的频率传递。</p>
<p>时分复用:将单位时间划分为若干个时间片，每个用户使用对应的时间片传递。 统计时分复用在发送数据时在数据中添加标记，接收方根据标记判定谁接收并将标记去除。</p>
<p>波分复用:每个用户使用不同的波长传递。</p>
<p>码分复用:自己的码片乘积为1，同他人码片乘积为0，传输的信号为原数据同对应码片的乘积，总的传输信号为各个设备传输的信号之和，接收者只要将总信号同自己的码片相乘即可得到需要接收的值。</p>
<p>码分复用的缺点:设备数变多后码片需要越多</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="传输层">传输层</h1>
<h2 id="各层协议">各层协议</h2>
<blockquote>
<p>应用层: http、https、ftp、DNS、SMTP、PoP3、RDP</p>
<p>传输层: TCP、UDP</p>
<p>网络层: IP(RIP、OSPF、BGP) 、ICMP、IGMP、ARP</p>
</blockquote>
<h2 id="传输层两个协议应用场景">传输层两个协议应用场景</h2>
<h3 id="tcp">TCP</h3>
<blockquote>
<p>分段、编号、流量控制、可靠传输、建立会话、面向连接。</p>
</blockquote>
<h3 id="udp">UDP</h3>
<blockquote>
<p>一个数据包就能完成数据通信、不建立会话。</p>
</blockquote>
<h2 id="传输层和应用层之间的关系">传输层和应用层之间的关系</h2>
<blockquote>
<p>http = TCP + 80</p>
<p>https = TCP + 443</p>
<p>ftp = TCP + 21</p>
<p>SMTP = TCP + 25</p>
<p>POP3 = TCP + 110</p>
<p>RDP = TCP + 3389</p>
<p>共享文件夹 = TCP + 445</p>
<p>SQLServer = TCP + 1433</p>
<p>DNS = UDP + 53 OR TCP + 53</p>
</blockquote>
<h2 id="应用层协议和服务之间的关系">应用层协议和服务之间的关系</h2>
<blockquote>
<p>服务运行后在TCP或UDP的某个端口监听客户端请求。</p>
</blockquote>
<h2 id="udp协议">UDP协议</h2>
<blockquote>
<p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元。</p>
<p>TCP传送的协议数据单元是<strong>TCP报文段</strong>。</p>
<p>UDP传送的协议数据单元是<strong>UDP报文</strong>或<strong>用户数据报</strong>。</p>
<p>UDP的首部格式<img src="/2021/02/20/computerNetwork/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/UDP首部格式.png" alt="UDP首部格式"></p>
</blockquote>
<h2 id="tcp协议">TCP协议</h2>
<blockquote>
<p><strong>TCP的特点</strong></p>
<p>​ TCP是面向连接的传输层协议，每条TCP连接只能有两个端点，故TCP连接是点对点的。</p>
<p>​ TCP提供可靠交付的服务，TCP提供全双工通信。</p>
<p>​ TCP面向字节流。</p>
<p>​ 提供流量控制。</p>
<p>​ 避免网络拥塞</p>
</blockquote>
<h3 id="tcp如何">TCP如何</h3>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC6%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="使用tcp">使用TCP</h2>
<blockquote>
<p>HTTP、FTP、Telnet、SMTP</p>
</blockquote>
<h2 id="使用udp">使用UDP</h2>
<blockquote>
<p>流媒体、DNS、网络电话、电话会议</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo简单介绍</title>
    <url>/2021/02/20/codeAnalyse/Dubbo/</url>
    <content><![CDATA[<h1 id="dubbo">Dubbo</h1>
<h2 id="rmi-和-rpc">RMI 和 RPC</h2>
<blockquote>
<p>RMI：远程方法调用，是java自带的API可以实现的，依赖JVM。客户端将要调用的方法和参数打包成辅助对象，通过网络socket，发送给服务端辅助对象，服务端接收后进行解包，找到真正被调用的方法，执行这个方法将执行结果，依次返回。服务端辅助对象进行打包，然后客户端辅助对象进行解包，结果返回给真正的调用者。</p>
<p>IPC：进程间通信。进程是计算机系统资源分配的最小单位，每个进程都是资源隔离的。</p>
<p>LPC：本地过程调用。</p>
<p>RPC：远程过程调用。</p>
</blockquote>
<h2 id="常用rpc框架">常用RPC框架</h2>
<h3 id="dubbo-1">Dubbo</h3>
<blockquote>
<p>阿里开发，基于Spring和Netty，是当前使用最广泛的RPC框架。</p>
</blockquote>
<h3 id="brpc">BRPC</h3>
<blockquote>
<p>百度开发，"baidu-rpc"，支持多种协议，性能优良。</p>
</blockquote>
<h3 id="grpc">GRPC</h3>
<blockquote>
<p>谷歌开发，基于Netty，服务于TensorFlow的底层通信。</p>
</blockquote>
<h3 id="thrift">Thrift</h3>
<blockquote>
<p>Facebook开发。</p>
</blockquote>
<h2 id="注册中心---zookeeper">注册中心 - Zookeeper</h2>
]]></content>
      <categories>
        <category>框架入门</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>分布式</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot原理分析</title>
    <url>/2021/02/20/codeAnalyse/SpringBoot%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="springboot原理">SpringBoot原理</h1>
<h2 id="springbootapplication"><span class="citation" data-cites="SpringBootApplication">@SpringBootApplication</span></h2>
<blockquote>
<p>本质上是</p>
<p><span class="citation" data-cites="SpringBootConfiguration">@SpringBootConfiguration</span>：实际是@Configuration</p>
<p><span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span>：由@AutoConfigurationPackage、<span class="citation" data-cites="Import">@Import</span>({AutoConfigurationImportSelector.class})组成。</p>
<p><span class="citation" data-cites="ComponentScan">@ComponentScan</span>：启用自动扫描，默认扫描所在类的同级类和同级目录下的所有类。</p>
<p>即这个注解实现了注册配置类、启用自动配置、启用自动扫描。</p>
</blockquote>
<h2 id="springapplication.runtestapplication.classargs的实际流程">SpringApplication.run(TestApplication.class,args)的实际流程</h2>
<blockquote>
<p>利用传入的类创建一个SpringApplication实例执行了run方法。</p>
<h3 id="具体创建实例的流程">具体创建实例的流程：</h3>
</blockquote>
<blockquote>
<figure>
<img src="/2021/02/20/codeAnalyse/SpringBoot%E5%8E%9F%E7%90%86/SpringBootAplication初始化过程.png" alt="SpringBootAplication初始化过程"><figcaption aria-hidden="true">SpringBootAplication初始化过程</figcaption>
</figure>
<p>倒数第四行加载了web应用的配置，具体流程是使用默认的类加载器去查找当前是否使用了对应的类。结果可以得出NONE、SERVLET、REACTIVE。</p>
<p>倒数三行之前都是加载主配置。</p>
<p>倒数第三、二行分别是创建初始化器和监听器。创建的流程均为先获取到类加载器，然后查找当前项目中所使用到的初始化器、监听器类名，再利用类名创建类实例，最后将这些实例按优先级排序即可。</p>
<p>创建类实例的方法即为通过反射调用类的构造方法创建。它们都使用了getSpringFactoriesInstances方法。这个方法是先通过读取META-INF/spring.factories文件内容来获取配置，并将配置放入map中。实际中会读取到项目所有jar包中的META-INF/spring.factories。然后利用传入的类名进行匹配找到所需的初始化器/监听器。</p>
<p>按优先级排序，Spring则是通过继承OrderComparator(实现了Comparator接口的类来完成的)，这里利用了模板方法模式，通过完成了findOrder方法，通过比较注解的优先级的方式来findOrder，若未设定优先级则设为最低优先级LOWEST_PRECEDENCE这个值为Integer.MAX_VALUE。</p>
<ul>
<li>（1）先判断有没有实现PriorityOrdered，实现PriorityOrdered比没实现的有高优先级</li>
<li>（2）第一步如果比较不出来，判断有没有实现Ordered，如果实现了，取实现方法的int值比较</li>
<li>前两步都是OrderComparator的默认实现。</li>
<li>（3）如果没有实现Ordered，判断有没有org.springframework.core.annotation.Order注解， 有注解，取注解上的order值，进行比较</li>
<li>（4）如果没有Order注解，判断有没有javax.annotation.Priority注解，取注解上的值比较</li>
<li>若以上都没找到则spring会返回null</li>
<li>（5）OrderComparator接收到null，返回Integer.MAX_VALUE即LOWEST_PRECEDENCE，值越大优先级越低</li>
</ul>
<p>最后一行找到主程序类是通过获取当前程序运行栈，通过找到栈中执行main方法的类，得到主程序类名。</p>
</blockquote>
<h3 id="创建实例后执行run方法的流程">创建实例后执行run方法的流程</h3>
<blockquote>

</blockquote>
<h2 id="自动配置原理">自动配置原理</h2>
<blockquote>
<p><span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span> = <span class="citation" data-cites="AutoConfigurationPackage">@AutoConfigurationPackage</span> + <span class="citation" data-cites="Import">@Import</span>({AutoConfigurationImportSelector.class})</p>
<p><span class="citation" data-cites="AutoConfigurationPackage">@AutoConfigurationPackage</span> = <span class="citation" data-cites="Import">@Import</span>({Registrar.class})</p>
<p>故@EnableAutoConfiguration实际上相当于引入了AutoConfigurationImportSelector和Registrar。</p>
</blockquote>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis流程源码分析</title>
    <url>/2021/02/20/codeAnalyse/mybatis%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="mybatis流程">Mybatis流程</h1>
<h2 id="创建sqlsessionfactory的流程">创建SqlSessionFactory的流程</h2>
<blockquote>
<p>由于创建工厂需要许多配置，mybatis利用了Builder模式。</p>
<p>先创建SqlSessionFactoryBuilder，调用SqlSessionFactoryBuilder的build方法，本质上就是通过解析xml文件，将文件内容映射到Configuration对象中，然后利用这个对象产生builder创建工厂所需的配置，然后创建出SqlSessionFactory。</p>
<p>具体则是先将xml的输入流传给SqlSessionFactoryBuilder，然后创建一个XMLConfigBuilder，负责解析xml内容放入configuration对象，解析的过程中会按类别解析，通过调用不同的方法解析xml的不同部分。解析mapper还有专门的XMLMapperBuilder其中对于二级缓存的处理也在这里进行。解析完成后configuration对象会保存全部的配置信息。</p>
</blockquote>
<h2 id="利用sqlsessionfactory创建sqlsession的流程">利用SqlSessionFactory创建SqlSession的流程</h2>
<blockquote>
<p>就是SqlSessionFactory调用openSession，传入ExecutorType、TransactionIsolationLevel、autoCommit三个参数，或让mybatis按默认设置，</p>
<p>ExecutorType有BatchExecutor、ReuseExecutor、SimpleExecutor、CachingExecutor四种。</p>
<p>​ BatchExecutor 让update操作变为批处理操作，即让连续的update先累积，等到下一次query操作前再一起执行。是使用List作为批处理存储。对于update操作会复用最近一次的statement。失败了会全部回滚。</p>
<p>​ ReuseExecutor 复用Statement，利用Map&lt;String, Statement&gt;来判定。</p>
<p>​ SimpleExecutor 即使用的Statement直接关闭。</p>
<p>​ CachingExecutor 相当于在前面三个执行者的基础上套了一层缓存机制，让query方法先查看缓存，只有缓存没有时再让三个执行者执行操作。这里的缓存是通过mybatis自己实现的statement对象内部的cache实现的，有些类似hashmap，是利用cache和cachekey获得的结果。</p>
<p>TransactionIsolationLevel即事物隔离级别。</p>
<p>​ READ_UNCOMMITTED 读未提交 存在脏读、不可重复读、幻读</p>
<p>​ READ_COMMITTED 读提交 存在不可重复读、幻读</p>
<p>​ REPEATABLE_READ 可重复读 存在幻读</p>
<p>​ SERIALIZABLE 序列化</p>
<p>autoCommit是否自动提交。</p>
</blockquote>
<h2 id="利用sqlsession创建mapper">利用SqlSession创建Mapper</h2>
<blockquote>
<p>SqlSession使用getMapper方法，实际上是调用了configuration中的mapperRegistry的getMapper方法，这里使用了动态代理的设计模式。同时这里还使用了工厂方法，根据不同的类名创建对应的代理工厂。</p>
<p>这个动态代理是JDK代理，它需要使用对应类加载器，对应类接口，对应的InvocationHandler。在mybatis中InvocationHandler是MapperProxy，MapperProxy的重写的invoke函数逻辑是对于Object自带的方法直接调用，对于接口默认的方法直接调用(这个特性是由于JDK8让接口方法可以有默认实现)。对于接口的方法则创建一个MapperMethod对象，该对象使用了缓存机制，利用Map&lt;Method, MapperMethod&gt;缓存方法。</p>
<p>而MapperMethod的excuse即为代理方法的实现，该类中含有MethodSignature、SqlCommand两个内部类用于实现解析sql及方法，而具体方法实现是根据判断当前sql是增删改查中的哪种再调用sqlSession的方法来实现的。</p>
</blockquote>
<h2 id="executor与handler">Executor与Handler</h2>
<blockquote>
<p>Executor是通过StatementHandler来执行sql的。StatementHandler先prepare方法配置基础设置，然后使用parameterize来设置statement的参数。若为query操作则StatementHandler会使用ResultSetHandler来处理结果集。</p>
<p>StatementHandler为抽象interface mybatis基于这个接口实现了抽象类BaseStatementHandler，还实现了路由类RoutingStatementHandler，路由类是用于根据参数创建对应具体类的。而抽象类是作为三个具体类的基础，三个具体类分别为CallableStatementHandler、PreparedStatementHandler、SimpleStatementHandler。</p>
<p>抽象类提供给三个具体类prepare方法，其中prepare中含有抽象方法instantiateStatement，是由具体子类实现的。(模板方法模式)</p>
</blockquote>
<h2 id="mybatis对于数据库操作的整体流程">mybatis对于数据库操作的整体流程</h2>
<blockquote>
<p>先使用builder模式，根据输入的xml输入流，利用对应XML解析对象解析，并将结果最终存入Configuration对象，然后利用Configuration对象创建出一个对应的SqlSessionFactory。</p>
<p>然后需要通过sqlSessionFactory的openSession方法创建一个SqlSession，这里可以设置SqlSession的Executor、TransactionIsolationLevel和autoCommit。Executor代表这个SqlSession采用什么执行器，执行器是对statement对象的处理。具体执行器共有3种：SimpleExecutor 、ReuseExecutor 、BatchExecutor 。同时若启用了缓存cache，则会在执行器外再包装一层CachingExecutor ，相当于对于查询操作提供了二级缓存。这个缓存是位于mybatis的MappedStatement类中。本质上这种缓存就是一个嵌套的哈希结构。Map&lt;Cache, TransactionalCache&gt;，TransactionalCache也是key-value结构。</p>
<p>而事物隔离即为正常的数据库事物隔离级别。</p>
<p>创建完SqlSession后，调用SqlSession的getMapper方法获取对应mapper对象。这里使用了动态代理。mybatis是先根据传入的类对象，通过configuration的配置信息中的MapperRegistry类对象找到对应的proxy工厂，利用代理工厂创建对应的代理对象。代理对象的创建使用的是JDK动态代理，即传入需要代理的类加载器、需要代理的接口、以及InvocationHandler。mybatis的handler是先判断方法是否为Object的，然后判断方法是否为接口默认实现的。只有接口未实现的方法才进行特殊处理，处理过程即为根据方法的类型(增删改查)，执行SqlSession的对应方法。</p>
<p>SqlSession执行对应方法则是利用SqlSession内部的executor执行对应操作的。所以实际上sql操作还是由executor执行的。而executor执行操作需要利用StatementHandler先后执行prepare初始化基本配置和parameterize处理参数。参数的处理利用了ParameterHandler，这个时候typeHandler就会起作用。若为query操作还需要对返回值进行处理，处理时利用了ResultSetHandler，这个时候typeHandler就会起作用。</p>
</blockquote>
<h2 id="mybatis的缓存机制">mybatis的缓存机制</h2>
<blockquote>
<p>mybatis共有两个缓存机制：一级缓存和二级缓存。</p>
<p>一级缓存默认开启且无法关闭。</p>
<p>二级缓存需要配置。</p>
<p>一级缓存是Executor的基本实现类BaseExecutor中实现的，本质上是个Map&lt;Object, Object&gt;。由于每个SqlSession里都带有一个Executor，故一级缓存是SqlSession层面的。</p>
<p>二级缓存则需要手动配置，开启后会在具体的Executor之外使用CachingExecutor包装，这里使用了装饰者模式。二级缓存本质上是在namespace层面的缓存。</p>
</blockquote>
<h2 id="mybatis是怎么实现和springboot的整合的">mybatis是怎么实现和SpringBoot的整合的？</h2>
<blockquote>

</blockquote>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mybatis</tag>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx了解</title>
    <url>/2021/02/20/codeAnalyse/nginx%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="nginx">Nginx</h1>
<h2 id="概述">概述</h2>
<blockquote>
<p>Nginx是高性能的http和反向代理服务器，也是一个IMAP/SMTP/POP3等邮件代理服务器。</p>
<p>正向代理和反向代理</p>
<p>正向代理：客户端client通过设置，使用代理服务器proxy去访问远程服务器server。客户端知道代理存在。</p>
<p>​ | client - proxy | - server</p>
<p>使用场景：</p>
<p>​ 可以访问原来无法访问的资源。</p>
<p>​ 做缓存使用，加快访问速度。</p>
<p>​ 对客户端授权或记录访问信息。</p>
<p>反向代理：服务器通过代理服务接收连接请求，再转发给内部网络的服务器，将结果返回给客户端。客户端不知道代理存在。</p>
<p>​ client - | proxy - server |</p>
<p>使用场景：</p>
<p>​ 保证内网安全，阻止web攻击。</p>
<p>​ 负载均衡。</p>
</blockquote>
<h2 id="nginx命令">Nginx命令</h2>
<blockquote>
<p>启动命令./Nginx</p>
<p>杀死进程 kill SIGNAL pid</p>
<p>​ kill -9 pid 强制停止</p>
<p>​ kill -TERM pid 快速停止</p>
<p>​ kill -QUIT pid 平缓停止</p>
<p>查看版本 ./Nginx -V</p>
<p>信号处理 ./Nginx -s SIGNAL(stop、quit、reopen、reload)</p>
<p>​ 关闭 ./Nginx -s stop</p>
<p>​ 重加载 ./Nginx -s reload</p>
<p>​ 平缓停止 ./Nginx -s quit</p>
<p>​ 快速停止 ./Nginx -s stop</p>
</blockquote>
<h2 id="nginx配置">Nginx配置</h2>
<h3 id="全局块">全局块</h3>
<blockquote>
<p>全局块：指定运行时的用户组、进程id存放位置、日志存放位置、worker process数量等。</p>
<p>#user nobody ：配置用户或用户组</p>
<p>#worker_processes 1 ：运行启动的进程数</p>
<p>#error_log logs/error.log 级别 ：日志路径及级别设置</p>
<p>#pid logs/nginx.pid 进程id的文件地址</p>
</blockquote>
<h3 id="events块">events块</h3>
<blockquote>
<p>events块：影响Nginx服务器和用户网络连接配置，如每个进程最大连接数、选择哪种事件驱动模型、是否序列化events块：影响Nginx服务器和用户网络连接配置，如每个进程最大连接数、选择哪种事件驱动模型、是否序列化。</p>
<p>events{</p>
<p>​ #worker_connections 1024：每个进程的最大连接数</p>
<p>}</p>
</blockquote>
<h3 id="http块">http块</h3>
<blockquote>
<p>http块：配置代理、缓存、日志等绝大部分功能的地方。可以嵌套多个server块，而不同的server可以对应不同的域名(虚拟主机)。</p>
<p>虚拟主机：同一台Nginx服务器，可以支持多个网站的运行，每个虚拟主机之间都互相独立，具有完整功能。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 相对路径</span><br><span class="line">			root html;</span><br><span class="line">			# 默认跳转的首页地址</span><br><span class="line">			index index.html index.htm;</span><br><span class="line"></span><br><span class="line">		&#125;	</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志配置：可以获取用户地址信息、跳转来源、终端、url访问量等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">#access_log logs/access.log main;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th></th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>remote_addr</td>
<td>客户端的ip地址</td>
</tr>
<tr class="even">
<td>remote_user</td>
<td>客户端的用户名称</td>
</tr>
<tr class="odd">
<td>time_local</td>
<td>访问时间和时区</td>
</tr>
<tr class="even">
<td>request</td>
<td>请求方法</td>
</tr>
<tr class="odd">
<td>status</td>
<td>响应状态码 如：200</td>
</tr>
<tr class="even">
<td>body_bytes_sent</td>
<td>主体内容字节数 如：612</td>
</tr>
<tr class="odd">
<td>http_referer</td>
<td>记录是从哪个链接访问过来的</td>
</tr>
<tr class="even">
<td>http_user_agent</td>
<td>用户使用的代理（浏览器）</td>
</tr>
<tr class="odd">
<td>http_x_forwarded_for</td>
<td>通过代理服务器来记录客户端的ip地址</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="反向代理配置">反向代理配置</h3>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 相对路径</span><br><span class="line">			root html;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://127.0.0.1:8080</span><br><span class="line">			# 默认跳转的首页地址</span><br><span class="line">			index index.html index.htm;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理多个tomcat服务器，通过路径来映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location ~ path1 &#123;</span><br><span class="line">			# 相对路径</span><br><span class="line">			root html;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://127.0.0.1:8080</span><br><span class="line">			# 默认跳转的首页地址</span><br><span class="line">			index index.html index.htm;</span><br><span class="line">        &#125;	</span><br><span class="line">		location ~ path2 &#123;</span><br><span class="line">			# 相对路径</span><br><span class="line">			root html;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://127.0.0.1:8081</span><br><span class="line">			# 默认跳转的首页地址</span><br><span class="line">			index index.html index.htm;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="负载均衡">负载均衡</h3>
</blockquote>
<blockquote>
<p>早期使用DNS(域名解析系统)做负载，具体来说就是给客户端解析不同的ip地址，让流量直接到达服务器。</p>
<p>优点： 1） 通过健康检查，避免单点故障 2） 当发现节点故障时，从集群中移除，保证应用的高可用</p>
<p>四层负载均衡，在OSI模型的传输层，主要是转发。 七层负载均衡，在OSI模型的应用层，主要是代理。</p>
<p>负载均衡器可以处理HTTP/HTTPS/TCP/UDP等的请求。</p>
<p>负载均衡的调度算法：</p>
<p>​ 轮询。</p>
<p>​ 最小连接：优先选择连接数最少的服务器，适用于会话时间较长的业务处理。</p>
<p>​ IP映射，根据请求的ip地址进行散列，让同一ip下的请求都映射到同一服务器上，可以解决session问题。</p>
<p>Nginx设置默认轮询算法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080;</span><br><span class="line">		server 192.168.1.20:8081;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置权重的情况，默认权重是1。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080 weight = 1;</span><br><span class="line">		server 192.168.1.20:8081 weight = 2;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据ip地址固定server处理，使用ip_hash。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080 weight = 1;</span><br><span class="line">		server 192.168.1.20:8081 weight = 2;</span><br><span class="line">		ip_hash;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="动静分离">动静分离</h3>
<blockquote>
<p>将静态资源和动态资源分开。</p>
<p>静态资源直接查找Nginx的静态资源地址。</p>
<p>动态资源请求通过反向代理映射到tomcat路径下的资源。</p>
<p>实现方式：</p>
<p>​ 单独把静态文件放在独立的服务器及独立的域名下(推荐)。</p>
<p>​ 将动态资源和静态资源混合在一起，通过Nginx分开。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080 weight = 1;</span><br><span class="line">		server 192.168.1.20:8081 weight = 2;</span><br><span class="line">		ip_hash;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 访问动态资源</span><br><span class="line">		location ~ .*.jsp$ &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">		# 访问静态资源</span><br><span class="line">		location ~ .*\.(gif|jpg|css)$ &#123;</span><br><span class="line">			root /usr/local/nginx/image;</span><br><span class="line">			// 缓存时间</span><br><span class="line">			expires 3d;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="location块的匹配规则">location块的匹配规则</h3>
</blockquote>
<blockquote>
<p>匹配规则：</p>
<p>​ location = /uri 精确匹配</p>
<p>​ location ^~ /uri 前缀匹配，顺序在正则之前</p>
<p>​ location ~ pattern 区分大小写的正则匹配</p>
<p>​ location ~* pattern 不区分大小写的正则匹配</p>
<p>​ location /uri 前缀匹配，顺序在正则之后(两种前缀匹配不能同时出现)</p>
<p>​ location / 通用匹配，接收未匹配到其他location的请求。</p>
<p>匹配顺序：</p>
<p>​ 首先会进行精确匹配，然后会进行前缀匹配，具体顺序按指令长度从长到短的顺序依次匹配。</p>
<p>​ 使用正则匹配时，是按照配置文件的顺序依次匹配的。如果不希望前缀匹配后进行正则匹配，那么使用^~。</p>
</blockquote>
<h3 id="url重写">URL重写</h3>
<blockquote>
<p>即对URL的规范化处理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080 weight = 1;</span><br><span class="line">		server 192.168.1.20:8081 weight = 2;</span><br><span class="line">		ip_hash;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		</span><br><span class="line">		# 重写URL</span><br><span class="line">		rewrite ^/(.*) http://www.xxxx.com/xxx;</span><br><span class="line"></span><br><span class="line">		# 访问动态资源</span><br><span class="line">		location ~ .*.jsp$ &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">		# 访问静态资源</span><br><span class="line">		location ~ .*\.(gif|jpg|css)$ &#123;</span><br><span class="line">			root /usr/local/nginx/image;</span><br><span class="line">			// 缓存时间</span><br><span class="line">			expires 3d;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nginx安装">Nginx安装</h2>
</blockquote>
<blockquote>
<p>在各官网下载相关组件 nginx openssl zlib pcre 等等</p>
<p>以openssl为例 1） 通过rz上传压缩包 2） 通过tar -xvf *.tar.gz 进行解压缩 3）cd openssl-1.1.1d 进行配置检查以及编译 ./config 执行配置检查 make &amp; make install 进行编译和安装</p>
<p>​ 如上过程，适用于zlib和pcre ​ 注意： 对于 pcre而言， 执行检查命令为 ./configure 4) 安装nginx过程中 执行配置检查</p>
<pre><code>./configure --sbin-path=/usr/local/nginx/nginx \
--conf-path=/usr/local/nginx/nginx.conf \
--pid-path=/usr/local/nginx/nginx.pid \
--with-http_ssl_module \
--with-pcre=/usr/local/src/pcre-8.44 \
--with-zlib=/usr/local/src/zlib-1.2.11 \
--with-openssl=/usr/local/src/openssl-1.1.1d</code></pre>
<ol start="5" type="1">
<li>仍然执行 make 以及 make install<br>
</li>
<li>nginx安装成功 ./nginx验证</li>
</ol>
<p>注意事项：nginx服务器，需要虚拟机开放80端口的访问 防火墙配置 （同样适用于开放8080 8081端口） firewall-cmd --list-all 查看当前配置 firewall-cmd --add-service=http --permanent 开放http访问 firewall-cmd --add-port=80/tcp --permanent 开放80端口 firewall-cmd --reload 重启防火墙保存</p>
<p>jdk的安装 1） 解压缩 -- 拷贝目录到 /usr/local/java 2) 更改环境变量 vim /etc/profile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export JAVA_BIN=$JAVA_HOME/bin</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>让环境变量生效 source /etc/profile</li>
<li>验证版本 java -version</li>
</ol>
<p>tomcat的安装 1） 解压缩 -- 拷贝目录到 /usr/local/tomcat 2) 执行启动 ./startup.sh</p>
</blockquote>
]]></content>
      <categories>
        <category>框架入门</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>网络</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/2021/02/20/codeAnalyse/redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="redis使用">Redis使用</h1>
<h2 id="传统数据库的发展">传统数据库的发展</h2>
<blockquote>
<p>单库 -&gt; 单库加缓存 -&gt; 主从分离+缓存(主写从读) -&gt; 分库分表(水平拆分(将一个库拆成多个库)、垂直拆分(按模块拆分))</p>
</blockquote>
<h3 id="传统数据库特点acid">传统数据库特点ACID</h3>
<blockquote>
<p>A(Atomicity)：原子性</p>
<p>C(Consistency)：一致性</p>
<p>I(Isolation)：隔离性</p>
<p>D(Durability)：持久性</p>
</blockquote>
<h3 id="mysql的数据类型">Mysql的数据类型</h3>
<blockquote>
<p>数值型</p>
<p>​ 整数型</p>
<p>​ 小数型</p>
<p>日期时间类型</p>
<p>字符串型</p>
</blockquote>
<h2 id="nosql">NoSQL</h2>
<blockquote>
<p>易拓展：没有关系型数据库的关系型特性。</p>
<p>性能高：NoSQL读写性能高。且cache一般是细粒度的。</p>
<p>数据类型灵活。</p>
</blockquote>
<h3 id="nosql分类">NoSQL分类</h3>
<blockquote>
<p>K-V：Memcache、Redis</p>
<p>列族：Hbase</p>
<p>文档：MongoDB</p>
<p>图：Neo4j</p>
</blockquote>
<h3 id="nosql-cap定理">NoSQL CAP定理</h3>
<blockquote>
<p>CAP定理：一个分布式系统不可能同时很好的满足一致性、可用性、分区容忍性这三个需求，最多只能同时较好的满足两个。</p>
<p>C(Consistency)：所有节点在同一时间有相同的数据。</p>
<p>A(Availability)：保证每个请求不管成功或者失败都有响应。</p>
<p>P(Partition tolerance)：系统中任意信息丢失或失败不会影响系统继续运作。</p>
<p>满足CA：单点集群。</p>
<p>满足CP：满足一致性、分区容忍性的系统，性能一般不高</p>
<p>满足AP：满足可用性、分区容忍性的系统，一致性要求较低。</p>
</blockquote>
<h3 id="nosql-base特点">NoSQL BASE特点</h3>
<blockquote>
<p>BA： Basically Availble基本可用。</p>
<p>S：Soft-state：软状态/柔性事务，无连接</p>
<p>E：Eventual Consistency 最终一致性。</p>
</blockquote>
<h2 id="redis">Redis</h2>
<h3 id="redis命令">Redis命令</h3>
<blockquote>
<p>redis-server：启动服务端</p>
<p>redis-benchmark：压测</p>
<p>redis-cli -p 端口号：启动客户端。</p>
<p>set key1 "xxxx"：设置key1的值为xxxx</p>
<p>get key1：获取key1对应的值</p>
<p>exit：退出当前连接</p>
<p>shutdown：关闭服务端</p>
<p>keys pattern：表示查找符合pattern的key。如keys *</p>
<p>dbsize：展示数据库key个数。</p>
<p>flushdb：删除当前数据库的操作。</p>
<p>flushall：删除所有数据库的数据。</p>
<p>exists xxx：判断xxx的键是否存在。</p>
<p>type xxx：判断xxx的键存储的值类型。</p>
<p>expire key 秒数(n)：设置key值的有效时间为n秒，过期后该key即被删除。</p>
<p>ttl key：查看key的有效时间，正数未过期。返回-1时说明key没有设置有效时间，返回-2说明key已不存在。</p>
<p>pexpire key 毫秒数：设置key值的有效时间为x毫秒。</p>
<p>pttl key：查看key的有效时间，毫秒为单位。</p>
<p>persist key：让key始终存在。</p>
<p>del key：删去key。</p>
<p>rename key1 key2： 把key1重命名为key2。</p>
<p>randomkey：随机找到一个key。</p>
<p>move key dbId ：把key移动到第dbId个数据库下。</p>
</blockquote>
<h3 id="redis配置">Redis配置：</h3>
<blockquote>
<p>database 16：默认16个数据库，可以通过select x来选择当前使用的数据库。可以通过ip：6379【x】中x值判断当前是哪个数据库。</p>
</blockquote>
<h3 id="redis数据结构">Redis数据结构</h3>
<h4 id="基本数据结构">基本数据结构</h4>
<h5 id="string">String</h5>
<blockquote>
<p>命令：</p>
<p>​ strlen key ：获取key存储的字符串长度</p>
<p>​ append key “xxx" ：在原有的基础上添加字符串。</p>
<p>​ getrange key strat end： 获取子串</p>
<p>​ getset key value ：修改原key对应的值并将旧值返回。</p>
<p>当值为整数时，直接进行数学运算。</p>
<p>​ incr key ：key对应的值自增1</p>
<p>​ incrby key number ：key对应的值自增number</p>
<p>​ decr key：key对应的值自减1</p>
<p>​ decrby key number ：key对应的值自减number</p>
<p>​ setex key 秒数 值：相当于同时设置了过期时间和值。</p>
<p>​ setnx key：不存在时才设置。</p>
<p>​ mget key1 key2.....：一次获取多个key对应的值</p>
<p>​ mset key1 value1 key2 value2.....：一次设置多个key-value。</p>
<p>​ msetnx key1 value1 key2 value2.....：一次设置多个key-value，具体set操作同setnx。</p>
<p>原理：</p>
<p>​ redis字符串是动态字符串，内部类似于ArrayList。采用预分配冗余空间的方式减少内存的频繁分配。当字符串长度&lt;1MB，扩容方式是直接加倍，若&gt;1MB，一次扩容只扩容1MB，直到扩大到512MB。</p>
</blockquote>
<h5 id="list">List</h5>
<blockquote>
<p>lpush key value1 value2 value3 .... ：从左侧存放值。</p>
<p>lpop key：从左侧弹出。</p>
<p>rpush key value1 value2 value3 .... ：从右侧存放值。</p>
<p>rpop key：从右侧弹出。</p>
<p>lrange key start end：按范围查看值。</p>
<p>llen key：查看长度</p>
<p>lindex key index：获取key对应index位置的值。</p>
<p>lrem key count value：移除count绝对值个和value相同的值。</p>
<p>ltrim key start end：截取范围内的值重新赋值给key。</p>
<p>linsert key before/after oldValue newValue 插入数据到某个数据前/后。</p>
<p>lpushx key value ：在列表头部插入数据。</p>
<p>rpushx key value：在列表尾部插入数据。</p>
<p>lset key pos value：把列表的第pos个位置改为value。</p>
<p>最多可存储<span class="math inline">\(2^{32}-1\)</span>个元素</p>
<p>原理：</p>
<p>​ 底层是一个快速链表，在列表元素较少时使用连续的内存压缩列表ziplist。当数据量较多时，改为quicklist，即将多个ziplist使用双向指针串起来使用。</p>
</blockquote>
<h5 id="hash">Hash</h5>
<blockquote>
<p>本质上类似于HashMap&lt;String,Map&gt;</p>
<p>hset key field value</p>
<p>hget key field</p>
<p>hkeys key</p>
<p>hvals key</p>
<p>hmset key field1 value1 field2 value2 ....</p>
<p>hmget key field1 field2 .....</p>
<p>hdel key field</p>
<p>hgetall key</p>
<p>hexists key field</p>
<p>hsetnx key field value</p>
<p>hincrby key field increment 让field增加increment</p>
<p>原理：</p>
<p>​ 底层同HashMap，也是数组+链表，但是redis的值只能为字符串，且二者rehash的方式不同，java的HashMap是一次全部rehash，redis采用渐进式rehash。具体操作为同时保留新旧两个hash结构，然后逐步搬迁。</p>
</blockquote>
<h5 id="set">Set</h5>
<blockquote>
<p>类似于HashSet，也是通过哈希表实现的，相当于所有value都是空的。通过计算hash的方式快速排除重复。</p>
<p>sadd key value1 value2 value3 value4</p>
<p>scard key 查看当前set的元素个数</p>
<p>smembers key 查看当前set的具体元素值</p>
<p>srem key value1 value2 value3 value4 移除元素</p>
<p>sismember key value 判断value是不是set中的元素</p>
<p>srandmember key number 在set中随机查看number个元素。</p>
<p>spop key number 在set中随机弹出number个元素。</p>
<p>smove key1 key2 value 移动元素value从key1到key2</p>
<p>sinter key1 key2 求key1、key2的交集</p>
<p>sunion key1 key2 求key1、key2的并集</p>
<p>sdiff key1 key2 求key1、key2的差集</p>
<p>sunionstore des key1 key2 求出key1、key2的并集然后存入des中</p>
</blockquote>
<h5 id="zset有序集合">Zset(有序集合)</h5>
<blockquote>
<p>和无序集合的区别是每个元素除了值之外还有一个浮点数的分数。内部实现使用了跳表。分数可重复，但值不可重复。</p>
<p>zadd key score1 value1 score2 value2 score3 value3 ....</p>
<p>zrange key start end [with scores] 查看范围内的值，加了with scores可以看见对应分数。</p>
<p>zrangebyscore key min max [limit offset num]查看对应分数范围内的值。 分数前加(表示开区间，[表示闭区间。如 zrangebyscore key (1 [99。加上【】内语句可以分页。</p>
<p>zrem key value 删除</p>
<p>zcard key 统计元素个数</p>
<p>zcount key min max 统计分数在min，max内的值个数</p>
<p>zscore key member 查询指定成员分数</p>
<p>zrank key member 查询指定成员分数排名(正序，从小到大排名)</p>
<p>zrevrank key member 查询指定成员分数排名(逆序，从大到小排名)</p>
</blockquote>
<h4 id="拓展数据结构">拓展数据结构</h4>
<h5 id="geo">GEO</h5>
<blockquote>
<p>基于zset的拓展，用于存储地理位置信息。</p>
<p>geoadd key 经度1 纬度1 member1 经度2 纬度2 member2.....</p>
<p>zrange key start end withscores</p>
<p>geodis key value1 value2 距离单位(m/km) 求两个位置之间的距离。</p>
<p>geopos key value 查询某地位置</p>
<p>geohash key value 对value进行hash</p>
<p>georadius key 经度 纬度 半径长度 长度单位 [withdist/withcoord/withhash]：以某个经纬度位置为中心，然后指定半径，返回满足条件的地址。</p>
</blockquote>
<h5 id="bitmap">Bitmap</h5>
<blockquote>
<p>setbit key index 0/1 零存</p>
<p>set key value 整存</p>
<p>getbit key index 零取</p>
<p>get key 整取</p>
<p>bitcount key 计算有几个1</p>
<p>bitcount key start end 从第start个字符到第end个字符有几个1</p>
</blockquote>
<h5 id="hyperloglog基数统计">HyperLogLog(基数统计)</h5>
<blockquote>
<p>pfadd key field 添加指定元素，若已存储返回0</p>
<p>pfcount key 返回基数值</p>
</blockquote>
<h5 id="stream">Stream</h5>
<blockquote>
<p>具体指令格式省略。</p>
<p>xadd 生成消息，返回消息id(时间戳+顺序)，顺序指该毫秒下消息的顺序。</p>
<p>xlen 查看消息列表长度</p>
<p>xrange 查看消息</p>
<p>xdel 删去消息</p>
<p>xread 读取消息</p>
</blockquote>
<h3 id="发布和订阅">发布和订阅</h3>
<blockquote>
<p>发布者发布消息到调度中心，订阅者从订阅中心订阅消息。类似于观察者模式。</p>
<p>redis中使用subscribe channel订阅，使用publish channel message发布消息。</p>
</blockquote>
<h3 id="redis配置-1">Redis配置</h3>
<h3 id="redis淘汰策略">Redis淘汰策略</h3>
<blockquote>
<p>volatile-lru：对超时key采用最近最少使用策略。</p>
<p>allkeys-lru：对所有key采用最近最少使用策略。</p>
<p>volatile-random：对超时的key采用随机淘汰策略。</p>
<p>allkeys-random：对所有key采用随机淘汰策略。</p>
<p>volatile-ttl：采用删除存活时间最短的键值对策略。</p>
<p>noeviction：不淘汰，当内存已满时再进行写操作会返回错误。</p>
<p>这里的LRU算法和TTL算法都是近似算法，redis使用抽样的方式执行。可以配置maxmemory-samples的值来控制抽样范围。</p>
</blockquote>
<h3 id="redis持久化">Redis持久化</h3>
<h4 id="rdb">RDB</h4>
<blockquote>
<p>在指定时间间隔对数据进行快照存储。是全量备份。</p>
<p>命令触发：</p>
<p>​ save：阻塞当前Redis服务器，直到持久化完成。</p>
<p>​ bgsave：fork一个子进程，由子进程负责持久化过程。</p>
<p>自动触发：</p>
<p>​ 根据配置的save m n 配置规则自动触发</p>
<p>​ 从结点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点触发bgsave</p>
<p>​ 执行debug reload时</p>
<p>​ 执行shutdown若没有开启aof时也会触发。</p>
<p>恢复方式：</p>
<p>​ 将备份文件(dump.rdb)移动到redis安装目录并启动服务即可。</p>
</blockquote>
<h4 id="aof">AOF</h4>
<blockquote>
<p>以日志文本形式记录服务器所处理的每个数据更改指令，通过重放来恢复数据，是增量备份。</p>
<p>本质上就是以日志的形式记录服务器处理的每个更改操作。</p>
<p>但是实际中由于更改操作可能数量巨大，导致恢复数据较慢，所以会对日志进行重写，即让某些操作合并。</p>
<p>具体流程：命令写入-&gt; 追加到aof_buf -&gt; 同步到aof磁盘</p>
<p>aof重写：</p>
<p>​ 手动触发：bgrewriteaof</p>
<p>​ 自动触发：根据配置规则来触发。</p>
<p>写入aof文件时若redis服务器宕机，日志文件会出现格式错误，重启时服务器会拒绝载入。可以通过redis-check-aof -fix file.aof来修复。</p>
</blockquote>
<h3 id="redis分布式锁">Redis分布式锁</h3>
<h4 id="乐观锁">乐观锁</h4>
<blockquote>
<p>每次处理数据时都认为别人都不会去修改数据，所以每次拿数据时都不会上锁。但如果想要更新数据，会在更新前检查在读取至更新这段时间内别人是否修改过这个数据，若修改过则重新读取，再次尝试更新，循环步骤直至成功。</p>
<p>乐观锁回滚重试，适用于写比较少的情况。</p>
<p>CAS算法(非阻塞同步)：</p>
<p>​ 读取一个A，在将其更新到B前，检查值是否还是A。</p>
<p>​ 若还是A则将A更新为B，否则什么也不做。</p>
<p>CAS缺点：ABA问题。</p>
</blockquote>
<h4 id="悲观锁">悲观锁</h4>
<blockquote>
<p>每次处理数据时都认为别人都会去修改数据，所以每次拿数据时都会上锁。</p>
<p>悲观锁阻塞事务，适用于写比较多的情况。</p>
</blockquote>
<h4 id="分布式锁">分布式锁</h4>
<blockquote>
<p>三种方式：数据库乐观锁、基于Redis的分布式锁、基于ZooKeeper的分布式锁。</p>
<p>分布式锁需要满足四个条件：</p>
<p>​ 互斥性。任意时刻只有一个客户端能持有锁。</p>
<p>​ 不会发生死锁。即使一个客户端崩溃了未能主动解锁，其他客户端也能加锁。</p>
<p>​ 具有容错性。</p>
<p>​ 加锁和解锁必须是同一个客户端。</p>
<p>redis实现分布式锁：</p>
<p>​ 通过setnx，和del来实现加锁和解锁的功能。</p>
<p>​ 其中setnx key value ex 在加锁的同时加上锁的过期时间，避免产生死锁。</p>
<p>​ 也可能配合lua脚本使用，因为lua可以保证连续多个子命令的原子性执行的。</p>
</blockquote>
<h2 id="主从模式">主从模式</h2>
<blockquote>
<p>slave of</p>
<p>从节点只允许读。</p>
<p>复制过程：</p>
<p>​ 旧版是SYNC：主库先生成一个RDB文件，然后将这个文件通过网络发送给从库</p>
<p>​ 新版(2.8以后)是PSYNC：分为完整重同步和部分重同步。完整重同步用于初次复制，类似于旧版的SYNC。部分重同步用于处理断线后重复制的情况。当从服务器断线后重连主服务器时，条件允许的话主服务器可以将主从服务器断开连接期间的写命令发送给从服务器，从服务器只要接收执行这些命令即可完成同步。</p>
<p>​ 部分重同步的实现需要：</p>
<p>​ 主服务器的复制偏移量和从服务器的复制偏移量。</p>
<p>​ 主服务器的复制积压缓冲区。</p>
<p>​ 服务器的运行ID。</p>
</blockquote>
<h2 id="哨兵模式">哨兵模式</h2>
<blockquote>
<p>主服务器中断服务时，将一个从服务器升级为主服务器。为了实现自动执行这一操作，就出现了哨兵模式。</p>
<p>哨兵作用是监控redis系统的运行状况，功能包括：</p>
<p>​ 监控主服务器和从服务器是否正常运行。</p>
<p>​ 主服务器出现故障时自动将从服务器转换为主服务器。</p>
<p>哨兵模式优点：</p>
<p>​ 主从可以切换，系统更加健壮，可用性更高。</p>
<p>哨兵模式缺点：</p>
<p>​ Redis较难在线扩容，在集群容量达到上限时在线扩容变得十分复杂。</p>
</blockquote>
<h2 id="cluster模式">Cluster模式</h2>
<blockquote>
<p>集群：使用多个主从模式的redis搭建，每个主从模式的redis又充当彼此的哨兵。</p>
</blockquote>
<h2 id="缓存可能遇到的问题">缓存可能遇到的问题</h2>
<h3 id="缓存穿透">缓存穿透</h3>
<blockquote>
<p>访问一个不存在的key，缓存不起作用，请求穿透到DB。这个key在数据库也查询不出结果，导致反复查询都会直接去查询数据库。</p>
<p>解决方案：采用布隆过滤器，使用一个足够大的位图，存储可能访问的key，不存在的key直接过滤。或者对应key去查询数据库时即使查询不出结果也在缓存中设置一个缓存，让下次查询可以访问缓存。</p>
</blockquote>
<h3 id="缓存雪崩">缓存雪崩</h3>
<blockquote>
<p>大量的key设置了相同的过期时间，导致缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<p>解决方案：给缓存设置过期时间的同时加上一个随机值时间，使得每个key的过期时间发布开，不会集中在同一时刻失效。</p>
</blockquote>
<h3 id="缓存击穿">缓存击穿</h3>
<blockquote>
<p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求会击穿到DB，造成瞬时DB请求量大。</p>
<p>解决方案：在访问key之前，采用SETNX来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>框架入门</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>数据库</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot常用配置</title>
    <url>/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="springboot常用配置">SpringBoot常用配置</h1>
<h2 id="选择不同配置">选择不同配置</h2>
<blockquote>
<p>也可以通过在类中使用@Profile("xx")来表示这个类只有在xx为active的情况下才可使用。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/springboot多配置文件设置启用.png" alt="springboot多配置文件设置启用"><figcaption aria-hidden="true">springboot多配置文件设置启用</figcaption>
</figure>
</blockquote>
<h2 id="自动加载配置文件的内容">自动加载配置文件的内容</h2>
<blockquote>
<p><span class="citation" data-cites="Value">@Value</span></p>
<p><span class="citation" data-cites="ConfigurationProperties">@ConfigurationProperties</span>(prefix = "spring.datasource.druid.write") 使用该注解需要引入且要启用@EnableConfigurationProperties(使用前面一个注解的类.class)</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><span class="citation" data-cites="PropertySource">@PropertySource</span></p>
</blockquote>
<h2 id="配置文件的加载顺序下覆盖上">配置文件的加载顺序(下覆盖上)</h2>
<blockquote>
<ol type="1">
<li>Application properties packaged inside your jar (application.properties and YAML variants).</li>
<li>Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants).</li>
<li>Application properties outside of your packaged jar (application.properties and YAML variants)</li>
<li>Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants).</li>
</ol>
</blockquote>
<h2 id="自动加载的-application.properties-的加载顺序下覆盖上">自动加载的 application.properties 的加载顺序(下覆盖上)</h2>
<blockquote>
<ol type="1">
<li><p>The classpath root</p></li>
<li><p>The classpath /config package</p></li>
<li><p>The current directory</p></li>
<li><p>The /config subdirectory in the current directory</p></li>
<li><p>Immediate child directories of the /config subdirectory</p></li>
</ol>
<p>4、5的差别就是如果config目录的根目录里有application.properties，则会将config子目录的application.properties覆盖。</p>
<p>而classpath中springboot不会自动扫描config子目录中的目录。</p>
<p>可以通过修改spring.config.name来修改默认配置文件名。</p>
<p>修改spring.config.location 可以修改springboot获取配置文件的位置。</p>
<p>修改spring.config.additional-location可以在springboot默认获取配置文件的位置的基础上补充一些获取配置文件的位置。optional: 前缀</p>
</blockquote>
<h2 id="可以使用来获取外部目录classpath中不能使用">可以使用*来获取外部目录，classpath中不能使用*</h2>
<h2 id="可以使用---在.pro配置文件中划分逻辑页">可以使用#---在.pro配置文件中划分逻辑页</h2>
<h2 id="使用---在.yml配置文件划分逻辑页">使用---在.yml配置文件划分逻辑页</h2>
<h2 id="在多个配置文件中均存在同一个list的值则只会去最高优先级的list值">在多个配置文件中均存在同一个list的值，则只会去最高优先级的list值</h2>
<h2 id="在多个配置文件中均存在同一个map的值则使用互补配置的方式构造map">在多个配置文件中均存在同一个Map的值，则使用互补配置的方式构造Map</h2>
<h2 id="spring自动注入的注解">spring自动注入的注解</h2>
<blockquote>
<p><span class="citation" data-cites="Component">@Component</span>("name")将一个类生成一个Bean实例并用spring管理。<span class="citation" data-cites="Controller">@Controller</span>、<span class="citation" data-cites="Repository">@Repository</span>、<span class="citation" data-cites="Service都是类似的功能">@Service都是类似的功能</span>。这些注解要放在类上。</p>
<p><span class="citation" data-cites="Bean">@Bean</span>("name")将一个方法返回的对象实例用spring管理。该注解放在方法上。</p>
<p><span class="citation" data-cites="Autowired">@Autowired</span> 自动注入。该注解可以放在构造器方法、方法、参数、属性、注解上。</p>
<p><span class="citation" data-cites="Primary">@Primary</span> 写在类上或方法上。为了消除自动装配的歧义性，如spring管理了两个都实现了同一父类的类，则存在@Primary 的类会被最先调用。</p>
<p><span class="citation" data-cites="Qualifier">@Qualifier</span>("name")写在变量、方法、参数、类上、注解上，可以根据传入的name按名字查找spring管理的类。</p>
</blockquote>
<h2 id="spring监听器">Spring监听器</h2>
<blockquote>
<p>使用过程:</p>
<p>​ 自定义事件，继承org.springframework.context.ApplicationEvent类。</p>
<p>​ 自定义事件监听器，实现org.springframework.context.ApplicationListener接口。</p>
<p>​ 在spring容器中发布事件。</p>
<p>实现监听的方式：</p>
<p>​ 自定义类实现ApplicationListener，在主函数中装载监听。</p>
<p>​ 自定义类实现ApplicationListener，在接口上加上@Component注解</p>
<p>​ 自定义类不实现接口，在对应方法上标明@EventListener注解。</p>
<p>​ 自定义类实现ApplicationListener，在application.properties中配置context.listener.classes</p>
</blockquote>
<h2 id="spring内置容器的配置">Spring内置容器的配置</h2>
<blockquote>
<p>修改配置：</p>
<ol type="1">
<li><p>可以在application.properties中按server.xxx:的方式修改</p></li>
<li><p>创建一个配置类通过编写public WebServerFactoryCustomizer<ConfigurableWebServerFactory> customizer()方法来设置。</ConfigurableWebServerFactory></p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/内嵌服务器配置修改.png" alt="内嵌服务器配置修改"><figcaption aria-hidden="true">内嵌服务器配置修改</figcaption>
</figure></li>
</ol>
<p>更换容器：</p>
<p>​ 通过先将start内的容器依赖去除然后导入新依赖即可。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/修改内嵌容器.png" alt="修改内嵌容器"><figcaption aria-hidden="true">修改内嵌容器</figcaption>
</figure>
</blockquote>
<h2 id="过滤器和拦截器">过滤器和拦截器</h2>
<blockquote>
<p>过滤器：在进入servlet前过滤。</p>
<p>实现方式：</p>
<p>​ 创建类实现接口javax.servlet.Filter，加上@Component，然后使用一个如下的配置类注入spring容器。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/filterConfig.png" alt="filterConfig"><figcaption aria-hidden="true">filterConfig</figcaption>
</figure>
<p>​ 创建类实现接口javax.servlet.Filter，加上@WebFilter，然后在主启动类中加上@ServletComponentScan注解。</p>
<p>拦截器：拦截方法。</p>
<p>​ 创建类实现HandlerInterceptor接口，然后创建配置类实现WebMvcConfigurer接口，配置类如下。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/interceptorConfig.png" alt="interceptorConfig"><figcaption aria-hidden="true">interceptorConfig</figcaption>
</figure>
</blockquote>
<h2 id="错误及异常处理">错误及异常处理</h2>
<h3 id="数值校验">数值校验</h3>
<blockquote>
<p>在参数前加入@Valid/<span class="citation" data-cites="Validated注解">@Validated注解</span>，然后跟上BindingResult对象即可获取错误时的错误信息。如图</p>
<p>利用配置文件ValidationMessages.properties中设置发生错误的提示信息。在bean的注解属性中通过{key}获取属性。</p>
</blockquote>
<h3 id="错误页指定">错误页指定</h3>
<blockquote>
<p>用到了再查</p>
</blockquote>
<h3 id="全局异常处理">全局异常处理</h3>
<blockquote>
<p>实现一个异常处理类并加上@ControllerAdvice注解。如图</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/全局异常处理.png" alt="全局异常处理"><figcaption aria-hidden="true">全局异常处理</figcaption>
</figure>
</blockquote>
<h2 id="日志">日志</h2>
<h3 id="日志文件输出">日志文件输出</h3>
<blockquote>
<p>在application中添加logging.file.path = xxx 默认日志名为spring.log</p>
<p>或添加logging.file.name = xxxx 默认输出路径为项目当前路径。</p>
<p>二者不能同时使用。</p>
</blockquote>
<h3 id="日志级别控制">日志级别控制</h3>
<blockquote>
<p>日志级别有TRACE、DEBUG、INFO、WARN、ERROR、FATAL、OFF。</p>
<p>logging.level.包名 = xxx级别</p>
<p>logging.level.root = 设置全局日志级别</p>
</blockquote>
<h2 id="文档生成">文档生成</h2>
<h3 id="swaggle">swaggle</h3>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">		</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).select()</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问http://localhost:8080/v2/api-docs拿到api的json</p>
<p>访问http://localhost:8080/swagger-ui.html获取页面</p>
</blockquote>
<h2 id="监控">监控</h2>
<blockquote>
<p>本质上是通过log收集信息，然后利用信息分析。</p>
</blockquote>
<h2 id="缓存">缓存</h2>
<blockquote>
<p><span class="citation" data-cites="Cacheable">@Cacheable</span>(value = "xx", key = "zz", condition = "yyy")</p>
<p>​ value 表示缓存名</p>
<p>​ key为缓存键，需要用SPEL写</p>
<p>​ condition为缓存触发的条件，需要用SPEL写</p>
<p>​ 缓存值为对应方法的返回值</p>
<p><span class="citation" data-cites="CacheEvict">@CacheEvict</span>(beforeInvocation = true表示在方法触发前就移除了缓存) 移除缓存</p>
<p><span class="citation" data-cites="CachePut">@CachePut</span> 添加缓存</p>
</blockquote>
<h2 id="微服务">微服务</h2>
<blockquote>
<p>注册中心</p>
<p>服务提供者</p>
<p>服务追踪</p>
<p>服务治理</p>
</blockquote>
]]></content>
      <categories>
        <category>框架入门</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>http基本知识及改进</title>
    <url>/2021/02/20/codeAnalyse/http%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%8F%8A%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<h1 id="http基本知识及改进">http基本知识及改进</h1>
<h2 id="http介绍">HTTP介绍</h2>
<h3 id="版本">0.9版本</h3>
<blockquote>
<p>GET /index.html</p>
<p>服务端只能返回html格式，传输过程只能处理文字</p>
</blockquote>
<h3 id="版本-1">1.0版本</h3>
<blockquote>
<p>支持任何格式的内容，包括图像、视频、二进制等。</p>
<p>引入了POST命令、HEAD命令。</p>
<p>增加了请求头、状态码，以及权限缓存等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 请求包</span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent:Mozilla/1.0</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line"># 应答包</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 12345</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Content-Type表示当前数据格式：text/html、image/png、application/pdf、video/mp4。</p>
<p>前面是一级格式，后面是二级类型，用斜杆分隔，还可以增加其他参数，如编码格式</p>
<p>Content-Type：text/plain；charset=utf-8</p>
<p>Content-Encoding表示数据压缩的方式：gzip、compress、deflate。</p>
<p>对应客户端的字段为Accept-Encoding，代表接收哪些压缩方式。</p>
<h4 id="缺点和问题">缺点和问题：</h4>
<p>每个TCP连接只能发送一个请求，发送完毕连接关闭，使用成本很高，性能较差。</p>
<p>Connection：keep-alive (非标准字段)</p>
</blockquote>
<h2 id="版本-2">1.1版本</h2>
<blockquote>
<p>持久连接：默认不关闭TCP连接，可以被多个请求复用。</p>
<p>管道机制：支持客户端发送多个请求，管理请求的顺序。服务器还是按照接受请求的顺序，返回对应的响应结果。</p>
<p>Content-Length：用于区分数据包的字段。</p>
<p>支持了DELETE、PUT、PATCH等命令。</p>
<h4 id="缺点和问题-1">缺点和问题</h4>
<p>当部分请求耗时较长时，仍会阻塞后续请求的处理速度，这种现象叫做“队头阻塞/线头阻塞”。</p>
</blockquote>
<h3 id="版本-3">2.0版本</h3>
<blockquote>
<p>解决了队头阻塞的问题。多路复用。</p>
</blockquote>
<h2 id="http的缺陷">HTTP的缺陷</h2>
<blockquote>
<p>通信只能由客户端发起，需要一种服务端能够主动推送的能力-websocket。</p>
<p>这种双向通信的能力，也叫"全双工"，协议标识符：http://127.0.0.1/ 变为 ws://127.0.0.1/ 通信的最小单位是帧frame。</p>
</blockquote>
<h2 id="websocket">WebSocket</h2>
<blockquote>
<p>websocket是由浏览器发起的。</p>
<p>响应码101代表本次协议需要更改为websocket。</p>
<p>建立连接后，支持文本信息和二进制信息。</p>
<p>Websocket实现的原理：</p>
<p>​ 通过http协议进行连接的建立，建立连接后不再使用http，而tcp自身是支持双向通信的，所以可以达到全双工的效果。</p>
<p>通信使用的单位叫帧frame</p>
<p>客户端：发送时，将消息切割成多个帧。</p>
<p>服务端：接收时，将关联的帧重新组装。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful基本使用</title>
    <url>/2021/02/20/designPattern/Restful%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="restful风格">Restful风格</h1>
<blockquote>
<p>本质上就是将接口的功能让http的语义来表示。</p>
<p>查询-&gt;GET</p>
<p>新增-&gt;POST</p>
<p>更新-&gt;PUT</p>
<p>删除-&gt;DELETE</p>
<p>本质上要做到，看url知道要什么，看http method知道要做什么，看http status code知道哪里有问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
        <category>代码风格</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/2021/02/20/codeAnalyse/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="数据库连接池">数据库连接池</h1>
<h2 id="常用数据库连接池">常用数据库连接池</h2>
<h3 id="dbcp">DBCP</h3>
<h4 id="常用参数">常用参数</h4>
<blockquote>
<p>initialSize 初始连接数</p>
<p>maxActive 最多可容纳活跃连接数</p>
<p>maxIdle 最大空闲连接数(已创建但未被使用的连接，会被定期回收，回收直到maxIdle数量)</p>
<p>minIdle 最小空闲连接数</p>
<p>maxWait 获取连接的最大等待时间</p>
</blockquote>
<h3 id="c3p0">C3P0</h3>
<h4 id="常用参数-1">常用参数</h4>
<blockquote>
<p>initialPoolSize 初始连接数</p>
<p>maxPoolSize 最大连接数</p>
<p>minPoolSize 最小连接数</p>
<p>acquireIncrement 当没有空闲连接时，一次性创建新连接的数量</p>
<p>maxIdleTime 连接的最大空闲时间，即若一直未使用则自动断掉连接。</p>
</blockquote>
<h3 id="druid">Druid</h3>
<h4 id="常用参数-2">常用参数</h4>
<blockquote>
<p>initialSize 初始连接数</p>
<p>maxActive 最多可容纳活跃连接数</p>
<p>maxIdle 最大空闲连接数(已创建但未被使用的连接，会被定期回收，回收直到maxIdle数量)</p>
<p>minIdle 最小空闲连接数</p>
<p>maxWait 获取连接的最大等待时间</p>
<p>timeBetweenEvictionRunsMillis 间隔多长时间检测是否关闭空闲连接。</p>
<p>minEvictableIdleTime 控制一个连接在资源池中最小的生存时间</p>
<p>maxEvictableIdleTime 控制一个连接在资源池中最大的生存时间</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>常用设计模式介绍</title>
    <url>/2021/02/20/designPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式">设计模式</h1>
<h2 id="策略模式">策略模式</h2>
<blockquote>
<p>将行为抽象，通过子类实现不同的行为来将某个对象的行为从父类抽取出，通过组合的方式来消除耦合。</p>
</blockquote>
<h2 id="命令模式">命令模式</h2>
<blockquote>
<p>也是将行为抽象，但是目的是将行为和行为执行者二者解耦，通过将行为和行为执行者组合的方式，加上控制器控制，来便于拓展。</p>
</blockquote>
<h2 id="工厂模式">工厂模式</h2>
<blockquote>
<p>简单工厂即在类中直接添加工厂对象，在工厂对象中直接创建实例。</p>
<p>工厂模式：将工厂的创建实例方法抽象化，通过子类继承并重写对应方法的方式完成。</p>
<p>抽象工厂模式：将一系列创建实例的方法抽象化，形成接口，子类实现该接口，有点类似工厂模式。</p>
</blockquote>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<p>即让一个类只能有一个对象实例。</p>
<p>double check方式实现比较好。</p>
<figure>
<img src="/2021/02/20/designPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/单例模式.png" alt="单例模式"><figcaption aria-hidden="true">单例模式</figcaption>
</figure>
</blockquote>
<h2 id="装饰者模式">装饰者模式</h2>
<blockquote>
<p>子类继承分类时，不是将父类的方法直接重写，而是在父类方法的基础上添加自己的功能。</p>
</blockquote>
<h2 id="观察者模式">观察者模式</h2>
<blockquote>
<p>分为主题(observable)和观察者(observer)两个模块，根主题是一种接口/类，提供添加观察者、移除观察者、通知观察者等方法，观察者则需要实现一个接口表示它为观察者，通常要实现update方法。主题的数据改变时可以通知观察者，数据可以有主题直接推送给观察者和观察者向主题拉取数据两个方式。</p>
</blockquote>
<h2 id="适配器模式">适配器模式</h2>
<blockquote>
<p>将一个类的接口转换成另一个接口，让本来不兼容的类可以合作无间。</p>
</blockquote>
<h2 id="外观模式">外观模式</h2>
<blockquote>
<p>将多个接口简化为一个接口</p>
</blockquote>
<h2 id="模板方法模式">模板方法模式</h2>
<blockquote>
<p>将算法分抽象为许多步骤，将统一的流程由父类实现，子类实现具体的不同部分。</p>
</blockquote>
<h2 id="迭代器模式">迭代器模式</h2>
<blockquote>
<p>给不同集合一种相同的遍历方法。</p>
</blockquote>
<h2 id="组合模式">组合模式</h2>
<blockquote>
<p>通过一致的方式处理个别对象及对象的组合，如对树和树的叶子节点采用统一的抽象方式。</p>
</blockquote>
<h2 id="状态模式">状态模式</h2>
<blockquote>
<p>状态机，将状态进行抽象，具体的状态类则实现自己具体的行为，状态类自己控制状态的转化。</p>
</blockquote>
<h2 id="代理模式">代理模式</h2>
<blockquote>
<p>给客户一个某种对象的代理，该代理对象控制对原对象的引用，目的是控制客户对对象的访问。</p>
<p>动态代理、静态代理、远程代理等。</p>
<p>静态代理</p>
<p>动态代理：JDK代理和cglib代理。JDK代理需要被代理类实现接口，而cglib没有这个限制</p>
</blockquote>
<h2 id="mvc">MVC</h2>
<blockquote>
<p>模型、视图、控制器。</p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O及Netty分析</title>
    <url>/2021/02/20/codeAnalyse/Netty/</url>
    <content><![CDATA[<h1 id="netty">Netty</h1>
<h2 id="io基础">I/O基础</h2>
<blockquote>
<p>输入流：InputStream(字节流)和Reader(字符流)。</p>
<p>输出流：OutputStream(字节流)和Writer(字符流)。</p>
<p>字节8bit，计算机处理的最小单位，字符16bit，人处理的最小单位。</p>
<p>字节流常用于处理文件、图片、视频等二进制数据，而字符流处理文本数据。</p>
</blockquote>
<h2 id="socket基础">Socket基础</h2>
<blockquote>
<p>Socket是应用层和传输层的抽象层，是一组接口，类似设计模式的门面模式。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/Netty/socket流程.png" alt="socket流程"><figcaption aria-hidden="true">socket流程</figcaption>
</figure>
<p>ServerSocket -&gt; serverSocketChannel -&gt; NioServerSocketChannel</p>
<p>Socket -&gt; SocketChannel</p>
</blockquote>
<h2 id="nio">NIO</h2>
<blockquote>
<p>阻塞：面向CPU等待慢操作完成才切换。</p>
<p>非阻塞：面向CPU在慢操作执行时，先去做别的事，等到慢操作完成时切换。</p>
<p>NIO和BIO区别：</p>
<p>​ BIO是面向流的，NIO是面向块/缓冲区的。</p>
<p>​ 最大不同在于NIO将文件或文件中的一段区域映射到内存中，可以像访问内存一样访问文件。</p>
<p>​ BIO是阻塞型IO,NIO是非阻塞型IO,NIO使用了多路复用的技术。</p>
</blockquote>
<h3 id="nio核心">NIO核心</h3>
<blockquote>
<p>通道Channel、缓冲区buffer、选择器selector。</p>
</blockquote>
<h4 id="channel">Channel</h4>
<blockquote>
<p>FileChannel 文件管道的数据</p>
<p>Pipe.SinkChannel</p>
<p>Pipe.SourceChannel 线程间通信的管道</p>
<p>ServerSocketChannel</p>
<p>SocketChannel 用于TCP网络通信的管道</p>
<p>DatagramChannel 用于UDP网络通信的管道</p>
</blockquote>
<h4 id="buffer">Buffer</h4>
<blockquote>
<p>底层是数组，可以进行set/get操作。</p>
<p>Buffer没有构造器，通过使用XxxBuffer.allocate(int n)方法分配，创建容量为n的对象。</p>
<p>capacity总体容量大小，limit存储容量的大小，是可读写和不可读写的界限，position已读容量的大小，是已读和未读区域的界限 。</p>
<p>具体使用：</p>
<p>​ 初始化时，position=0，limit = capacity。</p>
<p>​ 调用put方法存入数据，position向后移动，代表数据处理的位置，直到存储结束。</p>
<p>​ 写完成时调用flip方法刷新，limit = position，position = 0，保证limit记录可读写区域大小，positon已读部分重置为空。</p>
<p>​ 读数据知道读完成，需要调用clear方法，position = 0， limit = capacity。</p>
</blockquote>
<h4 id="selector">Selector</h4>
<blockquote>
<p>三个元素</p>
<p>​ Selector、SelectableChannel、SelectionKey。</p>
<p>selector实例有select()方法判断当前有几个操作已经就绪，keys()可以获取当前所有的SelectableChannel，selectedKeys获取就绪的key。</p>
<p>选择器Selector和通道SelectableChannel的关系，是将通道注册进选择器中，前提是通道是可选择的。注册关系对应的是选择键SelectionKey所代表的具体操作。</p>
<p>本质上Selector是监听器，监听的是通道是否具有我们关心的操作产生。</p>
<p>Selector，被注册的通道集合，以及他们的状态。</p>
<p>SelectableChannel，是一个抽象类，提供了可被选择需要实现的API。</p>
<p>​ FileChannel就是不可选择的，Socket相关的通道都是可选择的。</p>
<p>​ 一个通道可以被注册到多个选择器上，但对于每个选择器而言，一个通道只能被注册一次。</p>
<p>SelectionKey，封装了要监听的事件，连接、接收、读、写。</p>
<p>​ 一方面，Selector关心通道要处理哪些事件。</p>
<p>​ 另一方面，当事件触发时，通道要处理哪些事件。</p>
</blockquote>
<h3 id="零拷贝">零拷贝</h3>
<blockquote>
<p>零拷贝是基于操作系统层面的优化方式。(以下基于Linux系统)</p>
<p>需求：将socket要发送的数据从磁盘中读取，然后发送。</p>
<p>CPU拷贝：在操作系统中进行的拷贝。</p>
<p>DMA拷贝：连接磁盘或网卡的硬件拷贝。</p>
<p>零拷贝即无CPU拷贝。</p>
<p>原始操作：</p>
<p>​ 磁盘-&gt;操作系统内核缓冲区-&gt;应用程序缓存buffer-&gt;socket网络缓冲区(也属于操作系统内核缓冲区)-&gt;网卡。共四次copy。</p>
<p>mmap(内存映射)操作：</p>
<p>​ 磁盘-&gt;操作系统内核缓冲区-&gt;socket网络缓冲区(也属于操作系统内核缓冲区)-&gt;网卡。三次copy。将操作系统内核缓冲区和应用程序buffer映射。</p>
<p>sendfile(linux2.1内核支持)：</p>
<p>​ 磁盘-&gt;操作系统内核缓冲区-&gt;socket网络缓冲区(也属于操作系统内核缓冲区)-&gt;网卡。三次copy。操作系统内核到socket网络缓冲区不拷贝全部数据只记录数据的位置和长度。</p>
<p>sendfile with scatter/gather copy 批量sendfile：</p>
<p>​ 从单个文件的处理，上升到多个物理地址的处理。</p>
<p>splice(拼接，在linux2.6内核支持)：</p>
<p>磁盘-&gt;操作系统内核缓冲区 (管道------&gt;) socket网络缓冲区(也属于操作系统内核缓冲区)-&gt;网卡。三次copy。操作系统内核到socket网络缓冲区通过管道连接。</p>
</blockquote>
<h3 id="nio线程模型">NIO线程模型</h3>
<blockquote>
<p>Reactor模型：事件驱动，可以处理一个或多个数据源。</p>
<p>​ Reactor：监听事件的发生，并分发给对应的handler处理，或分发给acceptor。</p>
<p>​ Acceptor：处理客户端建立连接事件，并创建handler。</p>
<p>​ handler：处理后续读写事件。</p>
<p>主从reactor模型：</p>
<p>​ 主reactor负责接收事件处理、从reactor负责读写事件处理。</p>
</blockquote>
<h3 id="netty的线程模型">Netty的线程模型</h3>
<blockquote>
<p>BossGroup(主reactor)和WorkerGroup(从reactor)-&gt; NioEventGroup</p>
</blockquote>
<h3 id="netty编解码器">Netty编解码器</h3>
<h2 id="http-handler">HTTP Handler</h2>
<blockquote>
<p>请求/响应：HttpResponseDecoder 解码器(客户端)、HttpRequestEncoder 编码器(客户端)。HttpResponseEncoder 编码器(服务端)、HttpRequestDecoder 解码器(服务端)。</p>
<p>编解码器：HttpClientCodeC：HttpResponseDecoder + HttpRequestEncoder 。HttpServerCodeC：HttpResponseEncoder + HttpRequestDecoder 。</p>
<p>压缩：HttpContentCompressor压缩，HttpContentDecompressor解压缩。</p>
<p>聚合：HttpObjectAggregator -&gt; FullHttpRequest / FullHttpResponse</p>
</blockquote>
<h2 id="遇到的问题">遇到的问题</h2>
<blockquote>
<p>使用selector监听事件时，发现当客户端断开连接时，服务端仍会收到连续的读操作。</p>
<p>原因：</p>
<p>​ selector没有检查当前读到的字符长度是否为-1,-1表示服务端断开连接，需要单独处理，让channel关闭。</p>
<p>注册写事件时收到连续写。</p>
<p>原因：</p>
<p>​ 写操作的就绪条件为底层缓冲区有空闲空间，而写缓冲区绝大部分时间都是有空闲空间的，所以当你注册写事件后，写操作一直是就绪的，选择处理线程全占用整个CPU资源。所以，只有当你确实有数据要写时再注册写操作，并在写完以后马上取消注册。</p>
</blockquote>
<h3 id="一些测试">一些测试</h3>
<blockquote>
<p>使用普通io进行文件copy速度最慢。</p>
<p>使用mmap、sendfile、nio进行文件copy速度相差不大。</p>
<p>理论上sendfile应该最快。</p>
<p>下图mmap copy(使用inChannel.map())、zero/Sendfile copy(使用inChannel.transferTo())、nio copy(使用ByteBuffer和FileChannel)均测试复制同一个文件10000次用时。</p>
<p>而最后normal copy(使用BufferedOutputStream和BufferedInputStream) 测试同一个文件2000次用时。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/Netty/文件copy测试.png" alt="文件copy测试"><figcaption aria-hidden="true">文件copy测试</figcaption>
</figure>
</blockquote>
<h2 id="bytebuf-对应-buffer">ByteBuf 对应 Buffer</h2>
<blockquote>
<p>NIO中ByteBuffer的缺点：</p>
<p>长度固定，无法动态扩容的缩容，缺乏灵活性。</p>
<p>​ 使用一个position记录读写的索引位置，在读写模式切换时需要手动调用flip方法，增加了使用的复杂度。</p>
<p>​ 功能有限，使用过程中往往需要自行封装。</p>
</blockquote>
<h3 id="分类">分类</h3>
<blockquote>
<p>按照内存的位置：分为堆内存缓冲区heap buffer、直接内存缓冲区direct buffer、复合内存缓冲区composite buffer。</p>
</blockquote>
<h4 id="heap-buffer">heap buffer</h4>
<blockquote>
<p>将数据存储到JVM的堆空间中，实际使用字节数组byte[]存放。</p>
<p>优点：数据可以快速创建和释放，并且能够直接访问内部数组。</p>
<p>缺点：在读写数据时，需要将数据复制到直接缓冲区，再进行网络传输。</p>
<p>应用场景：业务消息使用缓冲区时往往使用heap bufffer。</p>
</blockquote>
<h4 id="direct-bufffer">direct bufffer</h4>
<blockquote>
<p>不在堆中，而是使用了操作系统的本地内存。</p>
<p>优点：在使用socket进行数据传输过程中，减少一次拷贝，性能更高。</p>
<p>缺点：释放和分配的空间更昂贵，使用时需要更谨慎。</p>
<p>应用场景：通信线程使用缓冲区时往往使用direct bufffer。</p>
<p>对于内存空间分配和释放的复杂度和效率，netty通过内存池的方式来解决。</p>
<p>内存池可以循环利用ByteBuf，提供使用率。但是管理和维护较复杂。</p>
<p>Unpooled是非池化缓冲区的工具类。</p>
<p>主要区别在于，池化的内存由netty管理，非池化内存由GC回收。</p>
<p>回收方式为引用计数，规则为：当对象被调用时，引用记为+1，当对象被释放时，引用记为-1，当引用次数为0时，对象可以回收。</p>
<h3 id="弊端">弊端</h3>
<p>当对象不可达时，JVM会通过GC回收，但此时引用计数可能不为0，对象无法归还内存池，导致内存泄漏。netty只能通过对内存缓冲区进行采样来检查。</p>
</blockquote>
<h4 id="composite-buffer">composite buffer</h4>
<blockquote>
<p>将两个或多个不同内存的缓冲区合并。</p>
<p>优点可以统一进行操作</p>
<p>应用场景：在解决http包，请求头+请求体特性不同而选择不同位置存储时，可以将两者拼接使用。</p>
</blockquote>
<h3 id="工作原理">工作原理</h3>
<blockquote>
<p>和ByteBuffer不同，增加了一个指针，通过两个指针来记录读模式和写模式的索引位置。读指针叫readerIndex，写指针叫做writerIndex。</p>
<p>写入数据时，写指针移动。读取数据时读数据移动。已读部分会变为可回收区域，被回收后，读指针和写指针会移动到新的位置。</p>
<p>buf.duplicate()方法，是浅拷贝。</p>
<p>buf.copy()方法，是深拷贝。</p>
</blockquote>
<h3 id="自动扩容原理">自动扩容原理</h3>
<blockquote>
<p>当写数据时，先判断是否需要扩容，若当前空间较小，以64为基数倍增。若当前空间较大(&gt;4M)，每次扩容增加4M。</p>
<p>具体实现位于AbstractByteBuf。ByteBuf的公共功能和属性都在此实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = src.remaining();</span><br><span class="line">    <span class="comment">// 判断是否可写入</span></span><br><span class="line">    ensureWritable0(length);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    setBytes(writerIndex, src);</span><br><span class="line">    writerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetCapacity = writerIndex + minWritableBytes;</span><br><span class="line">    <span class="comment">// 容量足够无须扩容</span></span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &lt;= capacity()) &#123;</span><br><span class="line">        <span class="comment">// 判断是否可达，利用了引用计数</span></span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//目标容量超过最大容量抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; targetCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取可写空间大小</span></span><br><span class="line">    <span class="comment">// Normalize the target capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fastWritable = maxFastWritableBytes();</span><br><span class="line">    <span class="comment">//若可写空间 &gt; 所需空间，新容量 = 写操作索引 + 可写空间大小</span></span><br><span class="line">    <span class="comment">//否则先创建一个buf，容量为calculateNewCapacity()</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable</span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新容量的值，调用本地的copy方法来将旧数组复制到新数组中。</span></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALCULATE_THRESHOLD = <span class="number">1048576</span> * <span class="number">4</span>; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    checkPositiveOrZero(minNewCapacity, <span class="string">&quot;minNewCapacity&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">&quot;minNewCapacity: %d (expected: not greater than maxCapacity(%d)&quot;</span>,</span><br><span class="line">                minNewCapacity, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阈值为4MB</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity == threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span> threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">    <span class="comment">// 超过阈值时每次扩容4MB</span></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">            newCapacity = maxCapacity;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newCapacity += threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">    <span class="comment">// 若小于阈值从64开始翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">        newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优点">优点</h3>
</blockquote>
<blockquote>
<p>池化的方式提高了内存的使用率。</p>
<p>提出了复合型缓冲区的整合方案。</p>
<p>增加了读写指针，使读写分离。</p>
<p>解决了ByteBuffer长度固定的问题。</p>
<p>使用引用计数的方式进行对象回收。</p>
</blockquote>
<h2 id="channel-1">Channel</h2>
<blockquote>
<p>Channel是通讯的载体，对应通讯的一端，在BIO中对应Socket，Nio中对应SocketChannel。Netty对应NioSocketChannel。</p>
<p>channelHandler是通道的处理器，一个channel往往有多个handler。</p>
<p>channelpipeline是handler的容器，装载并管理hanlder的顺序(本质双向链表)。</p>
<p>一个Channel对应一个channelpipeline，一个channelpipeline对应一个或多个channelHandler。</p>
</blockquote>
<h3 id="流程">流程</h3>
<blockquote>
<p>channel创建时，会对应创建一个channelPipeline，pipeline首先会记录一个头部处理器handler，当pipeline进行分发时，先分发给头部，然后依次进行，执行handler全部执行完成。</p>
<p>同时，channel创建后，会注册到EventLoop之中，EventLoop会监听事件的发生，不同事件调用handler不同的处理方法，让流程运转起来。</p>
<p>channel生命周期：</p>
<p>​ ChannelUnregistered：已创建但未被注册到监听器中。</p>
<p>​ ChannelRegistered：已注册到监听器EventLoop中。</p>
<p>​ ChannelActive：连接完成处于活跃状态，此时可以接收和发送数据。</p>
<p>​ ChannelInactive：非活跃状态，代表连接未建立或已断开。</p>
<p>channelHandler生命周期，对应三种状态，分别为：</p>
<p>​ handlerAdded：把handler添加到pipeline之中。早于ChannelRegistered</p>
<p>​ handlerRemove：从pipeline移除。晚于ChannelUnregistered</p>
<p>​ exceptionCaught：处理过程中有错误产生。</p>
</blockquote>
<h3 id="channel创建流程">Channel创建流程</h3>
<blockquote>
<p>开始时先利用ServerBootstrap来设定channel的类型，产生对应的channel工厂。然后在调用bind方法时底层会利用反射机制创建对应的channel对象。</p>
<p>bind方法主要分为两步，第一步为利用反射机制创建对应的channel对象，然后对对象进行init。第二步为注册</p>
<p>创建出对象后调用init方法，先利用ServerBootstrap给channel设置属性，然后获取channel对应的pipeline，再将ServerBootstrap设置的子通道childOptions、childAttrs拷贝给临时变量，并获取currentChildGroup、currentChildHandler最后再利用pipeline.addlast方法将ChannelInitializer传入pipeline(创建了Acceptor，起到将主reactor接收到的客户端通道传递给从reactor)。</p>
<p>init完成后，再调用register方法对channel进行注册。</p>
<p>注册流程为将eventLoop和channel绑定，然后判断当前线程是否为指定线程，若是则直接调用register0方法，否则将任务放入队列中，并启动一个新线程来执行任务。register0方法本质上是调用NIO的register方法将channel注册进selector中进行监听。</p>
<p>最后执行的任务会是NioEventLoop中的run方法，具体流程为，先判断队列中是否存在任务，若不存在任务则设置搜索策略为SELECT，调用select方法进行获取。然后对事件集合进行处理使用processSelectedKeys()方法，对具体事件处理时调用processSelectedKey()，processSelectedKey方法中便是根据事件的类型调用不同的方法(模板方法模式)，如读事件则调用read方法，调用read方法的主要逻辑为：分配一个ByteBuf，然后利用pipeline调用其内部每个handler的fireChannelRead方法，若读完成则调用pipeline中每个handler的fireChannelReadComplete，若发生异常则会调用pipeline中每个handler的fireExceptionCaught方法。</p>
</blockquote>
<h3 id="channelhandler">ChannelHandler</h3>
<blockquote>
<p>以入站和出站的角度设计的。</p>
<p>handler从一端开始，到另一端结束，以责任链的模式依次执行。</p>
<p>使用了责任链模式和适配器模式。</p>
<p>ChannelInboundHandler、ChanneOutboundHandler、ChanneDuplexHandler(包含出站、入站)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoggingHandler extends ChannelDuplexHandler </span><br><span class="line">ChannelDuplexHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandler</span><br><span class="line">ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler</span><br></pre></td></tr></table></figure>
<p>ChannelHandlerAdapter提供了额外的isSharable()方法，用来判断handler是否可以被共享到多个pipeline之中。默认不共享，若需要启用，则要在对应的继承了适配器的handler上增加注解@Sharable</p>
<p>继承ChannelInboundHandlerAdapter实现handler时最重要的方法是channelRead()，在使用时需要显式的释放ByteBuf相关的内存。使用ReferenceCountUtil工具类。</p>
<p>继承SimpleChannelInboundHandler实现handler时，使用其channelRead0()方法可以自动释放资源，使用更加便利。</p>
</blockquote>
<h3 id="channelpipeline">ChannelPipeline</h3>
<blockquote>
<p>pipeline维护入站和出站链路的执行顺序。</p>
<p>handler只负责处理自身的业务逻辑，对通道而言，它是无状态的。通道的信息会保存到handlerContext处理器上下文中。</p>
<p>pipeline管理的是由handlerContext包裹的handler，也就是说当添加handler时，先将其转为handlerContext，然后添加到pipeline的双向链表中。头结点叫HeadContext，尾结点叫TailContext。</p>
<p>addLast的逻辑：本质上就是在双向链表中添加一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前handler是否是sharable的，若不是且被其他通道添加则抛出异常</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">		<span class="comment">//将handler包装成AbstractChannelHandlerContext</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">		<span class="comment">//将newCtx添加到链表尾部</span></span><br><span class="line">        <span class="comment">//构造器会提前创建头尾节点</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span></span><br><span class="line">        <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">        <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            <span class="comment">//添加一个任务，当通道被注册后，能够回调handlerAdded方法</span></span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//若已被注册则执行调用handlerAdded方法</span></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用pipeline模式的优点：</p>
<p>解耦，让处理器逻辑独立，可以被多个channel共享。</p>
<p>channel相关信息由context维护。</p>
<p>使用处理器具有极大的灵活性，可以方便的添加或删除，或更改顺序。</p>
</blockquote>
<h2 id="eventloop对应selector">EventLoop对应Selector</h2>
<blockquote>
<p>事件循环。封装了reactor模型。监听IO事件，内部封装了线程。</p>
<p>当新建channel时，group会为其分配一个EventLoop，封装了nio中的Selector，监听通道中的所有事件，一个通道的生命周期中，所有操作都由相同的EventLoopGroup所封装的线程处理。同时多个通道可以由一个EventLoopGroup处理。</p>
</blockquote>
<h3 id="eventloopgroup">EventLoopGroup</h3>
<blockquote>
<p>初始化时，会调用默认构造器，然后调用到EventLoopGroup的父类MultithreadEventLoopGroup的构造方法设置线程数为NettyRuntime.availableProcessors() * 2和1中更大的值。最后调用MultithreadEventExecutorGroup构造方法创建。</p>
<p>具体流程为：判断线程数是否小于0，小于0则抛出异常。若executor为空，创建默认executor。然后按照线程数创建对应数量的EventExecutor。若某个EventExecutor创建异常则全部关闭。其中具体的EventExecutor创建过程则调用子类的newChild方法实现。(模板方法)然后根据创建的EventExecutor数量选择对应的选择器chooser，本质上是按数量是否为2的次幂选择的。再给每个EventExecutor设置线程终止的监听器，然后将产生的EventExecutor放入集合中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="eventloop">EventLoop</h3>
</blockquote>
<blockquote>
<p>重要属性Selector 及其父类的父类属性Thread</p>
<p>Thread用于轮询，在channel注册之后启动线程。</p>
<p>轮询的流程为：查询I/O事件是否就绪 -&gt; 处理就绪事件 -&gt; 处理SelectionKey -&gt; 分发结果</p>
</blockquote>
<h2 id="bootstrap启动流程">Bootstrap启动流程</h2>
<blockquote>
<p>bootstrap：引导，对应用程序进行配置，并让他运行。</p>
</blockquote>
<h2 id="future和promise">Future和Promise</h2>
<blockquote>
<p>Future表示一个可能还没有实际完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后做出对应操作。</p>
<p>Future接口就是用于封装异步操作的执行状态的，在执行异步操作时可以立马返回一个Future，Future可以通过Sync方法来等待执行结果。可以通过future.addListener()的方式来在之前的异步操作完成时执行新操作。</p>
<p>Future代表的是一个还没有完成的异步任务的执行结果，可以通过addListener方法，监听执行结果后进行相应的处理，此时它的状态可以分为未完成、已完成(成功、失败、主动取消)等，对Future而言，状态只能读取，无法更改，又出现了Promise，但是Promise只能更改一次。</p>
</blockquote>
<h2 id="心跳检测的实现">心跳检测的实现</h2>
<blockquote>
<p>检测逻辑：</p>
<p>​ 服务端启动，客户端建立连接，连接的目的是互相发送信息。</p>
<p>​ 如果客户端在工作，服务端一定可以收到数据，如果客户端空闲，服务端会出现资源浪费。</p>
<p>​ 服务端需要一种检测机制，验证客户端的活跃状态，不活跃则关闭。</p>
<p>Netty实现的方式：IdleStateHandler提供了readerIdleTime，writerIdleTime，allIdleTime三个用于判断多长时间没有读、多长时间没有写、多长时间没有读写。</p>
<p>底层实现检测的是IdleStateEvent事件，通过管道传递给下一个handler处理，处理方法是userEventTriggered。</p>
</blockquote>
<h2 id="tcp粘包和拆包及解决方案">TCP粘包和拆包及解决方案</h2>
<blockquote>
<p>TCP是流协议，基于字节流，没有界限，只会根据TCP缓冲区的情况进行拆分，所以业务上完整的包可能被拆分为多个进行发送。</p>
<p>粘包即：两个较短的包被合成一个包发送</p>
<p>拆包即：一个较长的包被拆分成两个包发送</p>
<p>UDP则不会发生粘包和拆包，因为UDP不是基于流的，UDP是基于报文的。在UDP的首部使用16bit存储报文的长度，因此不会发生。</p>
<p>TCP发生粘包和拆包的本质原因：</p>
<p>要发送的数据先经过TCP缓冲区。</p>
<p>​ 若要发送的数据 &gt; TCP剩余的缓冲区大小，发生拆包。</p>
<p>​ 若要发送的数据 &gt; 最大报文长度，发送拆包。</p>
<p>​ 若要发送的数据 &lt;&lt; TCP剩余的缓冲区大小，发生粘包(Nagle算法，要求TCP连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组)</p>
<p>​ 若接收数据的应用层没有及时读取缓冲区数据，也会发送粘包</p>
<p>解决方案：</p>
<p>​ 设置消息长度</p>
<p>​ 设置消息的边界---分隔符</p>
<p>Netty提供的解码器，两类。</p>
<p>A 基于长度的解码器，在包头设置出数据的长度。</p>
<p>​ LengthFiledBasedFrameDecoder ---- 自定义长度的处理方式</p>
<p>​ FixedLengthFrameDecoder ---- 固定长度的处理方式</p>
<p>B 基于分隔符的解码器</p>
<p>​ DelimiterBasedFrameDecoder --- 自定义分隔符</p>
<p>​ LineBaseFrameDecoder ---- 行尾符(""或"")分隔</p>
</blockquote>
<h2 id="序列化">序列化</h2>
<blockquote>
<p>将一个对象的状态保存起来，在需要时获取。</p>
<p>主要应用于网络传输和对象持久化。</p>
<p>原生序列化(java提供的)方式的缺点：</p>
<p>​ 无法跨语言</p>
<p>​ 序列化结果很大</p>
<p>​ 序列化耗时很长，性能低。</p>
<p>常用的序列化框架：</p>
<p>​ Protobuf (Google)</p>
<p>​ Thrift (Facebook)</p>
<p>​ Json (Gson/FastJson)</p>
</blockquote>
<h2 id="nagle算法和延迟确认捎带确认可能造成的问题">Nagle算法和延迟确认/捎带确认可能造成的问题</h2>
<blockquote>
<p>当程序为写-写-读时，导致第二次写需要超时才能发出。</p>
</blockquote>
<h2 id="udp实现">UDP实现</h2>
<h3 id="原生">原生</h3>
<blockquote>
<p>使用DatagramSocket代表通信的一端。</p>
<p>使用DatagramPacket传输数据。</p>
<p>使用socket的send和receive方法来发送、接收数据。</p>
</blockquote>
<h3 id="netty实现">Netty实现</h3>
<blockquote>
<p>DatagramSocket对应NioDatagramChannel</p>
<p>DatagramPacket改为netty提供的DatagramPacket</p>
<p>无论服务端还是客户端都是用Bootstrap启动。</p>
<p>通过调用Bootstrap的localAddress指定端口号，也可以调用remoteAddress()指定连接地址。</p>
<p>自定义handler，继承SimpleChannelInboundHandler<DatagramPacket>。</DatagramPacket></p>
<p>主要逻辑仍是channelRead0方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>网络</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
</search>
