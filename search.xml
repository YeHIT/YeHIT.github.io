<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构突击</title>
    <url>/2021/03/07/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="数据结构突击">数据结构突击</h1>
<h2 id="树">树</h2>
<h3 id="二叉树">二叉树</h3>
<blockquote>
<p>即每个结点都带有左右子树的树结构</p>
</blockquote>
<h3 id="二叉搜索树">二叉搜索树</h3>
<blockquote>
<p>在二叉树的基础上需要满足任一子树，左孩子的值小于根节点值，右孩子的值大于根节点值。</p>
<p>优点：既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p>
<p>缺点：在特定情况下，如插入都是按序插入，会导致树结构退化为链表。查找效率下降。</p>
</blockquote>
<h3 id="二叉平衡树">二叉平衡树</h3>
<blockquote>
<p>特点：是高度平衡的二叉搜索树，要求左右子树高度差绝对值不超过1，且左右子树都是二叉搜索树。</p>
<p>优点：由于树高度平衡，让查找操作的时间复杂度变为O(logN)。</p>
<p>缺点：由于对树的平衡要求过高，导致每次插入和删除操作需要耗费大量资源对树进行平衡，耗费大量性能。</p>
<p>适用场景：读多写少的场景。</p>
</blockquote>
<h3 id="红黑树">红黑树</h3>
<blockquote>
<p>特点：基于二叉平衡树的优点和缺点，红黑树放宽了树的平衡条件。最终会让根到叶子节点的路径最长不超过最短的两倍。它的特点为：</p>
<p>​ 具有二叉查找树的特点。</p>
<p>​ 根节点是黑色的。</p>
<p>​ 每个叶子节点都是黑色的空节点，即叶子节点不存数据。</p>
<p>​ 任何相邻的节点不能同时为红色，即红色节点是被黑色节点隔开的。</p>
<p>​ 每个结点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点。</p>
<p>优点：红黑树对于平衡条件要求不是十分严格，让每次插入、删除操作的开销减少，且平衡条件也避免了像二叉搜索树退化成链表的情况，使得搜索操作时间复杂度是O(logN)。</p>
<p>适用场景：写频繁的场景。</p>
</blockquote>
<h3 id="b树">B树</h3>
<blockquote>
<p>是一种多路平衡查找树，为了针对磁盘等存储设备设计的。读取磁盘往往是以磁盘块为单位的，位于同一个磁盘块的数据会被一次性读出。InnoDB存储引擎中有页的概念，默认每个页大小为16KB。</p>
<p>一个m阶的B-Tree的特性：</p>
<p>​ 每个结点最多有m个孩子。</p>
<p>​ 除了根节点和叶子节点外，其他每个节点至少有Ceil(m/2)个孩子。</p>
<p>​ 若根节点不是叶子节点，则至少有2个孩子。</p>
<p>​ 所有叶子结点在同一层，且不含其他关键字信息。</p>
<p>​ 非叶子结点大致是由指针，关键字，数据组成。</p>
<p>操作：</p>
<p>​ 插入：B树的插入在<strong>叶结点</strong>，当结点空间满了，则分裂为两个相邻结点，中间关键字上移到父节点中。若父节点也满了，同样分裂并上移，直至根节点，<strong>若根节点也满了，则中间元素上移到新的根结点中，树的深度增加一层</strong>。</p>
<p>​ 删除：若没有左右孩子结点，则直接删除，否则将孩子结点中相近的结点上移到当前节点中。然后调整平衡性。</p>
<p>优点：经常访问的数据可能离根节点较低，需要的I/O查询次数少，从而效率高。</p>
<p>缺点：由于节点既存放数据又存放指针，导致每个节点可以指向的数据块数量少，从而导致树的高度高，且由于数据分布在各层，也导致查询数据的I/O次数不同，使得耗时难以估计。由于叶子之间没有联系，无法从一个叶子结点找到另一个叶子结点，故B-树难以进行范围查询。</p>
</blockquote>
<h3 id="b树-1">B+树</h3>
<blockquote>
<p>对B-树进行优化，将所有的数据都放在叶子结点，其他结点只存放关键字和孩子指针，且所有的叶子结点和相连的结点使用链表相连，便于范围查找和遍历。</p>
<p>优势：B+数在内部节点上不含数据信息，使得内部节点可以存放更多的索引信息，降低了树高，减少了I/O查询次数。且B+树的叶子结点是相连的，对树的遍历只需要一次线性遍历，而B-树需要每层递归遍历。</p>
<p>具体计算：</p>
<p>​ 以InnoDB为例，默认页大小为16KB，若主键占8B，指针占8B，一条记录占1KB大小，则每个页可以存放1K的索引信息，16条记录，若树高为一(即只有根节点和叶子节点)则可以获取的记录数为1K * 16 = 16K，树高为2则可以获取的记录为 16M，树高为3可以获取的记录为16G。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql突击</title>
    <url>/2021/03/05/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="mysql突击">Mysql突击</h1>
<h2 id="基本sql语句">基本sql语句</h2>
<h3 id="dml数据操作语言">DML(数据操作语言)</h3>
<blockquote>
<p><em>SELECT</em> 、UPDATE、DELETE、INSERT INTO</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查找记录，可以附带条件语句，和分页语句</span><br><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[LIMIT N][<span class="keyword">OFFSET</span> M]</span><br></pre></td></tr></table></figure>
<p>INSERT INTO TABLE_NAME (field1,field2,.....) VALUES(值1,值2,.....)</p>
<p>UPDATE TABLE_NAME SET COL = XXX WHERE COL = YYY 更改表数据</p>
<p>DELETE FROM TABLE_NAME WHERE COL = XXX 删去表中的行</p>
</blockquote>
<h3 id="ddl数据定义语言">DDL(数据定义语言)</h3>
<blockquote>
<p>CREATE DATABASE 数据库名：创建数据库</p>
<p>DROP DATABASE 数据库名：删除数据库</p>
<p>USE DATABASE 数据库名：选用数据库</p>
<p>ALTER DATABASE：变更数据库</p>
<p>CREATE TABLE 表名(列名 列类型，......)：创建数据库表</p>
<p>DROP TABLE;删除表</p>
<p>ALTER TABLE TABLE_NAME DROP COL：删去表格对应列。</p>
<p>ALTER TABLE TABLE_NAME ADD COL TYPE：在表格中增加对应列。</p>
<p>ALTER TABLE TABLE_NAME MODIFY COL TYPE：修改表格中对应列类型</p>
<p>ALTER TABLE TABLE_NAME CHANGE COL1 COL2 TYPE：将表格中COL1列改为COL2列，且指定为TYPE类型</p>
<p>CREATE INDEX;创建索引</p>
<p>DROP INDEX;删除索引</p>
</blockquote>
<h2 id="mysql数据类型">Mysql数据类型</h2>
<blockquote>
<p>数值类型：</p>
<p>​ TINYINT：1个byte 8位</p>
<p>​ SMALLINT：2个bytes 16位</p>
<p>​ MEDIUMINT：3个bytes 24位</p>
<p>​ INT/INTEGER：4bytes 32位</p>
<p>​ BIGINT：8bytes 64位</p>
<p>​ FLOAT：4bytes 32位 单精度浮点数</p>
<p>​ DOUBLE：8bytes 64位 双精度浮点数</p>
<p>​ DECIMAL(a,b)：a指定整数位数，b指定小数位数，适用于高精度场景。默认值10,0</p>
<p>日期和时间类型：</p>
<p>​ DATE：3bytes，格式YYYY-MM-DD，存储日期值</p>
<p>​ TIME：3bytes，格式HH:MM:SS，存储时间值</p>
<p>​ YEAR：1byte，格式YYYY，年份值</p>
<p>​ DATETIME：8bytes，格式YYYY-MM-DD HH:MM:SS，混合了日期和时间值</p>
<p>​ TIMESTAMP：4bytes，存储时间戳。比DATETIME空间效率更高，但是表示的时间范围小。</p>
<p>字符串类型：</p>
<p>​ CHAR：0~255bytes，定长字符串。适合存储很短的字符串，或者所有值都接近同一个长度，如用于存储密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于非常短的列CHAR比VARCHAR在存储空间上更有效率。</p>
<p>​ VARCHAR：0~65535bytes，变长字符串。比定长类型更节省空间因为它只使用必要的空间。VARCHAR需要一个或2个额外字节记录字符串的长度，若列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。它节省了空间但由于它是变长的，所以可能导致特殊情况。如一个行占用的空间增长，且页内没有更多的空间可以存储，在这种情况下不同的存储引擎操作不同。MyISAM会将行拆成不同片段存储，InnoDB通过分裂页来使行可以放入业内。</p>
<p>​ TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB：存储2进制数据，依次为<span class="math inline">\(2^8,2^{16},2^{24},2^{32}\)</span> B</p>
<p>​ TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT：存储文本数据，依次为<span class="math inline">\(2^8,2^{16},2^{24},2^{32}\)</span> B</p>
<p>BLOB和TEXT值太大时，InnoDB会使用专门的外部存储区域来存储，此时每个值在行内需要1~4个字节存储指针，然后在外部存储区域存储实际的值。</p>
</blockquote>
<h2 id="mysql操作符及字句">Mysql操作符及字句</h2>
<blockquote>
<p>UNION：连接两个以上的SELECT语句，将结果组合到数据集中。多个SELECT语句会删除重复的数据。</p>
<p>DISTINCT：表示该值不可重复。如SELECT DISTINCT NAME FROM TABLE_NAME;可以过滤多余的重复记录。</p>
<p>WHERE 字句：设置条件。如SELECT NAME FROM TABLE_NAME WHERE ID &gt; 0；只会查询出id&gt;0的NAME。WHERE字句的格式：WHERE 列 运算符 值。</p>
<p>​ 可以使用的运算符：=，&lt;&gt;(不等于)，&gt;，&lt;，&gt;=，&lt;=，BETWEEN(在某个范围内)，LIKE(搜索某种模式，如LIKE "A%")</p>
<p>​ LIKE支持的通配符：%代替一个或多个，_代替一个字符，[charlist]代替字符列的任意一个字符，[!charlist]或[^charlist]代替除了字符列之外的任意一个字符。</p>
<p>IN(V1,V2,....)/ IN(子查询)：在V1，V2....之中的记录。</p>
<p>AND和OR：可以基于一个及以上条件对记录进行过滤，如WHERE A AND B; 过滤出当A且B的条件满足的记录。</p>
<p>ORDER BY 列名：按xxx列排序，如 ORDER BY COL1，COL2 DESC 表示记录按COL1降序排列，若COL1相同则按COL2降序排列，或后跟ASC表示升序排列。</p>
<p>SELECT * FROM TABLE_NAME LIMIT NUMBER 返回number数量的值。</p>
<p>GROUP BY：根据一个或多个列对结果集进行分组</p>
<p>IS NULL：判断值为空</p>
<p>IS NOT NULL：判断值不为空</p>
<p>EXISTS和NOT EXISTS (sub)：判断该子句是否存在结果。</p>
<p>ANY (subquery)：对结果任一满足条件即可。如 where A &gt; ANY(SELECT * FROM TABLE);即为若A＞子查询任意记录的值即可。相当于多个OR语句</p>
<p>SOME(subquery)：和ANY一样。</p>
<p>ALL(subquery)：要求同时满足，相当于多个AND语句。</p>
<p>REGEXP ‘正则表达式’：在条件中使用正则表达式匹配。</p>
</blockquote>
<h2 id="mysql连接的使用">Mysql连接的使用</h2>
<blockquote>
<p>内连接：<strong>INNER JOIN</strong>、<strong>JOIN</strong>、<strong>CROSS JOIN</strong>。是等价的，都返回笛卡尔积。</p>
<p>外连接：<strong>LEFT JOIN</strong>、<strong>RIGHT JOIN</strong>、<strong>NATURAL JOIN</strong>，分别为左连接，右连接，自然连接。均可以省略OUTER关键字。即<strong>LEFT JOIN = LEFT OUTER JOIN</strong></p>
<p><strong>LEFT JOIN</strong>：会读取左边数据表的全部数据，即使右边表无数据</p>
<p><strong>RIGHT JOIN</strong>：会读取右边数据表的全部数据，即使左边表无数据。</p>
<p><strong>NATURAL JOIN</strong>：是对两张表中字段名和数据类型都相同的字段进行等值连接，并符合符合条件的结果。注意只能有一个列符合条件。</p>
</blockquote>
<h2 id="mysql事务">Mysql事务</h2>
<h3 id="事务的基本特性acid">事务的基本特性ACID</h3>
<blockquote>
<p>A：原子性，即一个事务的操作要么全部完成，要么全部不完成。</p>
<p>C：一致性，即在事务开始之前和之后数据库的完整性没有被破坏。所有写入的规则都必须完全符合所有预设规则。</p>
<p>I：隔离性，数据库对多个并发事务同时对其数据进行读写和修改的能力。</p>
<p>D：持久性，事务处理结束后，对数据库的修改就是永久的。</p>
</blockquote>
<h3 id="事务隔离级别">事务隔离级别</h3>
<blockquote>
<p>READ UNCOMMITTED：读未提交，即事务中的修改即使没有提交，对其他事务也是可见的。存在脏读、不可重复读、幻读的问题</p>
<p>READ COMMITED：读已提交，一个事务开始时只能看见已经提交的事物所做的修改。解决了脏读的问题。</p>
<p>REPEATABLE READ：可重复读，Mysql的默认事物隔离级别。解决了不可重复读的问题，保证了在同一个事务中多次读取同样记录的结果是一致的。解决了脏读和不可重复读的问题。</p>
<p>SERIALIZABLE：串行化。最高的隔离级别，强制事务串行处理，避免了幻读问题。</p>
<p>脏读：会读到其他事务没有提交的内容。</p>
<p>不可重复读：执行两次同样的查询可能得到不一样的结果，即其他事务修改了当前读取的记录。</p>
<p>幻读：指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB采用MVCC即多版本并发控制解决幻读的问题。</p>
</blockquote>
<h3 id="多版本并发控制mvcc">多版本并发控制MVCC</h3>
<blockquote>
<p>MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，开销更低。只在READ COMMITED和REPEATABLE READ下工作，因为READ UNCOMMITED总是读取最新的数据行。SERIALIZABLE会对所有读取的行都加锁。</p>
<p>MVCC的实现是通过保存数据在某个时间点的快照来实现的，也就是说不管需要执行多次时间，每个事务看到的数据都是一致的。根据事务开始时间的不同，不同事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>InnoDB的MVCC，是通过在每行记录后保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间，一个保存行的过期时间。储存的是系统版本号。没开启一个新的事务，系统版本号将会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用于和查询到的每行记录的版本号进行比较。</p>
</blockquote>
<h4 id="repeatable-read下mvcc的具体操作">REPEATABLE READ下MVCC的具体操作</h4>
<blockquote>
<p>SELECT：InnoDB会根据以下条件来检查记录</p>
<p>​ InnoDB只查找版本&lt;=当前事务版本的数据行，这样可以确保事务读取的行要么是事务开启前已经存在的，要么是事务自身插入或修改过的。</p>
<p>​ 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行在事务开始之前没有被删除。</p>
<p>INSEART：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除表示。</p>
<p>UPDATE：InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
</blockquote>
<h3 id="事务隔离级别的实现">事务隔离级别的实现</h3>
<blockquote>
<p>可重复读RR(Repeatable Read)：在Mysql中每条记录在更新时会同时记录一条回滚操作。记录上的最新值可以通过回滚操作得到前一个状态的值。同一条记录在系统中可以存着多个版本，即MVCC。其中回滚日志会在系统中没有比这个回滚日志更早的read-view时删除。(因此最好不要使用长事务。)</p>
</blockquote>
<h3 id="innodb上锁操作">InnoDB上锁操作</h3>
<blockquote>
<p>上锁分为隐式锁定和显式锁定。</p>
<p>InnoDB采用的是两阶段锁定协议，在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。这就是隐式锁定，InnoDB会根据隔离级别在需要时自动加锁。</p>
<p>显示锁定：</p>
<p>​ 如SELECT .... LOCK IN SHARE MODE</p>
<p>​ SELECT .... FOR UPDATE</p>
</blockquote>
<h3 id="事务日志">事务日志</h3>
<blockquote>
<p>事务日志可以提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再将该修改行为记录到持久在硬盘上的事务日志中，而不用每次将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域的顺序I/O，而非随机I/O需要在磁盘的多个地方移动磁头。事务日志持久后，内存被修改的数据在后台可以被慢慢地刷回磁盘。这是目前大多数存储引擎的实现方式，被叫作预写式日志，修改数据需要写两次磁盘。</p>
</blockquote>
<h3 id="事务基本操作">事务基本操作</h3>
<blockquote>
<p>BEGIN/START TRANSACTION：开启事务。</p>
<p>COMMIT/COMMIT WORK：提交事务。</p>
<p>ROLLBACK/ROLLBACK WORK：回滚事务。</p>
<p>SAVEPOINT IDENTIFIER：在事务中创建一个保存点。</p>
<p>RELEASE SAVEPOINT IDENTIFIER：删除一个事务的保存点，当没有指定的保存点时会抛出异常。</p>
<p>ROLLBACK TO IDENTIFIER：把事务回滚到保存点。</p>
<p>SET TRANSACTION 隔离级别：设置事务的隔离级别。READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</p>
</blockquote>
<h2 id="mysql索引">Mysql索引</h2>
<blockquote>
<p>索引可以大大提高查询速度，但会降低更新表的速度，因为更新表时Mysql不仅要保存数据还需要保存索引文件。同时索引也会占用磁盘空间的索引文件。</p>
<p>创建索引：</p>
<p>​ CREATE INDEX INDEX_NAME ON TABLE_NAME()</p>
<p>唯一索引：UNIQUE INDEX。索引值必须是唯一的，除了NULL之外。可能出现多个NULL。</p>
<p>主键索引：PRIMARY KEY。索引值必须是唯一的且不能为NULL。</p>
<p>普通索引：INDEX。索引值可以出现多次。</p>
<p>全文索引：FULLTEXT。</p>
</blockquote>
<h3 id="索引的类型">索引的类型</h3>
<h4 id="b-tree索引">B-TREE索引</h4>
<blockquote>
<p>是Mysql对索引的称呼，底层的存储引擎可能采用不同的数据结构。如InnoDB采用的是B+树实现的索引。</p>
<p>B-Tree索引的限制：</p>
<p>​ 若不是按照索引的最左列开始查找，则无法使用索引。如索引是A-B-C，查找B无法利用索引。</p>
<p>​ 不能跳过索引中的列，即若索引是A-B-C，查找A-C则只能利用索引的第一列</p>
<p>​ 若查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。如索引为A-B-C，查询操作中B使用了如LIKE ‘%’的语句，则只能索引索引的前两列。</p>
</blockquote>
<h4 id="哈希索引">哈希索引</h4>
<blockquote>
<p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。只有精确匹配索引所有列的查询才有效。对于每行数据，存储引擎会对所有的索引计算一个哈希吗。哈希索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，让哈希索引查找的速度非常快。</p>
<p>哈希索引的限制：</p>
<p>​ 哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。</p>
<p>​ 哈希索引数据不是按照索引值顺序存储的，所以无法用于排序。</p>
<p>​ 哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容计算哈希值的。如索引A-B，查询A无法使用哈希索引。</p>
<p>​ 哈希索引只支持等值比较查询，如=、IN()、&lt;=&gt;(可以判断NULL的=)，不支持任何的范围查询。</p>
<p>​ 访问哈希索引的数据非常快，除非有很多哈希冲突。出现哈希冲突时需要遍历链表里的所有行指针。</p>
<p>​ 如果哈希冲突很多的话，一些索引维护操作的代价也很高。如：删去一行需要在链表中查找到对应行才能删去。</p>
<p>InnoDB的自适应哈希索引：当InnoDB注意到某些索引值被使用得很频繁时，会在内存上基于B-Tree索引上再创建一个哈希索引，这样让B-Tree索引也有哈希索引的一些优点。</p>
<p>创建自定义哈希索引：只需要很小的索引就可以为超长的键创建索引。只需要在B-Tree的基础上创建一个伪哈希索引。使用B-Tree查找，但使用哈希值而非键本身进行索引查找。</p>
</blockquote>
<h4 id="全文索引">全文索引</h4>
<blockquote>
<p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
</blockquote>
<h4 id="聚簇索引">聚簇索引</h4>
<blockquote>
<p>聚簇索引不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>当表有聚簇索引时，它的数据行实际上放在索引的叶子页。聚簇是指数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，故一个表只能有一个聚簇索引。InnoDB是通过主键聚集数据。若没有定义主键，InnoDB会选择一个唯一的非空索引代替。若没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。</p>
<p><strong>聚簇索引的优点</strong>：</p>
<p>​ 可以把相关数据保存在一起。如实现电子邮箱时按用户ID聚集数据，这样只需要从磁盘读取少量数据页即可获取用户的全部邮件。</p>
<p>​ 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据往往比非聚簇索引中查找更快。</p>
<p>​ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>
<p><strong>聚簇索引的缺点</strong>：</p>
<p>​ 插入速度严重依赖于插入顺序。若按主键顺序插入速度最快，若不是按主键顺序插入，那加载完成后最好使用OPTIMIZE TABLE命令重新组织表。</p>
<p>​ 更新聚簇索引列的代价很高。因为会强制InnoDB将每个被更新的行移动到新位置。</p>
<p>​ 基于聚簇索引的表在插入新行，或者主键被更新需要移动时，可能存在页分裂的情况。</p>
<p>​ 聚簇索引可能导致全表扫描变慢，特别是当行比较稀疏，或由于页分裂导致数据存储不联系时。</p>
<p>​ 二级索引(非聚簇索引/辅助索引)的空间占用可能较大，因为二级索引叶子节点中包含主键列。</p>
<p>​ 二级索引访问需要两次索引查找而非一次。</p>
<p><strong>聚簇索引的使用</strong>：</p>
<p>​ <strong>最好避免随机的聚簇索引</strong>，即索引值不应该是不连续且值分布访问非常大。因为这会导致聚簇索引的插入变得完全随机。随机的聚簇索引插入不仅花费的时间更长而且索引占用的空间也更大。这既是由于主键字段长，也是由于页分裂和碎片导致的。</p>
<p><strong>采用顺序的主键值插入</strong>，由于主键的值是顺序的，InnoDB会将每一条记录存储在上一条记录的后面，当达到页的最大填充因子时下一条记录会写入新的页中，主键页会被以近似顺序的记录填满：</p>
<figure>
<img src="/2021/03/05/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/聚簇索引顺序插入.png" alt="聚簇索引顺序插入"><figcaption aria-hidden="true">聚簇索引顺序插入</figcaption>
</figure>
<p><strong>采用随机的主键值插入</strong>，由于新行的主键不一定比之前插入的大，所以InnoDB不能简单地总把新行插入到索引的最后，而要为新行寻找合适的位置，通常是已有数据的中间位置，且分配空间。这样带来了缺点：</p>
<p>​ 写入的目标页可能已经刷到磁盘上并从缓存中移除，或没有加载到缓存中，InnoDB在插入之前需要先找到并从磁盘中读取目标页到内存。这样导致了随机I/O。</p>
<p>​ 因为写入是乱序的，InnoDB需要频繁地进行页分裂操作，以便为新行分配空间。导致移动大量数据，一次插入至少修改三个页，而非一个页。</p>
<p>​ 由于频繁页分裂，页会变得稀疏且不规则，最终数据会有碎片。</p>
<p><strong>顺序主键的缺点</strong>：并发场景下，InnoDB按主键顺序插入可能造成明显争用。</p>
</blockquote>
<h4 id="覆盖索引">覆盖索引</h4>
<blockquote>
<p>为了避免回表操作，即查询到的数据是主键，还要再用主键查询一次。如果索引的叶子节点包含要查询的数据就不用进行回表操作了。而一个索引包含了所有需要查询的字段的值，我们就称之为覆盖索引。</p>
<p>覆盖索引的优点：</p>
<p>​ 索引条目通常原小于数据行大小，如果只用读取索引，Mysql就会极大地减少数据访问量。覆盖索引也会让I/O密集型应用有帮助，因为索引比数据更小，更容易放入内存中。</p>
<p>​ 索引是按照列值顺序存储的(至少在单页内如此)，所以I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O少得多。</p>
<p>​ 一些存储引擎如MyISAM在内存中只缓存索引，数据依赖操作系统缓存，导致访问数据需要进行系统调用。</p>
<p>​ 由于InnoDB采用聚簇索引，所以覆盖索引对于InnoDB表特别有用。</p>
<p>并非所有类型的索引都可以成为覆盖索引。覆盖索引必须存储索引列的值，而哈希索引、空间索引、全文索引等都不能存储索引列的值，故Mysql只能用B-Tree索引做覆盖索引。</p>
</blockquote>
<h3 id="索引的优缺点">索引的优缺点</h3>
<blockquote>
<p>优点：</p>
<p>​ 索引大大减少了服务器需要扫描的数量。</p>
<p>​ 索引可以帮助服务器避免排序和临时表。</p>
<p>​ 索引可以将随机I/O变为顺序I/O。</p>
<p>缺点：</p>
<p>​ 索引会占据额外空间，此外也降低了更新表的操作效率，因为更新表时Mysql不仅要保存数据还需要保存索引文件。</p>
</blockquote>
<h3 id="高效地使用索引">高效地使用索引</h3>
<h4 id="独立的列">独立的列</h4>
<blockquote>
<p>索引必须是独立的列。如索引为A，查询时使用 A + 1 = X，不会使用索引。即索引列不能是表达式的一部分，也不能是函数的参数。</p>
</blockquote>
<h4 id="前缀索引和索引选择性">前缀索引和索引选择性</h4>
<blockquote>
<p>有时索引很长的字符列，索引会变得大且慢，此时可以使用模拟哈希索引，也可以索引开始的部分字符，以节省索引空间，提高索引效率。</p>
<p>索引的选择性是指不重复的索引值和数据报的记录总数的比值。索引选择性越高则查询效率越高，1为最佳。</p>
<p>可以将长度较大的字符列，采用前缀索引的方式，即使用该列的前x个字符作为索引。这样可以使索引更小，更快。但是存在缺点：Mysql不能使用前缀索引进行ORDER BY和GROUP BY操作，也不能使用前缀索引进行覆盖扫描。</p>
</blockquote>
<h4 id="索引使用注意点">索引使用注意点</h4>
<blockquote>
<p>Mysql不能在索引中执行LIKE操作。Mysql5.5及更早的版本中只允许在索引中做简单的比较操作。Mysql能在索引中做最左前缀匹配的LIKE比较，但不能执行以通配符开头的LIKE查询，这种情况下Mysql只能提前数据行的值而非索引值来进行比较。</p>
</blockquote>
<h2 id="mysql结构">Mysql结构</h2>
<blockquote>
<figure>
<img src="/2021/03/05/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/Users\SmallYe\Desktop\blog\source_posts\面试突击\Mysql突击\Mysql架构.png" alt="Mysql架构"><figcaption aria-hidden="true">Mysql架构</figcaption>
</figure>
<p>最上层是连接器即客户端同Mysql连接的架构，提供连接处理、授权认证、安全等功能。</p>
<p>第二层是Mysql的服务层，包括Mysql核心服务功能：解析、分析、优化、缓存及内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。有分析器、优化器、执行器、查询缓存等组件。</p>
<p>最底层即第三层是存储引擎层，Mysql可以使用多种存储引擎如：InnoDB、MyISAM、Memory，存储引擎负责Mysql中数据的存取。</p>
</blockquote>
<h3 id="各组件功能">各组件功能</h3>
<blockquote>
<p>连接器：负责和客户端建立连接、获取权限、维持和管理连接。每个服务端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或CPU中运行。服务器会缓存线程，不需要为每个新建的连接创建或销毁线程。连接过程服务端还会对客户端进行认证，认证基于用户名、原始主机信息和密码。</p>
<p>分析器：有词法分析、语法分析两个功能。对于一个SQL语句，分析器先进行词法分析，对SQL进行拆分，识别出各个字符串代表的含义。然后进行语法分析，分析器根据定义的语法规则判断SQL是否满足Mysql语法。</p>
<p>优化器：优化器在获取分析器的结果后，通过表结构和SQL语句选择执行方案，比如：多表关联时，各个表如何进行连接；当表中有索引时，应该怎样选择索引。</p>
<p>执行器：获取到执行方案后，执行器会根据表的引擎定义，去使用引擎提供的接口。查询过程Mysql执行器内部执行步骤：</p>
<p>​ 1、调用引擎接口取这个表的第一行，判断该行是否满足WHERE字句，若满足则将这行存在结果集中，否则跳过。</p>
<p>​ 2、调用引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行。</p>
<p>​ 3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
<p>​ UPDATE操作的处理逻辑(InnoDB引擎)：</p>
<p>​ 1、Mysql Server发送更新请求到InnoDB引擎。</p>
<p>​ 2、从Buffer Pool加载对应记录的Data Page，若Buffer Pool中没有该记录，则从磁盘中读取记录。</p>
<p>​ 3、将P1存储到Undo Page中，并在Redo Log Buffer中记录Undo操作。</p>
<p>​ 4、更新P1为P1‘，并将P1’写入Dirty Page，记录变更到Redo Log Buffer(Prepare状态)。</p>
<p>​ 5、返回Mysql Server执行完成。</p>
<p>​ 6、Mysql Server 记录binlog。</p>
<p>​ 7、Mysql Server 提交commit。</p>
<p>​ 8、 Redo Log Buffer状态由Prepare 更改为Commit，并刷入磁盘。</p>
<p>​ 9、当Dirty Page过多时，启动ChechPoint机制，将脏页刷入磁盘。</p>
</blockquote>
<h2 id="存储引擎">存储引擎</h2>
<blockquote>
<p>使用SHOW TABLE STATUS可以查看表的相关信息。</p>
</blockquote>
<h3 id="innodb存储引擎">InnoDB存储引擎</h3>
<blockquote>
<p>InnoDB是Mysql的默认事物引擎。被设计用来处理大量短期事务，短期事务大部分情况是正常提交，少部分被回滚。</p>
<p>InnoDB的数据存储在表空间，表空间是InnoDB管理的黑盒，由一系列数据文件组成。</p>
<p>InnoDB采用MVCC来支持高并发，并实现了四个标准的隔离级别，默认隔离级别是REPEATABLE READ，并提供间隙锁策略来防止幻读出现。间隙锁让InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入。</p>
<p>InnoDB表是基于聚簇索引建立的。InnoDB的索引结构和Mysql的其他存储引擎存在很大不同，聚簇索引对主键查询有很高的性能，但是它的二级索引必须包含主键列，所以如果主键列很大，那么其他的所有索引都会很大。</p>
<p>InnoDB还做了许多优化，如从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，能加速插入操作的插入缓冲区等。</p>
<p>InnoDB通过一些机制和工具支持真正的热备份。</p>
</blockquote>
<h3 id="myisam">MyISAM</h3>
<blockquote>
<p>MyISAM不支持事务和行级锁，不能热备份，且崩溃后无法安全恢复。当对于只读的数据或者表比较小、可以忍受修复操作，可以使用MyISAM。</p>
<p>MyISAM的特性：</p>
<p>​ 加锁和并发：MyISAM对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但当表有读取查询时，也可以往表中插入新记录。</p>
<p>​ 修复：可以手工或自动执行检查和修复操作。但是执行表的修复可能导致数据丢失。</p>
<p>​ 索引特性：对于MyISAM表即使是BLOB和TEXT长字段，也可以基于前500个字符创建索引。也支持全文索引。</p>
<p>​ 压缩表：即使用myisampack对MyISAM进行压缩，压缩表是不能进行修改的(除非先解压缩，修改数据，再压缩)，压缩表可以减少磁盘占用，也减少磁盘I/O。</p>
</blockquote>
<h3 id="innodb和myisam的区别">InnoDB和MyISAM的区别</h3>
<h4 id="事务">事务</h4>
<blockquote>
<p>MyISAM：不支持事务。</p>
<p>InnoDB：支持事务。</p>
</blockquote>
<h4 id="外键">外键</h4>
<blockquote>
<p>MyISAM：不支持外键。</p>
<p>InnoDB：支持外键。</p>
</blockquote>
<h4 id="索引">索引</h4>
<blockquote>
<p>InnoDB使用聚簇索引和辅助(非聚簇)索引。实现方式都是B+树，但基于聚簇索引的查询，InnoDB查询的结果为具体的数据，而基于辅助索引的查询，查询的结果为对应的主键。即B+树的叶子节点是存储的数据一个是整个记录，一个是对应的主键。</p>
<p>MyISAM使用非聚簇索引。实现方式是B+树，非聚簇索引的两颗树没有什么不同，区别在于叶子节点存储的是具体数据的地址。无论是主键查询，还是基于辅助索引查询，都可以直接获取具体数据的地址。索引和数据是分离的。</p>
</blockquote>
<h4 id="锁">锁</h4>
<blockquote>
<p>InnoDB支持表、行(默认)级锁。InnoDB行锁是实现在索引上的，若访问没有命中索引，无法使用行锁，要退化为表锁。</p>
<p>MyISAM支持表级锁。</p>
</blockquote>
<h3 id="存储引擎的切换">存储引擎的切换</h3>
<blockquote>
<p>ALTER TABEL table_name ENGINE = XXXX</p>
<p>导入导出：使用mysqldump工具将数据导出到文件，然后修改文件中CREATE TABLE语句中存储引擎选项。</p>
<p>创建和查询：即先创建一个同结果的表，然后修改表存储引擎，最后使用insert into 配合select将旧数据插入到新表。</p>
</blockquote>
<h2 id="显示查询执行情况">显示查询执行情况</h2>
<blockquote>
<p>使用SHOW PROFILE</p>
<p>使用SHOW STATUS</p>
<p>使用慢查询日志。</p>
</blockquote>
<h2 id="mysql-schema设计">Mysql Schema设计</h2>
<h3 id="选择优化的数据类型">选择优化的数据类型</h3>
<blockquote>
<p>更小的通常更好：尽量使用可以存储数据的最小数据类型。</p>
<p>简单就好：如整型比字符操作代价更低。举例：使用Mysql存储日期和时间，而不是使用字符串。使用整型来存储IP地址。</p>
<p>尽量避免NULL：最好指定列为NOT NULL，除非真的需要NULL值。因为查询中包含可为NULL的列对应Mysql来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。</p>
</blockquote>
<h3 id="设计中的陷阱">设计中的陷阱</h3>
<blockquote>
<p>太多的列：</p>
<p>太多的关联：</p>
<p>全能的枚举：将没有必要设计成枚举的列设计成枚举，每次修改时都需要用到ALTER TABLE</p>
<p>不要全盘否定NULL：有时NULL会比特定的值好用，避免代码复杂。</p>
</blockquote>
<h2 id="慢查询优化">慢查询优化</h2>
<blockquote>
<p>主要分析步骤：</p>
<p>​ 1、确认应用程序是否在检索大量超过需要的数据。即可能访问了太多的行/列。</p>
<p>​ 2、确认Mysql服务器是否在分析大量超过需要的数据行。</p>
</blockquote>
<h3 id="是否向数据库请求了不需要的数据">是否向数据库请求了不需要的数据？</h3>
<blockquote>
<p>判断是否查询了不需要的记录。</p>
<p>​ 如是否存在向Mysql查询了大量记录，然后获取前面N行后关闭结果集。如果存在这种情况，可以在查询后添加LIMIT。</p>
<p>多表关联时返回全部列而非具体需要的列。</p>
<p>是否总是取出全部列？即使用SELECT *操作。</p>
<p>是否重复查询相同的数据？若存在则使用缓存机制。</p>
</blockquote>
<h3 id="mysql是否扫描额外的记录">Mysql是否扫描额外的记录？</h3>
<blockquote>
<p>Mysql开销的三个指标：响应时间、扫描行数、返回行数。</p>
<p>响应时间：包括服务时间和排队时间。服务时间指数据库处理这个查询真正花了多长时间。排队时间指服务器因为等待某些资源而没有真正执行查询的时间(如等待I/O操作，等待行锁等)。</p>
<p>查看扫描的行数和返回的行数。</p>
<p>查看扫描的行数和访问类型。</p>
<p>​ 通过EXPLAIN查看。在Mysql使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<p>​ 在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</p>
<p>​ 使用索引覆盖扫描(在Extra列出现Using index)来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在Mysql服务器层完成的，但无须回表操作。</p>
<p>​ 从数据表中返回数据，然后过滤不满足条件的记录(在Extra列出现Using Where)。这在Mysql服务器层完成，Mysql需要从数据表读出记录再过滤。</p>
<p>当发现查询需要扫描大量数据但只返回少数列时，可以尝试以下方式优化：</p>
<p>​ 使用索引覆盖扫描，把所有需要用的列都放入索引中，这样存储引擎无须回表即可返回结果。</p>
<p>​ 改变库表结构，如使用单独的汇总表。</p>
<p>​ 重新复杂的查询，让Mysql优化器可以以更优化的方式执行查询。</p>
</blockquote>
<h3 id="重构查询的方式">重构查询的方式</h3>
<blockquote>
<p><strong>将一个复杂查询拆分为多个简单查询</strong>。</p>
<p><strong>切分查询</strong>：如删除旧数据时，如果采用一个大语句删除，会一次锁住许多数据、占满事务日志、耗尽系统资源、阻塞小而重要的查询。可以选择一次删除比较少的数目，分多次删除。</p>
<p><strong>分解关联查询</strong>：即将关联查询改为对每个表进行单表查询，然后将结果在应用程序中进行关联。</p>
<p>​ 优点：让缓存的效率更高。</p>
<p>​ 将查询分解后执行单个查询可以减少锁的竞争。</p>
<p>​ 在应用层做关联可以更容易对数据库进行拆分，更容易做到高性能和可拓展。</p>
<p>​ 查询本身的效率可以有所提升。</p>
<p>​ 减少冗余记录的查询，在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复访问一部分数据。</p>
<p>​ 相当于应用中实现了哈希关联，而不是使用Mysql的嵌套循环关联。</p>
</blockquote>
<h3 id="mysql执行查询的流程">Mysql执行查询的流程</h3>
<blockquote>
<p>1、客户端发送一条查询给服务器。</p>
<p>2、服务器检查查询缓存，若命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。即解析查询语句前，若查询缓存是开启的，Mysql会优先检查这个查询是否命中缓存中的数据。该检查是通过一个对大小写敏感的哈希查找实现的。</p>
<p>3、服务器端执行SQL解析、预处理，再由优化器生成对应的执行计划。</p>
<p>4、Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询。</p>
<p>5、将结果返回给客户端。</p>
<p>即客户端先经过连接器认证 —&gt; 查询缓存 —&gt; 经过分析器 —&gt; 经过优化器 —&gt; 经过执行器 —&gt; 获得结果返回给客户端。</p>
</blockquote>
<h2 id="锁-1">锁</h2>
<h3 id="索引和锁">索引和锁</h3>
<blockquote>
<p>InnoDB只有在访问行的时候才会对其加锁，而索引可以减少InnoDB访问的次数，从而减少锁的数量。但如果索引不能过滤掉无效的行，那么InnoDB检索到数据并返回给服务器层后，Mysql才能应用Where子句，此时InnoDB已经锁住了这些行，到适当时释放。Mysql 5.1前InnoDB可以在服务端过滤掉行后释放，之前的版本，只有在事务提交后才能释放。</p>
<p>InnoDB在二级索引上使用共享锁，访问主键索引需要排它锁。</p>
</blockquote>
<h2 id="日志redo-log-和-binlog">日志redo log 和 binlog</h2>
<blockquote>
<p>redo log和binlog区别：</p>
<p>​ <strong>redo log是InnoDB特有的日志</strong>，<strong>binlog是Server层特有的日志</strong></p>
<p>​ redo log是物理日志，记录了“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，如“给ID=2这一行的C字段加1”。</p>
<p>​ redo log是循环写的，空间固定且可以被用完；binlog是可以追加写入的，即binlog文件写到一定大小后会切换到下一个，不会覆盖之前的日志。</p>
<p>Mysql在这一部分主要设计思想为先写日志再写磁盘。即WAL(Write Ahead Logging技术)。</p>
<p>redo log的使用：具体而言当存在记录需要更新时，InnoDB引擎会先把记录写入redo log里，并更新内存，此时认为更新完成了。同时InnoDB会在适当时将操作记录更新到磁盘里。但InnoDB的redo log的固定大小的，如可以配置一组4个文件，每个文件大小为1GB，则redo log一共可以记录4GB操作。然后在写入的过程中会记录当前的write_pos和checkpoint即写入的位置和需要擦除的位置。若二者重合则需要提前将记录写到磁盘。</p>
<p>redo log 和binlog是怎么配合的？<strong>两阶段提交</strong>。以更新某个行的某个字段值为1为例：</p>
<p>​ 执行器会找存储引擎去取出对应行，存储引擎会利用树查找，若该行位于内存中，则返回，否则通过磁盘读入再返回给执行器。</p>
<p>​ 执行器拿到数据将值修改后，调用存储引擎接口写入新数据。</p>
<p>​ 存储引擎将数据更新到内存中，记录该操作到<strong>redo log</strong>，此时redo log处于<strong>prepare</strong>状态。然后告知执行器可以随时提交事务。</p>
<p>​ 执行器生成操作的binlog，将binlog写入磁盘。</p>
<p>​ 执行器调用引擎的事务提交接口，引擎将redo log改为<strong>commit</strong>状态，更新完成。</p>
<p>为什么要<strong>两阶段提交</strong>？</p>
<p>​ 若先写binlog再写redo log：假设在写入binlog后，redo log写入前数据库崩溃了。此时事务没有执行结束，没有对数据进行修改，但由于binlog已经记录了导致还原时会多出一次操作。</p>
<p>​ 若先写redo log再写binlog：假设在写入redo log后，binlog写入前数据库崩溃了。此时事务结束了，数据已经被修改，但由于binlog没有记录操作，导致还原时操作被丢失了。</p>
<p>可以通过innodb_flush_log_at_trx_commit设为1，让每次事务的redo log持久化到磁盘，设置sync_binlog为1，让每次事务的binlog持久化到磁盘。</p>
</blockquote>
<h2 id="tips">Tips</h2>
<blockquote>
<p>InnoDB存储引擎处理死锁的方式是，将持有最少行级排他锁的事务进行回滚。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发突击</title>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/java%E5%B9%B6%E5%8F%91%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="java并发突击">Java并发突击</h1>
<h2 id="线程创建的方式">线程创建的方式</h2>
<blockquote>
<p>继承thread类，重写run方法</p>
<p>实现runnable接口，重写run方法。</p>
<p>实现callable接口，实现call方法</p>
</blockquote>
<h2 id="线程池">线程池</h2>
<blockquote>
<p>为什么使用线程池？</p>
<p>​ 为了避免线程的创建、销毁导致的线程开销，采用线程池管理一定数量的线程达到可复用线程的效果。</p>
<p>Executors自带的线程池</p>
<p>​ <strong>newSingleThreadExecutor</strong>：单线程线程池，这个线程池只有一个线程在工作。</p>
<p>​ <strong>newFixedThreadPool</strong>：固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池最大大小。超出的线程会在队列中等待。</p>
<p>​ <strong>newCachedThreadPool</strong>：创建一个可缓存的线程池，当线程池大小超过了处理任务所需要的线程，会回收部分空闲线程，当任务增加时此线程池可以智能添加线程来处理任务。该线程池不会对大小进行限制。</p>
<p>​ <strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池，支持定时及周期性任务。</p>
<p>​ <strong>newSingleThreadScheduled</strong>：创建一个只有一个线程的线程池，支持定时及周期性任务。</p>
<p>​ <strong>newWorkStealingPool</strong>：创建一个拥有多个任务队列的线程池。</p>
<p>自带线程池的缺点，newSingleThreadExecutor和newFixedThreadPool创建了一个长度Integer.MAX_VALUE的阻塞队列，导致任务过多堆积时耗费大量内存，产生OOM错误。newCachedThreadPool和newScheduledThreadPool创建的线程池最大线程数量为Integer.MAX_VALUE，导致可能创建了大量的线程，消耗资源，甚至造成OOM。</p>
</blockquote>
<h2 id="自定义线程池">自定义线程池</h2>
<blockquote>
<p>自己创建线程池new ThreadPoolExecutor()可以传递参数：</p>
<p>​ corePoolSize：核心线程数量，即线程池会保持的线程数</p>
<p>​ maximumPoolSize：最大线程数量，即线程池</p>
<p>​ keepAliveTime：空闲线程最大存活时间</p>
<p>​ TimeUnit：时间单位</p>
<p>​ BlockingQueue：阻塞队列</p>
<p>​ ThreadFactory：线程工厂</p>
<p>​ RejectedExecutionHandler：拒绝策略</p>
</blockquote>
<h3 id="线程池执行execute的流程">线程池执行execute的流程</h3>
<blockquote>
<p>当当前线程数少于核心线程数时会新增worker线程。</p>
<p>若任务可以成功入队，则将任务入队，同时检测当前线程池状态，若为不是RUNNING状态则将任务移出队列且执行拒绝策略。</p>
<p>若入队失败，则尝试创建新的worker，若创建失败执行拒绝策略。</p>
</blockquote>
<h3 id="线程池拒绝策略">线程池拒绝策略</h3>
<blockquote>
<p>AbortPolicy：丢弃任务并抛出异常。</p>
<p>CallerRunsPolicy：判断当前线程池是否关闭，若未关闭则直接调用线程的run方法。</p>
<p>DiscardOldestPolicy：丢弃队列最前的任务，然后重新使用线程池执行被拒绝的任务。</p>
<p>DiscardPolicy：丢弃任务，什么也不做。</p>
<p>NewThreadRunsPolicy：创建一个线程去执行被丢弃的任务。</p>
</blockquote>
<h2 id="synchronized">Synchronized</h2>
<h2 id="juc">JUC</h2>
<h3 id="reentrantlock">ReentrantLock</h3>
<blockquote>
<p>可重入锁本质上是针对一个线程的，当一个线程抢占成功锁之后，若线程内部还有进行锁操作，那么会将锁的state值增加，释放时则将该值减少，直到减少到0时又可以被重新抢占。</p>
<p>释放锁过程也是先判断逐步释放。判断当前释放锁之后锁状态是否为0，若为0则通过unpark方法唤醒队列中的后继线程。</p>
<p>java实现的锁的方式分为公平锁和非公平锁。</p>
<p>公平锁和非公平锁的队列都是基于锁内部维护的一个双向链表。</p>
<p>公平锁的公平性体现在每次重新抢占时会先判断队列中是否存在等待线程，若存在则让队列的线程先抢夺。</p>
<p>非公平锁非公平体现在每次抢占时不会判断队列中是否存在等待线程，直接进行抢占。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>redis突击</title>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/redis%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="redis突击">redis突击</h1>
<h2 id="redis为什么快">redis为什么快？</h2>
<blockquote>
<p>单线程：因为一开始的redis认为redis速度的瓶颈不在于cpu运算速度，而往往在于网络带宽和机器内存大小。使用单线程编程简单且没有线程切换的开销。</p>
<p>数据存放在内存中。</p>
<p>使用了I/O多路复用技术。</p>
</blockquote>
<h2 id="redis数据结构">redis数据结构</h2>
<blockquote>
<p>String、Hash、List、Set、SortedSet、HyperLogLog(可以用于统计网页每天的用户访问量数据)、Geo、Bitmap(可以用来记录用户的在线状态)、Stream(主要用于消息队列)</p>
</blockquote>
<h2 id="redis数据淘汰机制">redis数据淘汰机制</h2>
<blockquote>
<p>随机淘汰、ttl淘汰即淘汰即将过期的数据、LRU淘汰最近最少使用的数据。</p>
</blockquote>
<h2 id="缓存击穿缓存雪崩缓存穿透">缓存击穿、缓存雪崩、缓存穿透</h2>
<blockquote>

</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统突击</title>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="操作系统突击">操作系统突击</h1>
<h2 id="进程线程和协程">进程、线程和协程</h2>
<blockquote>
<p>进程是操作系统资源分配和调度的基本单位。每个进程有着自己的独立内存空间，不同进程之间使用进程间通信来通信。操作系统是以进程为单位分配系统资源(如CPU时间片、内存等资源)，进程是资源分配的最小单位。</p>
<p>进程间通信的方法：</p>
<p>​ 管道：一种半双工的通信方式，数据只能单向流动，且只能在具有亲缘关系的进程间调用。</p>
<p>​ 消息队列：即将消息使用链表的形式存放在内核中并由消息队列标识符标识。</p>
<p>​ 信号量：本质上是一种计数器，可以用于控制多个进程对共享资源的访问。</p>
<p>​ 共享内存：映射一段能被其他进程所访问的内存，这个共享内存由一个进程创建，但由多个进程共享。它是最快的IPC方式，针对其他进程间通信效率低而设计的。</p>
<p>​ 信号：一种事件通知机制，进程可以通过发送信号给另一个进程，另一个进程则会根据收到的信号执行对应的处理方。</p>
<p>​ socket：</p>
<p>线程是依附于进程，是<strong>操作系统调度的最小单位</strong>。</p>
<p>线程间通信的方法：</p>
<p>​ 锁机制。</p>
<p>​ 信号量机制。</p>
<p>​ 信号机制。</p>
<p>​ voliate变量。</p>
<p>协程：不被操作系统内核所管理，完全是有程序所控制。</p>
</blockquote>
<h2 id="调度算法">调度算法</h2>
<blockquote>
<p><strong>先来先服务调度算法FCFS</strong>、<strong>短作业（进程）优先调度算法SJF（非抢占）</strong>、<strong>基于时间片的轮转调度算法RR</strong>、<strong>多级反馈队列算法FB</strong></p>
</blockquote>
<h2 id="死锁的四个条件">死锁的四个条件</h2>
<blockquote>
<p><strong>互斥</strong>：某种资源一次只能运行一个进程访问。</p>
<p><strong>请求保持</strong>：一个进程占有资源，但还有资源没有满足。</p>
<p><strong>不可抢占</strong>：不可以去抢夺别人已拥有的资源。</p>
<p><strong>循环等待</strong>：存在一个进程链，每个进程都占有下一个进程所需的至少一种资源。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯面经</title>
    <url>/2021/03/04/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="腾讯面经">腾讯面经</h1>
<h2 id="腾讯云一面">腾讯云一面</h2>
<blockquote>
<p>1、自我介绍和项目介绍</p>
<p>2、我看你之前面过一次，为什么挂了，你相对上次来说有什么提高？</p>
<p>3、java内存结构及各功能</p>
<p>4、堆栈的线程安全问题</p>
<p>5、HashMap和CurrenthashMap(说了一会面试官没啥兴趣就换了个问题)</p>
<p>6、四次挥手</p>
<p>7、Java线程池</p>
<p>8、乐观锁和悲观锁</p>
<p>9、分布式锁</p>
<p>10、项目亮点</p>
<p>11、项目有没有进行压测？</p>
<p>12、说说熟悉的算法</p>
<p>13、数据库了解的情况</p>
<p>14、redis为什么快</p>
<p>15、多路复用</p>
<p>16、Netty 线程模型-reactor模型</p>
<p>17、你对微服务有什么理解？</p>
<p>18、你觉得怎么实现RPC？</p>
<p>19、自己的优缺点</p>
<p>20、反问</p>
</blockquote>
]]></content>
      <categories>
        <category>面试总结</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列突击</title>
    <url>/2021/03/03/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="消息队列突击">消息队列突击</h1>
<blockquote>
<p>常用的信息队列：rockketMQ、kafka</p>
</blockquote>
<h2 id="为什么使用消息队列">为什么使用消息队列?</h2>
<blockquote>
<p>异步：开发过程中往往会存在后一个步骤需要等待前一个流程执行的操作，如果使用正常流程开发会导致操作线性化占用大量时间。使用消息队列允许前者将自己的结果放入队列中，然后让接下来的流程自己去调用结果执行。</p>
<p>解耦：此外正常开发流程中还存在如果增加依赖者，需要手动修改代码，使用消息队列的话只需要主体将结果放入队列，依赖者自己去消费队列的信息即可，无须多余操作。</p>
<p>削峰：遇到大量并发时，如果直接访问数据库往往会导致数据库连接异常。此时选择先将请求放入消息队列中，让对应数据库系统根据自己的承载能力消费即可。</p>
</blockquote>
<h2 id="消息队列的消息可靠性">消息队列的消息可靠性</h2>
<blockquote>
<p>生产者发送消息丢失：</p>
<p>​ 一种方法是同步执行，然后等待消息发送，若发送失败则事务回滚。</p>
<p>​ 另一种是异步发送消息，设置回调函数，等待消息队列告知是否发送成功，若不成功则重新发送，失败一定次数后，考虑人工干预。</p>
<p>MQ本身丢失消息：</p>
<p>​ 定期存储。多机存储。存储时可以设置只有当n个从机都存储成功了才会告知生产者消息发送成功。</p>
<p>消费者丢失消息：</p>
<p>​ 消费者消费消息成功后给生产者发送ack信号。</p>
</blockquote>
<h2 id="消息队列不被重复消费">消息队列不被重复消费</h2>
<blockquote>
<p>本质上就是让消费操作重复执行也不影响结果，即幂等性。</p>
<p>主要看场景，如果消费需要修改数据库，那直接查看数据库中是否有这个数据若存在该数据则不执行插入。</p>
<p>若使用的是redis，则直接更新redis即可。</p>
<p>若是其他情况，往往需要维护一个全局唯一的id-消费消息的结构，或者放在redis中，消费者消费时先查询该结构，若没有查询结果则说明消息没有被消费过。</p>
</blockquote>
<h2 id="消息队列顺序消费">消息队列顺序消费</h2>
<blockquote>
<p>即生产者生成的消息需要被按序执行。</p>
<p>解决方案：消息队列中将这些需要按序执行的消息，放入一个队列中，让消费者消费时必须消费整个队列。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>自己的项目总结</title>
    <url>/2021/03/03/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="自己的项目总结">自己的项目总结</h1>
<h2 id="为什么使用protobuf">为什么使用protobuf？</h2>
<blockquote>
<p>因为protobuf兼容性好、序列化性能高、且序列化出的数据体积小，会降低网络通信的传输负担。</p>
<p>当然json的优点在于易读，且许多项目都是使用json传输的。</p>
<p>protobuf兼容性好的原因：</p>
<p>​ protobuf在编码消息时会把消息分为tag域和value域，tag域用于标注出这个value对应的类型，且protobuf解析时也是按照序号对应解析的，假如说服务端消息序号为1、2、3、4，而客户端使用的是旧消息1、2、4，此时在客户端接收到消息时客户端会发现缺失了一个3号位，此时读取tag就会获知这个是什么类型的数据，跳过对应位数解析即可。</p>
<p>protobuf序列化性能高的原因：</p>
<p>​ 主要是因为编码方式导致protobuf序列化过程中只需要进行数字的简单运算，同时protobuf还在框架层面上同编译器共同完成序列化，所以序列化速度非常快。</p>
<p>protobuf序列化出的数据体积小的原因：</p>
<p>​ protobuf采用T-L-V，即tag-length-value的编码方法来针对字符串。</p>
<p>​ protobuf采用T-V的结果来针对整数，其中tag的值会利用位运算先将序号左移3位然后或上对应的type值，减少空间占用。</p>
<p>​ 因为protobuf对于数字采用了特定的Varint编码。对于值越小的数字使用越少的字节表示。如对应int32的数字，如果数字较小，只使用了其中的8位，那么发送时也只会发送最后8位。</p>
</blockquote>
<h2 id="netty通讯时选择的是什么协议为什么选择这个协议">Netty通讯时选择的是什么协议？为什么选择这个协议？</h2>
<blockquote>
<p>选用TCP来实现的，因为认为TCP传输更加可靠。</p>
</blockquote>
<h3 id="使用tcp通讯时有没有遇到粘包问题怎么处理的">使用TCP通讯时有没有遇到粘包问题？怎么处理的？</h3>
<blockquote>
<p>粘包问题本质上是由于TCP自身是以流传输的发送传递数据的，而TCP默认又会开启Nagle算法，所谓Nagle算法就是TCP协议要求让一个连接中最多只能有一个未被确认的小分组，而对于后续的小分组采用累积最后合并发送的形式发送。这样就导致客户端分次发送的数据被服务端接收时变为连续的数据。</p>
<p>粘包问题有许多解决方案：</p>
<p>​ 规定每次发送消息只能发送固定长度的，未到固定长度的使用空白填补。</p>
<p>​ 消息利用特殊分隔符分隔，接收时利用分隔符进行拆分。</p>
<p>​ 在发送消息前在消息内容前添加消息长度字段，接收时利用长度字段进行接收。</p>
<p>我使用的是最后一种。</p>
</blockquote>
<h2 id="redis的使用">redis的使用</h2>
<h2 id="zookeeper相关">zookeeper相关</h2>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础突击</title>
    <url>/2021/03/01/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/java%E5%9F%BA%E7%A1%80%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="java基础突击">java基础突击</h1>
<h2 id="java容器">java容器</h2>
<h3 id="arrays.sort怎么排序的">Arrays.sort()怎么排序的？</h3>
<blockquote>
<p>根据排序对象分为两种：</p>
<p>​ 对于基本类型，使用DualPivotQuicksort.sort()</p>
<p>​ 对于数量小于QUICKSORT_THRESHOLD = 286的数组，再进行分类，若小于INSERTION_SORT_THRESHOLD = 47，使用leftmost再选择排序模式，模式分为插入排序和改进的插入排序。</p>
<p>​ 若大于INSERTION_SORT_THRESHOLD = 47，则使用DualPivotQuicksort双轴快排。</p>
<p>​ 而对于数量较大的，先判断数组是否为高度结构化，若不是高度结构化则使用DualPivotQuicksort，否则使用归并排序。</p>
<p>​ 对于实现了Comparable接口的类型，使用ComparableTimSort.sort()。</p>
<p>​ 对于数量小于MIN_MERGE = 32的数组，使用二分插入排序。</p>
<p>​ 对于数量大于MIN_MERGE的数组，使用timSort排序(大量优化的归并排序)。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis突击</title>
    <url>/2021/03/01/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/mybatis/</url>
    <content><![CDATA[<h1 id="mybatis突击">mybatis突击</h1>
<h2 id="和">#{}和$</h2>
<blockquote>
<p>#{} mybatis会创建PreparedStatement参数占位符，并使用占位符安全地设置参数。</p>
<p>${} mybatis不会执行转义，可以在sql插入一个不转义的字符串。</p>
<p>如果需要输入大量特殊字符，可以使用&lt;[CDATA[ ]]&gt; 标签。</p>
</blockquote>
<h2 id="常见标签">常见标签</h2>
<blockquote>
<p><resultMap>、<association>、<sql>、<sql>标签里面还有一些如<if>、<trim>之类的用于动态sql。</trim></if></sql></sql></association></resultMap></p>
</blockquote>
<h2 id="mybatis流程">Mybatis流程</h2>
<blockquote>

</blockquote>
<h2 id="dao代理">dao代理</h2>
<blockquote>
<p>mybatis使用JDK动态代理实现。mapper的方法不能重载，因为Mybatis是使用包名+类+方法名作为key去查找xml的sql执行的。</p>
<p>JDK动态代理是基于接口的代理。不实现接口的话可以使用cglig的动态代理。</p>
<p>JDK动态代理本质上就是根据接口的方法产生一个继承了Proxy类实现了需要代理接口的代理子类，该子类中存在代理接口的方法对象，而这些方法对象会在静态块利用反射进行创建，而调用执行方法时会使用this.h.ivoke调用执行，其中h即为实现动态代理时的InvactionHandler。</p>
<p>缺点：要求方法实现接口。</p>
<p>cglib动态代理是基于代理类的思想实现的。代理过程会生成一个需要被代理的类B对象。也会创建对应的方法。但是在方法invoke时cglib做了fast class的优化，jdk动态代理invoke时是使用反射的技术进行调用方法的，而cglib则会随着方法的调用产生fast class，产生了一个对应方法的具体实现，使用时利用index映射关系找到对应方法，直接执行，不需要执行反射过程。</p>
<p>缺点：不能代理final方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>网络突击</title>
    <url>/2021/03/01/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/%E7%BD%91%E7%BB%9C%E7%AA%81%E5%87%BB/</url>
    <content><![CDATA[<h1 id="网络突击">网络突击</h1>
<h2 id="http相关">Http相关</h2>
<h3 id="概述">概述</h3>
<blockquote>
<p>HTTP基于TCP/IP通信协议传递数据。</p>
<p>HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。</p>
<p>HTTP是无连接的：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。引出Keep-alive</p>
<p>HTTP是媒体独立的：只要客户端和服务器知道如何处理数据内容，任何数据都可以从HTTP发送。通过content-type指定类型。</p>
<p>HTTP是无状态的：指协议对于事务的处理没有记忆能力。意味着后续处理如果需要前面的信息必须重传。从而引出的Session。</p>
</blockquote>
<h3 id="http事务-http请求命令-响应码">Http事务 = http请求命令 + 响应码</h3>
<blockquote>
<p>http事务是http请求的最小处理单元。</p>
<p>请求报文和响应报文。</p>
</blockquote>
<h4 id="请求报文">请求报文</h4>
<blockquote>
<p>请求行+请求头+请求体</p>
<p>请求行内容为：</p>
<p>​ 请求方法 + 请求的URL地址 + Http协议版本</p>
<p>​ 请求方法有：</p>
<p>​ HTTP1.0：GET(请求指定页面信息并返回主体)、POST(向指定资源提交数据)、HEAD(请求指定页面头)</p>
<p>​ HTTP1.1：OPTIONS(允许客户端查看服务端性能)、PUT(客户端提交数据代替服务端)、DELETE(请求服务端删除指定页面)、TRACE(回显服务端收到的请求) 、CONNECT (HTTP1.1中预留给能够将连接改为管道方式的代理服务)</p>
<p>请求头内容为属性，用于让服务端获知客户端信息，以下为常见属性：</p>
<p>​ accept：告知服务端可以接受的文件格式。如application/json</p>
<p>​ accept-language：浏览器支持的语言</p>
<p>​ accept-encoding：指定浏览器可以支持的web服务器返回的内容压缩编码类型。</p>
<p>​ User-Agent：用户代理，用于查看用户是使用什么访问的。</p>
<p>​ Cookie：HTTP请求发送时会把请求域名下所有的cookie值都发给服务端。</p>
<p>​ Cache-Control：设置缓存相关。no-cache代表不接受缓存，max-age表示客户端希望接受存在时间不大于该值的资源。</p>
<p>​ connection：表示是否需要持久连接，keep-alive表示使用持久连接。http1.1默认使用。</p>
<p>​ host：指定请求的服务器的域名和端口号</p>
<p>请求体一般是用来传递参数。</p>
</blockquote>
<h4 id="响应报文">响应报文</h4>
<blockquote>
<p>响应行 + 响应头 + 响应体</p>
<p>响应行内容为：</p>
<p>​ HTTP协议版本 + 状态码及描述</p>
<p>常见状态码：</p>
<p>​ 1xx：表示服务器收到请求但需要请求者继续操作。</p>
<p>​ 2xx：成功，操作被成功接收并处理。</p>
<p>​ 3xx：重定向。</p>
<p>​ 4xx：客户端错误，请求包含语法错误或无法完成请求。</p>
<p>​ 5xx：服务器错误。</p>
<p>​ 具体：</p>
<p>​ 200 OK：处理成功</p>
<p>​ 303 See Other：重定向到另外页面</p>
<p>​ 304 Not Modified：未修改，服务端不会返回数据。让客户端访问缓存。</p>
<p>​ 400 Bad Request：客户端请求语法错误。</p>
<p>​ 403 Forbidden：禁止访问</p>
<p>​ 404 Not Found：找不到页面</p>
<p>​ 500 Internal Server Error：服务端出现内部错误。</p>
<p>​ 502 Bad Gateway：网关错误。</p>
<p>响应头：</p>
<p>​ Cache-Control：告知客户端怎么控制缓存。类似请求头。值可以为no-cache，max-age</p>
<p>​ content-encoding：压缩编码格式。</p>
<p>​ Content-Type：文件类型</p>
<p>​ Location：重定向</p>
<p>​ date：时间</p>
<p>​ set-cookie：xx=yyy；Max-Age=3600；Version=1；当中Max-Age是用于设置cookie的保存时间。</p>
<p>响应体就是服务端返回给客户端的信息，如html页面，json之类。</p>
</blockquote>
<h3 id="get和post的区别">GET和POST的区别</h3>
<blockquote>
<p>本质上除了语义不同之外没有区别，但浏览器实现时区别如下：</p>
<p>​ get可以被缓存、get请求可以被收藏为书签，post不行。</p>
<p>​ get的数据url可见，post不会。</p>
<p>​ get长度有限制、post没有</p>
<p>​ get请求刷新回退都没有影响、post数据会被重新提交</p>
</blockquote>
<h3 id="cookiesessiontoken">Cookie、Session、Token</h3>
<blockquote>
<p>本质上都是用于存储用户信息的。</p>
<p>cookie是浏览器层面储存的一种k-v结构数据，当发送请求给服务端时可以把cookie发送给服务端。但是由于cookie是存储在浏览器上的，所以cookie往往不能用来存储用户的私密数据。</p>
<p>session则是在服务端层面存储用户信息，服务端在使用session时往往会产生一个特殊的sessionId，然后将这个id交给客户端，客户端每次访问服务端时带上这个id即可。但是由于session存储在服务端，所以如果有大量用户时服务端往往会消耗大量资源来存储session，并且如果是多服务端的结构，还需要采用一定操作来保证session的存储。</p>
<p>token=header密文+payload密文+签名：本质上是将用户第一次发送的用户名+密码的信息进行签名加密然后再发还给用户，而用户浏览器则保存这个信息，在之后的访问过程每次带上这个token供服务端验证。可以防止CSRF(跨站请求伪造)攻击，即在页面中放入一些恶意链接，这些链接会指向如转账之类的功能，由于浏览器发送请求时会默认带上cookie，所以导致请求通过校验被执行。而使用token浏览器就不会默认发送，从而防止csrf攻击。验证时服务端将两个密文解密再签名同自带的签名进行比对判断是否通过认证。此外还可以对payload密文解密来判断token是否过期。</p>
</blockquote>
<h3 id="http工作流程">HTTP工作流程</h3>
<blockquote>
<p>DNS域名解析-&gt;TCP三次握手-&gt;发起HTTP请求-&gt;服务器响应HTTP请求-&gt;浏览器解析HTML并请求资源-&gt;浏览器渲染页面</p>
<p>DNS既用TCP又用UDP，使用53号端口。</p>
<p>在域名解析时使用UDP。因为解析的数据少，UDP较快。</p>
<p>而在域名服务器之间执行数据同步时会使用TCP。因为此时数据量大，TCP是可靠连接，保证数据准确性。</p>
<p>DNS域名解析流程：</p>
<p>​ 搜索浏览器自身DNS缓存-&gt;搜索操作系统自身DNS缓存-&gt;读取host文件-&gt;向本地DNS服务器发起域名解析请求。</p>
<p>​ 本地DNS先向根域名服务器-&gt;顶级域名服务器-&gt; 权限域名服务器得到结果返回。</p>
</blockquote>
<h3 id="http发展流程">HTTP发展流程</h3>
<blockquote>
<p>http0.9：只支持get，服务端只能返回html格式，参数过程只支持文字。</p>
<p>http1.0：增加了post和head，支持发送任何格式的内容，增加了请求头、状态码，权限缓存相关内容。</p>
<p>缺点：每个TCP只能发送一个请求，发送完毕连接关闭，使用成本高。队头堵塞，即请求大量资源时耗时较长的资源会影响之后的资源处理。</p>
<p>http1.1引入了Connection： keep-alive让连接持久，还加入了如put、delete、connect之类的请求方式。另外引入了管道机制，支持客户端发送多个请求，管理请求的顺序，一定程度上解决了队头堵塞。</p>
<p>缺点：keep-alive虽然可以复用部分连接，但是域名分片的情况下还是要建立多个connection。管道机制要求返回结果是按序的，即使后面的处理成功了，但返回时还是需要等待前面结果完成。协议开销大，协议头里内容过多且基本不变，增加了传输负担。</p>
<p>http2.0基于SPDY。目的是通过支持请求和响应的多路复用来减低延迟。http1.x是文本协议，而http2.0使用二进制化分帧的方式，将传输的信息分割为更小的帧，并采用二进制编码的方式，首部信息放入Header frame，Request body放入Data frame，这样会对信息进行顺序标识，使得服务器可以并行传输数据。从而实现了多路复用。</p>
<p>此外http2.0还使用了首部压缩技术，对于一条连接使用首部表来维护key-value，若增加新的key-value则加入表尾，避免每次请求都需要携带首部。此外还对首部使用了HPACK算法压缩。</p>
<p>不仅如此http2.0还支持服务器主动推送，即先请求服务器，服务器不用解析就可以直接将预先设置好的内容推送给客户端。</p>
<p>http3.0：基于QUIC协议，底层使用UDP通信。</p>
</blockquote>
<h3 id="http和https">HTTP和HTTPS</h3>
<blockquote>
<p>HTTP是超文本文件传输协议通信使用明文传输，HTTPS则是基于HTTP协议通过SSL(处于TCP/IP协议与各种应用层协议之间)或TLS(前身是SSL)提供加密处理数据、验证对方身份及数据完整性保护。</p>
<p>HTTPS的特点：</p>
<p>​ 内容加密：采用混合加密技术，中间者无法直接查看明文内容。</p>
<p>​ 验证身份：通过证书认证客户端访问的是自己的服务器。</p>
<p>​ 保护数据完整性：防止传输的内容被中间人冒充或篡改。</p>
</blockquote>
<h2 id="tcp和udp">TCP和UDP</h2>
<h3 id="tcp和udp的区别">TCP和UDP的区别</h3>
<blockquote>
<p>TCP是面向连接的，UDP是无连接的。</p>
<p>TCP消耗资源较大，UDP消耗资源较少。</p>
<p>TCP是字节流传输，UDP是数据报传输。</p>
<p>TCP可靠性高，UDP不保证消息可靠性。</p>
<p>TCP可以进行流量控制，UDP不具有流量控制的能力。</p>
<p>TCP适用于对于消息准确性和顺序要求较高的场景，UDP应用于对于通信效率、准确性要求相对较低的场景。</p>
</blockquote>
<h3 id="tcp是怎么保证可靠性的">TCP是怎么保证可靠性的？</h3>
<blockquote>
<p>1、使用报文里的校验和字段。</p>
<p>2、使用了序列号机制，即每次发送报文都会附上相应的序列号，而接收到请求的那方会发送ACK对报文进行确认，同时ACK也会附带对应应答的序列号，此时发送方就可以对接收到ACK附带的序列号进行检测。若序列号正确再发送其他的报文，若错误则重发。</p>
<p>3、超时重传：即报文在发出一定时间内未收到接收方的，发送方就会重传。</p>
<p>4、三次握手和四次挥手机制。</p>
<p>5、流量控制：由于接收端处理数据的速度是有限的，为了不让过多的数据让接收端无法处理，tcp报文中有个窗口大小字段，可以让接收端在接收报文，发出ACK信号时附上该值，让发送方及时调整。</p>
<p>6、拥塞控制：流量控制是发送方接收方之间，而拥塞控制是相对整个网络通信环境的。TCP采用慢启动、拥塞避免和快启动、快重传的方式来降低网络拥塞的可能。</p>
<p>​ 快重传即收到连续三个冗余ACK，则重新发送报文段。因为TCP使用累积确认的机制，即接收端受到比期望序号大的报文，会重复发送最近一次确认的报文段的确认信号。</p>
</blockquote>
<h3 id="tcp握手与挥手">TCP握手与挥手</h3>
<h4 id="tcp三次握手">TCP三次握手</h4>
<blockquote>
<p>三次握手的流程：</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A发送SYN信号及A的初始序号x，此时A进入SYN_SEND状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">B接收到了A发送的SYN信号与A初始序号x，需要对SYN信号发送ACK应答且应答序号为x+1，同时也向A发出SYN信号和自己的序号y，然后进入SYN_RECV状态</td>
</tr>
<tr class="odd">
<td style="text-align: center;">A接收到服务端发送的SYN和ACK信号，会发送ACK信号并将序号设为y+1，然后发送给客户端，发送完毕后A进入ESTABLISHED状态，完成三次握手。</td>
<td style="text-align: center;">B收到ACK也进入ESTABLISHED状态</td>
</tr>
</tbody>
</table>
<p><strong>为什么不是四次握手，如将B的SYN信号和ACK信号拆开发送</strong>。原因：避免资源浪费。</p>
<p><strong>为什么B需要等待A的ACK信号？即为什么不是两次握手？</strong>原因：本质上为了避免旧重复连接造成资源浪费的问题，若B发出SYN和ACK信号后直接进入ESTABLISHED状态，假定A、B先前存在连接，然后断开了连接，而此时B在之后的一段时间中收到了A早期发送的SYN信号，若B直接进入ESTABLISHED状态，此时显然A是没有连接需求的，也不会向B发送数据，而B也不知道这一点，这样就会浪费掉连接资源。而使用三次握手，A、B之间存在序列号，若发生之前的情况，B会对A发出信号和自己的ACK序号，此时A收到ACK时就会发现自己当前的序列号不能和B的ACK对应，就会给B发送RESET信号，从而避免资源浪费。</p>
<p><strong>SYN攻击</strong>：即随机IP访问服务器发送大量SYN请求。</p>
</blockquote>
<h4 id="tcp四次挥手">TCP四次挥手</h4>
<blockquote>
<p>四次挥手的流程：</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A发送FIN信号及自己的序列号给B，然后进入FIN_WAIT1状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">B接收到了A发送的FIN信号会向A发送ACK，然后进入CLOSE_WAIT状态</td>
</tr>
<tr class="odd">
<td style="text-align: center;">客户端收到ACK信号进入FIN_WAIT2状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">一段时间后，服务端发送完数据，就会给客户端发送FIN报文，此时服务端进入LAST_ACK状态</td>
</tr>
<tr class="odd">
<td style="text-align: center;">当客户端接收到FIN信号时发送ACK信号给服务端，此时客户端会进入TIME_WAIT状态。若超过2MSL没有收到回复则客户端关闭连接进入CLOSED状态。</td>
<td style="text-align: center;">当服务端接收到ACK信号时会关闭连接进入CLOSED状态</td>
</tr>
</tbody>
</table>
<p><strong>为什么断开连接需要四次挥手？</strong></p>
<p>​ 因为TCP连接是全双工的，所以必须保证每个方向都单独进行关闭。当客户端想关闭自己这方的连接时，服务端可能还需要发送消息，故客户端只能先发送FIN，然后等待服务端完成了自己操作后发出FIN才完成一个连接两个方向的关闭。</p>
<p><strong>为什么客户端发送ACK信号后还需要等待2MSL长度的时间？</strong></p>
<p>​ 主要有两个原因：</p>
<p>​ 1、如果ACK信号在传输过程中丢失了，客户端可以等待服务端重新发送FIN报文，此时再发送ACK报文来保证连接被正常关闭。</p>
<p>​ 2、2MSL时间是网络TCP生存时间的两倍，设置这个时间是为了给服务器足够的超时重传时间，也让客户端可以等待网络中在之前连接中发出的包全部消失。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试突击</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C10K问题的解决及I/O多路复用</title>
    <url>/2021/02/28/netty%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/C10K%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8F%8AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="c10k问题的解决及io多路复用">C10K问题的解决及I/O多路复用</h1>
<h2 id="c10k问题">C10K问题</h2>
<blockquote>
<p>即网络通信时单机服务器保持的TCP连接数超过10K即1万，导致服务器压力过大无法承载。</p>
</blockquote>
<h2 id="发生c10k问题的原因">发生C10K问题的原因</h2>
<blockquote>
<p>本质上是操作系统的问题，操作系统使用的都是传统阻塞I/O模型，处理方式都是requests per thread，导致并发10K和并发100的关键在于CPU。</p>
</blockquote>
<h2 id="解决方法">解决方法</h2>
<blockquote>
<p>原始的TCP连接需要一个线程/进程处理一个连接。</p>
<p>改进为同一个线程/进程处理多个连接。即使用I/O多路复用技术</p>
</blockquote>
<h2 id="io多路复用技术的发展">I/O多路复用技术的发展</h2>
<h3 id="原始情况">原始情况</h3>
<blockquote>
<p>最简单的思路为利用循环挨个处理每个连接，每个连接对应一个socket，当所有socket都有数据时这个方法可行，但若某个socket没有数据会导致线程/进程被阻塞。</p>
</blockquote>
<h3 id="select">Select</h3>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数会传递readset、writeset、exceptset，即读事件、写事件、异常事件，使用fd_set来告知内核同时监控多个文件句柄，最后是timeout是时间参数，可以分为三种情况：一直等待某个描述字直到事件就绪回调、等待到某个时间若某个描述字事件不就绪则不等待、根本不等待某个描述字。</p>
<p>回调后可以通过FD_ISSET 来逐个查看fd_set中的句柄状态，当连接数大时效率较低，因此select存在句柄管理上限。</p>
<p>且fd_set只有一个字段关注事件和发生事件，使用前往往要初始化。</p>
<p>此外fd_set在调用select时需要反复在用户态和内核态传递。</p>
</blockquote>
<h3 id="poll">Poll</h3>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>本质上和select没有区别，都需要轮询，但是poll没有最大文件描述符的限制</p>
<p>pollfd存在事件字段和发生事件字段，使用前不用重复初始化。</p>
<p>此外pollfd在调用poll时需要反复在用户态和内核态传递。</p>
</blockquote>
<h3 id="epoll">Epoll</h3>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll的句柄，用于管理size个监听数目，返回一个fd值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// epoll的事件注册函数，会先注册需要监听的事件类型，epfd为epoll_create的返回值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// 等待事件的发生，只会返回需要处理的事件文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll_event在用户态和内核态的传递只需要在epoll_ctl进行一次。</p>
<p>且事件触发时只会返回触发事件的文件描述符，避免遍历全部的文件描述符。</p>
<p>有ET模式和LT模式</p>
<p>​ ET模式：边缘触发，当状态发生时才通知，每个事件仅通知一次，所以程序必须立即处理该事件。</p>
<p>​ LT模式：水平触发，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件，下次调用epoll_wait时操作系统还会再次向应用程序通知此事件。</p>
</blockquote>
<h2 id="c10m">C10M</h2>
<blockquote>
<p>即并发量上升到10M，此时瓶颈变为了操作系统。</p>
<p>可能的解决方案：</p>
<p>​ 让数据报直接传递到业务逻辑，不经过linux协议栈。</p>
<p>​ 自己管理内存，如将内存预留一部分，并使用更大的内存分页进行管理。</p>
<p>​ 多线程核间绑定，将线程同处理器核心进行绑定，最大化核心Cache利用，实现无锁设计，避免线程切换开销。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>网络</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O模型及I/O线程模型</title>
    <url>/2021/02/28/JavaBasicKnowledge/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="io模型及io线程模型">I/O模型及I/O线程模型</h1>
<h2 id="io模型">I/O模型</h2>
<h3 id="阻塞型iobio">阻塞型I/O(BIO)</h3>
<blockquote>
<p>线程调用recvfrom，持续等待直到复制完成。</p>
<p>优点：程序简单</p>
<p>缺点：每个连接需要独立进程/线程，并发量大时维护程序的线程切换开销大。</p>
</blockquote>
<h3 id="非阻塞型io">非阻塞型I/O</h3>
<blockquote>
<p>线程调用recvfrom，不持续等待，而是不断轮询操作系统内核。</p>
<p>优点：不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，不用阻塞等待，实时性较好。</p>
<p>缺点：轮询占用大量CPU时间，系统资源利用率低。</p>
</blockquote>
<h3 id="io多路复用nio">I/O多路复用(NIO)</h3>
<blockquote>
<p>如select、poll、epoll，用一个描述符管理多个描述符，同时管理多个I/O操作，当有事件发生时才堵塞进行复制。</p>
<p>优点：节省大量系统资源。</p>
<p>缺点：在并发量低时延迟较多线程+堵塞I/O更高，因为I/O多路复用对单个连接需要进行两次系统调用。</p>
</blockquote>
<h3 id="信号驱动型io">信号驱动型I/O</h3>
<blockquote>
<p>使用信号来驱动，当数据准备好时进程会受到一个信号，在信号处理函数中处理数据。</p>
<p>优点：线程没有在等待数据时被阻塞，提高资源利用率。</p>
<p>缺点：信号I/O在大量I/O操作时可能会因为信号序列溢出导致无法通知。</p>
</blockquote>
<h3 id="异步ioaio">异步I/O(AIO)</h3>
<blockquote>
<p>类似于信号驱动I/O，但是AIO会在内核完成了数据复制操作后才给线程发送信号，线程无须等待。</p>
<p>优点：异步I/O充分利用DMA，让I/O操作和计算重叠。</p>
<p>缺点：AIO需要操作系统支持，目前AIO在linux中还不完善，且AIO代码编写复杂。</p>
</blockquote>
<h2 id="io线程模型">I/O线程模型</h2>
<h3 id="传统阻塞-io-服务模型">传统阻塞 I/O 服务模型</h3>
<blockquote>
<p>采用阻塞式I/O获取输入数据，每个连接都需要独立的线程完成数据输入、业务处理、数据返回的完整操作。</p>
<p>缺点：</p>
<p>​ 并发数较大时需要大量线程。</p>
<p>​ 连接后若没有数据会被阻塞在read操作上。</p>
</blockquote>
<h3 id="reactor模式">Reactor模式</h3>
<blockquote>
<p>I/O复用结合线程池</p>
<p>主要组件为Reactor、Acceptor、Handler</p>
<p>非阻塞同步网络模型。</p>
</blockquote>
<h4 id="单线程reactor">单线程reactor</h4>
<blockquote>
<p>Reactor对象通过select监控请求事件，收到事件后通过Dispatch分发。</p>
<p>若是连接事件通过Acceptor处理。然后创建一个Handler处理连接后的事件</p>
<p>若不是连接事件则交给Handler处理。</p>
<p>优点：单线程不用考虑线程切换开销。</p>
<p>缺点：只有一个线程无法完全发挥多核CPU的性能。</p>
</blockquote>
<h4 id="多线程reactor">多线程reactor</h4>
<blockquote>
<p>优化了Handler，handler只负责数据读取，然后将数据分发给worker线程处理，worker线程处理完成后将结果返回给handler。</p>
<p>优点：充分利用多核CPU处理能力</p>
<p>缺点：多线程数据共享和访问比较困难。reactor负责承担所有事件响应，容易成为瓶颈。</p>
</blockquote>
<h4 id="主从reactor模型">主从Reactor模型</h4>
<blockquote>
<p>主Reactor负责将新连接分发给Acceptor，然后将Acceptor处理后的数据分发给从reactor，从reactor负责处理其他事件，然后分发给handler处理，handler负责数据读取，而业务仍交给worker处理。</p>
<p>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</p>
</blockquote>
<h3 id="proactor模型">Proactor模型</h3>
<blockquote>
<p>proactor</p>
<p>异步网络模型。</p>
<p>组件：Proactor Initiator、Proactor 、Handler 、AsyOptProcessor</p>
<p>流程：initiator创建Proactor 、Handler ，然后Proactor 和Handler 都通过AsyOptProcessor注册到内核。</p>
<p>AsyOptProcessor处理注册请求，并处理I/O操作。</p>
<p>AsyOptProcessor完成I/O操作后会通知Proactor，Proactor根据不同的事件类型回调不同的Handler进行业务处理。</p>
<p>优点：效率较reactor模型更高。</p>
<p>缺点：编程更加复杂。</p>
<p>​ 内存使用更加困难。</p>
<p>​ 需要操作系统支持。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux介绍及基本指令</title>
    <url>/2021/02/20/Linux/Linux%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux介绍及基本指令">Linux介绍及基本指令</h1>
<h2 id="linux区别">Linux区别</h2>
<blockquote>
<p>Ubantu：分为用户版和服务器版。</p>
<p>​ 用户版，有着良好的用户界面，有强大的软件支持。</p>
<p>​ 服务器版比较少用。</p>
<p>Debian：系统十分稳定，内核非常小。</p>
<p>RedHat：是一个商用的操作系统，性能非常好，软件支持也非常好。</p>
<p>Centos：基本上相当于RedHat的复刻版本。免费。</p>
</blockquote>
<h2 id="根目录下各目录对应的功能">根目录下各目录对应的功能</h2>
<h2 id="在linux中获取帮助">在linux中获取帮助</h2>
<blockquote>
<p>man 命令名：查看命令的操作说明</p>
<p>命令行 --help：查看命令的语法</p>
</blockquote>
<h2 id="linux基本命令">Linux基本命令</h2>
<blockquote>
<p>ls：查看当前目录中所有文件及目录</p>
<p>ll：查看当前目录内所有文件及目录详细信息。详细信息具体查看方式。以drwxr-xr-x为例(第一个字符拆出，然后每三个字符表示一个内容)：</p>
<p>d：文件类型，目录。rwx：拥有者权限，可读，可写，可执行。r-x：用户组权限，可读，不可写，可执行。r-x：其他组权限，可读，不可写，可执行。</p>
<p>具体文件类型有：d：路径。<em>-</em>：文件。 l ：连接(快捷方式)。b：表示可按块随机读写的设备。c：设备文件里的串行端口设备，如键盘、设备。</p>
<p>表示权限的三个字符可以用0~7的数字表示。如rwx为7，r-x为5。</p>
<p>ls -al：查看所有文件及目录包括隐藏目录。</p>
<p>pwd：查看当前所在层级</p>
<p>echo xxx：打印xxx</p>
<p>date：查看日期</p>
<p>cal：查看日历</p>
<p>grep xxx：用于查看包含xxx的对象。</p>
<p>curl 网址：向对应网址发出http请求。curl -i www.baidu.com ：向百度首页发出请求，会返回响应头。</p>
<p>history：查看先前输入过的命令。</p>
<p>df：查看磁盘使用情况。</p>
</blockquote>
<h2 id="文件基本命令">文件基本命令</h2>
<blockquote>
<p>vi xxx：打开临时记事本，基本可以认为是创建文件。</p>
<p>mkdir xxx：创建文件夹</p>
<p>rm -rf xxx：删除目录。</p>
<p>cp a b ：把a文件复制到b处</p>
<p>mv a b ：把a文件移动到b处（也可以当做重命名使用）</p>
<p>tail -number xx：查看文件最后number行内容(可以用于监控日志使用tail -F/-f xxx)-F，-f分别为追踪文件名和追踪文件索引。</p>
<p>cat xxx：查看文件内容，往往伴随着grep使用如 cat a.txt | grep "a:xxx"。</p>
<p>less xxx：查看文件一页的内容。</p>
<p>find xxx：查找文件(可以查找所有文件)。</p>
<p>whereis xx：查找命令所在目录(只能查找二进制类的文件)。</p>
<p>which xxx：在PATH变量指定的路径中搜索指定的系统命令的位置。</p>
<p>sh xxx.sh：执行shell命令。这种执行sh文件不需要本身具有权限。</p>
<p>path/xxx.sh：执行shell命令。sh文件本身需要有权限。(如./xxx.sh其中.表示当前目录)</p>
</blockquote>
<h2 id="文件解压缩">文件解压缩</h2>
<blockquote>
<p>zip -r 压缩后路径加名字 需要压缩的文件：压缩，如zip -r a.zip a.txt。这个命令需要yum install zip</p>
<p>unzip -d 解压缩到的路径 解压缩的包：解压缩，如unzip -d . a.zip。这个命令需要yum install unzip。</p>
<p>tar -cvf 压缩后路径加名字 需要压缩的文件：压缩，如tar -cvf a.txt。</p>
<p>tar -zcvf 压缩后路径加名字 需要压缩的文件：压缩，如tar -zcvf a.txt。压缩后占的空间更少</p>
<p>tar -xvf 解压缩到的路径 解压缩的包：解压缩，如tar -xvf a.txt。</p>
<p>tar -zxvf 解压缩到的路径 解压缩的包：压缩，如tar -zxvf a.txt。</p>
<p>tar的参数：c：表示create，即压缩，z：约等于zip，即打包后空间会更小，v：压缩后展示压缩包中文件名字。f：表示结束。x：extract，即解压缩。</p>
<p>b：表示查看压缩包内容。其中c、x、b同时只能存在一个。</p>
</blockquote>
<h2 id="文件传输">文件传输</h2>
<blockquote>
<p>scp 目录加文件名 用户名@IP地址:目录加文件名：将文件传输利用网络传输到另一个服务器。如scp ./a.txt root@10.0.2.6:~/b.txt</p>
</blockquote>
<h2 id="进程管理命令">进程管理命令</h2>
<blockquote>
<p>top ：查看当前系统使用情况。</p>
<p>ps：查看进程情况。</p>
<p>ps aux：查看所有正在执行的进程。经常和grep配合使用。如ps aux | grep "top"</p>
<p>lsof -i:port ：根据端口号查看进程。需要yum install lsof</p>
<p>kill 进程号：杀死进程。</p>
<p>kill -9 进程号：强制杀死进程。</p>
<p>service xxx start：启动服务。</p>
<p>service xxxx stop：关闭服务。</p>
</blockquote>
<h2 id="权限管理命令">权限管理命令</h2>
<blockquote>
<p>chmod xxx aaa：设置aaa的权限为xxx。第一个x为拥有者权限，第二个x为用户组权限，第三个x为其他组权限。如chmod 777 a.txt：表示将a.txt的权限均设为可读、可写、可执行。</p>
</blockquote>
<h2 id="软件安装命令">软件安装命令</h2>
<blockquote>
<p>yum install xxxx：安装xxxx</p>
<p>yum install ifconfig -y：安装时自动同意。</p>
</blockquote>
<h2 id="安全相关命令">安全相关命令</h2>
<blockquote>
<p>systemctl disable firewalld ：关闭防火墙。</p>
</blockquote>
<h2 id="关机命令">关机命令</h2>
<blockquote>
<p>shutdown：关机</p>
<p>reboot：重启</p>
<p>poweroff：关机</p>
<p>halt：进入系统停止的模式，屏幕可能保留一些信息，取决于电源管理模式。</p>
<p>systemctl suspend：休眠</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot原理分析</title>
    <url>/2021/02/20/codeAnalyse/SpringBoot%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="springboot原理">SpringBoot原理</h1>
<h2 id="springbootapplication"><span class="citation" data-cites="SpringBootApplication">@SpringBootApplication</span></h2>
<blockquote>
<p>本质上是</p>
<p><span class="citation" data-cites="SpringBootConfiguration">@SpringBootConfiguration</span>：实际是@Configuration</p>
<p><span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span>：由@AutoConfigurationPackage、<span class="citation" data-cites="Import">@Import</span>({AutoConfigurationImportSelector.class})组成。</p>
<p><span class="citation" data-cites="ComponentScan">@ComponentScan</span>：启用自动扫描，默认扫描所在类的同级类和同级目录下的所有类。</p>
<p>即这个注解实现了注册配置类、启用自动配置、启用自动扫描。</p>
</blockquote>
<h2 id="springapplication.runtestapplication.classargs的实际流程">SpringApplication.run(TestApplication.class,args)的实际流程</h2>
<blockquote>
<p>利用传入的类创建一个SpringApplication实例执行了run方法。</p>
<h3 id="具体创建实例的流程">具体创建实例的流程：</h3>
</blockquote>
<blockquote>
<figure>
<img src="/2021/02/20/codeAnalyse/SpringBoot%E5%8E%9F%E7%90%86/SpringBootAplication初始化过程.png" alt="SpringBootAplication初始化过程"><figcaption aria-hidden="true">SpringBootAplication初始化过程</figcaption>
</figure>
<p>倒数第四行加载了web应用的配置，具体流程是使用默认的类加载器去查找当前是否使用了对应的类。结果可以得出NONE、SERVLET、REACTIVE。</p>
<p>倒数三行之前都是加载主配置。</p>
<p>倒数第三、二行分别是创建初始化器和监听器。创建的流程均为先获取到类加载器，然后查找当前项目中所使用到的初始化器、监听器类名，再利用类名创建类实例，最后将这些实例按优先级排序即可。</p>
<p>创建类实例的方法即为通过反射调用类的构造方法创建。它们都使用了getSpringFactoriesInstances方法。这个方法是先通过读取META-INF/spring.factories文件内容来获取配置，并将配置放入map中。实际中会读取到项目所有jar包中的META-INF/spring.factories。然后利用传入的类名进行匹配找到所需的初始化器/监听器。</p>
<p>按优先级排序，Spring则是通过继承OrderComparator(实现了Comparator接口的类来完成的)，这里利用了模板方法模式，通过完成了findOrder方法，通过比较注解的优先级的方式来findOrder，若未设定优先级则设为最低优先级LOWEST_PRECEDENCE这个值为Integer.MAX_VALUE。</p>
<ul>
<li>（1）先判断有没有实现PriorityOrdered，实现PriorityOrdered比没实现的有高优先级</li>
<li>（2）第一步如果比较不出来，判断有没有实现Ordered，如果实现了，取实现方法的int值比较</li>
<li>前两步都是OrderComparator的默认实现。</li>
<li>（3）如果没有实现Ordered，判断有没有org.springframework.core.annotation.Order注解， 有注解，取注解上的order值，进行比较</li>
<li>（4）如果没有Order注解，判断有没有javax.annotation.Priority注解，取注解上的值比较</li>
<li>若以上都没找到则spring会返回null</li>
<li>（5）OrderComparator接收到null，返回Integer.MAX_VALUE即LOWEST_PRECEDENCE，值越大优先级越低</li>
</ul>
<p>最后一行找到主程序类是通过获取当前程序运行栈，通过找到栈中执行main方法的类，得到主程序类名。</p>
</blockquote>
<h3 id="创建实例后执行run方法的流程">创建实例后执行run方法的流程</h3>
<blockquote>

</blockquote>
<h2 id="自动配置原理">自动配置原理</h2>
<blockquote>
<p><span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span> = <span class="citation" data-cites="AutoConfigurationPackage">@AutoConfigurationPackage</span> + <span class="citation" data-cites="Import">@Import</span>({AutoConfigurationImportSelector.class})</p>
<p><span class="citation" data-cites="AutoConfigurationPackage">@AutoConfigurationPackage</span> = <span class="citation" data-cites="Import">@Import</span>({Registrar.class})</p>
<p>故@EnableAutoConfiguration实际上相当于引入了AutoConfigurationImportSelector和Registrar。</p>
</blockquote>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo简单介绍</title>
    <url>/2021/02/20/codeAnalyse/Dubbo/</url>
    <content><![CDATA[<h1 id="dubbo">Dubbo</h1>
<h2 id="rmi-和-rpc">RMI 和 RPC</h2>
<blockquote>
<p>RMI：远程方法调用，是java自带的API可以实现的，依赖JVM。客户端将要调用的方法和参数打包成辅助对象，通过网络socket，发送给服务端辅助对象，服务端接收后进行解包，找到真正被调用的方法，执行这个方法将执行结果，依次返回。服务端辅助对象进行打包，然后客户端辅助对象进行解包，结果返回给真正的调用者。</p>
<p>IPC：进程间通信。进程是计算机系统资源分配的最小单位，每个进程都是资源隔离的。</p>
<p>LPC：本地过程调用。</p>
<p>RPC：远程过程调用。</p>
</blockquote>
<h2 id="常用rpc框架">常用RPC框架</h2>
<h3 id="dubbo-1">Dubbo</h3>
<blockquote>
<p>阿里开发，基于Spring和Netty，是当前使用最广泛的RPC框架。</p>
</blockquote>
<h3 id="brpc">BRPC</h3>
<blockquote>
<p>百度开发，"baidu-rpc"，支持多种协议，性能优良。</p>
</blockquote>
<h3 id="grpc">GRPC</h3>
<blockquote>
<p>谷歌开发，基于Netty，服务于TensorFlow的底层通信。</p>
</blockquote>
<h3 id="thrift">Thrift</h3>
<blockquote>
<p>Facebook开发。</p>
</blockquote>
<h2 id="注册中心---zookeeper">注册中心 - Zookeeper</h2>
]]></content>
      <categories>
        <category>框架入门</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>分布式</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis流程源码分析</title>
    <url>/2021/02/20/codeAnalyse/mybatis%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="mybatis流程">Mybatis流程</h1>
<h2 id="创建sqlsessionfactory的流程">创建SqlSessionFactory的流程</h2>
<blockquote>
<p>由于创建工厂需要许多配置，mybatis利用了Builder模式。</p>
<p>先创建SqlSessionFactoryBuilder，调用SqlSessionFactoryBuilder的build方法，本质上就是通过解析xml文件，将文件内容映射到Configuration对象中，然后利用这个对象产生builder创建工厂所需的配置，然后创建出SqlSessionFactory。</p>
<p>具体则是先将xml的输入流传给SqlSessionFactoryBuilder，然后创建一个XMLConfigBuilder，负责解析xml内容放入configuration对象，解析的过程中会按类别解析，通过调用不同的方法解析xml的不同部分。解析mapper还有专门的XMLMapperBuilder其中对于二级缓存的处理也在这里进行。解析完成后configuration对象会保存全部的配置信息。</p>
</blockquote>
<h2 id="利用sqlsessionfactory创建sqlsession的流程">利用SqlSessionFactory创建SqlSession的流程</h2>
<blockquote>
<p>就是SqlSessionFactory调用openSession，传入ExecutorType、TransactionIsolationLevel、autoCommit三个参数，或让mybatis按默认设置，</p>
<p>ExecutorType有BatchExecutor、ReuseExecutor、SimpleExecutor、CachingExecutor四种。</p>
<p>​ BatchExecutor 让update操作变为批处理操作，即让连续的update先累积，等到下一次query操作前再一起执行。是使用List作为批处理存储。对于update操作会复用最近一次的statement。失败了会全部回滚。</p>
<p>​ ReuseExecutor 复用Statement，利用Map&lt;String, Statement&gt;来判定。</p>
<p>​ SimpleExecutor 即使用的Statement直接关闭。</p>
<p>​ CachingExecutor 相当于在前面三个执行者的基础上套了一层缓存机制，让query方法先查看缓存，只有缓存没有时再让三个执行者执行操作。这里的缓存是通过mybatis自己实现的statement对象内部的cache实现的，有些类似hashmap，是利用cache和cachekey获得的结果。</p>
<p>TransactionIsolationLevel即事物隔离级别。</p>
<p>​ READ_UNCOMMITTED 读未提交 存在脏读、不可重复读、幻读</p>
<p>​ READ_COMMITTED 读提交 存在不可重复读、幻读</p>
<p>​ REPEATABLE_READ 可重复读 存在幻读</p>
<p>​ SERIALIZABLE 序列化</p>
<p>autoCommit是否自动提交。</p>
</blockquote>
<h2 id="利用sqlsession创建mapper">利用SqlSession创建Mapper</h2>
<blockquote>
<p>SqlSession使用getMapper方法，实际上是调用了configuration中的mapperRegistry的getMapper方法，这里使用了动态代理的设计模式。同时这里还使用了工厂方法，根据不同的类名创建对应的代理工厂。</p>
<p>这个动态代理是JDK代理，它需要使用对应类加载器，对应类接口，对应的InvocationHandler。在mybatis中InvocationHandler是MapperProxy，MapperProxy的重写的invoke函数逻辑是对于Object自带的方法直接调用，对于接口默认的方法直接调用(这个特性是由于JDK8让接口方法可以有默认实现)。对于接口的方法则创建一个MapperMethod对象，该对象使用了缓存机制，利用Map&lt;Method, MapperMethod&gt;缓存方法。</p>
<p>而MapperMethod的excuse即为代理方法的实现，该类中含有MethodSignature、SqlCommand两个内部类用于实现解析sql及方法，而具体方法实现是根据判断当前sql是增删改查中的哪种再调用sqlSession的方法来实现的。</p>
</blockquote>
<h2 id="executor与handler">Executor与Handler</h2>
<blockquote>
<p>Executor是通过StatementHandler来执行sql的。StatementHandler先prepare方法配置基础设置，然后使用parameterize来设置statement的参数。若为query操作则StatementHandler会使用ResultSetHandler来处理结果集。</p>
<p>StatementHandler为抽象interface mybatis基于这个接口实现了抽象类BaseStatementHandler，还实现了路由类RoutingStatementHandler，路由类是用于根据参数创建对应具体类的。而抽象类是作为三个具体类的基础，三个具体类分别为CallableStatementHandler、PreparedStatementHandler、SimpleStatementHandler。</p>
<p>抽象类提供给三个具体类prepare方法，其中prepare中含有抽象方法instantiateStatement，是由具体子类实现的。(模板方法模式)</p>
</blockquote>
<h2 id="mybatis对于数据库操作的整体流程">mybatis对于数据库操作的整体流程</h2>
<blockquote>
<p>先使用builder模式，根据输入的xml输入流，利用对应XML解析对象解析，并将结果最终存入Configuration对象，然后利用Configuration对象创建出一个对应的SqlSessionFactory。</p>
<p>然后需要通过sqlSessionFactory的openSession方法创建一个SqlSession，这里可以设置SqlSession的Executor、TransactionIsolationLevel和autoCommit。Executor代表这个SqlSession采用什么执行器，执行器是对statement对象的处理。具体执行器共有3种：SimpleExecutor 、ReuseExecutor 、BatchExecutor 。同时若启用了缓存cache，则会在执行器外再包装一层CachingExecutor ，相当于对于查询操作提供了二级缓存。这个缓存是位于mybatis的MappedStatement类中。本质上这种缓存就是一个嵌套的哈希结构。Map&lt;Cache, TransactionalCache&gt;，TransactionalCache也是key-value结构。</p>
<p>而事物隔离即为正常的数据库事物隔离级别。</p>
<p>创建完SqlSession后，调用SqlSession的getMapper方法获取对应mapper对象。这里使用了动态代理。mybatis是先根据传入的类对象，通过configuration的配置信息中的MapperRegistry类对象找到对应的proxy工厂，利用代理工厂创建对应的代理对象。代理对象的创建使用的是JDK动态代理，即传入需要代理的类加载器、需要代理的接口、以及InvocationHandler。mybatis的handler是先判断方法是否为Object的，然后判断方法是否为接口默认实现的。只有接口未实现的方法才进行特殊处理，处理过程即为根据方法的类型(增删改查)，执行SqlSession的对应方法。</p>
<p>SqlSession执行对应方法则是利用SqlSession内部的executor执行对应操作的。所以实际上sql操作还是由executor执行的。而executor执行操作需要利用StatementHandler先后执行prepare初始化基本配置和parameterize处理参数。参数的处理利用了ParameterHandler，这个时候typeHandler就会起作用。若为query操作还需要对返回值进行处理，处理时利用了ResultSetHandler，这个时候typeHandler就会起作用。</p>
</blockquote>
<h2 id="mybatis的缓存机制">mybatis的缓存机制</h2>
<blockquote>
<p>mybatis共有两个缓存机制：一级缓存和二级缓存。</p>
<p>一级缓存默认开启且无法关闭。</p>
<p>二级缓存需要配置。</p>
<p>一级缓存是Executor的基本实现类BaseExecutor中实现的，本质上是个Map&lt;Object, Object&gt;。由于每个SqlSession里都带有一个Executor，故一级缓存是SqlSession层面的。</p>
<p>二级缓存则需要手动配置，开启后会在具体的Executor之外使用CachingExecutor包装，这里使用了装饰者模式。二级缓存本质上是在namespace层面的缓存。</p>
</blockquote>
<h2 id="mybatis是怎么实现和springboot的整合的">mybatis是怎么实现和SpringBoot的整合的？</h2>
<blockquote>

</blockquote>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>orm</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门</title>
    <url>/2021/02/20/codeAnalyse/redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="redis使用">Redis使用</h1>
<h2 id="传统数据库的发展">传统数据库的发展</h2>
<blockquote>
<p>单库 -&gt; 单库加缓存 -&gt; 主从分离+缓存(主写从读) -&gt; 分库分表(水平拆分(将一个库拆成多个库)、垂直拆分(按模块拆分))</p>
</blockquote>
<h3 id="传统数据库特点acid">传统数据库特点ACID</h3>
<blockquote>
<p>A(Atomicity)：原子性</p>
<p>C(Consistency)：一致性</p>
<p>I(Isolation)：隔离性</p>
<p>D(Durability)：持久性</p>
</blockquote>
<h3 id="mysql的数据类型">Mysql的数据类型</h3>
<blockquote>
<p>数值型</p>
<p>​ 整数型</p>
<p>​ 小数型</p>
<p>日期时间类型</p>
<p>字符串型</p>
</blockquote>
<h2 id="nosql">NoSQL</h2>
<blockquote>
<p>易拓展：没有关系型数据库的关系型特性。</p>
<p>性能高：NoSQL读写性能高。且cache一般是细粒度的。</p>
<p>数据类型灵活。</p>
</blockquote>
<h3 id="nosql分类">NoSQL分类</h3>
<blockquote>
<p>K-V：Memcache、Redis</p>
<p>列族：Hbase</p>
<p>文档：MongoDB</p>
<p>图：Neo4j</p>
</blockquote>
<h3 id="nosql-cap定理">NoSQL CAP定理</h3>
<blockquote>
<p>CAP定理：一个分布式系统不可能同时很好的满足一致性、可用性、分区容忍性这三个需求，最多只能同时较好的满足两个。</p>
<p>C(Consistency)：所有节点在同一时间有相同的数据。</p>
<p>A(Availability)：保证每个请求不管成功或者失败都有响应。</p>
<p>P(Partition tolerance)：系统中任意信息丢失或失败不会影响系统继续运作。</p>
<p>满足CA：单点集群。</p>
<p>满足CP：满足一致性、分区容忍性的系统，性能一般不高</p>
<p>满足AP：满足可用性、分区容忍性的系统，一致性要求较低。</p>
</blockquote>
<h3 id="nosql-base特点">NoSQL BASE特点</h3>
<blockquote>
<p>BA： Basically Availble基本可用。</p>
<p>S：Soft-state：软状态/柔性事务，无连接</p>
<p>E：Eventual Consistency 最终一致性。</p>
</blockquote>
<h2 id="redis">Redis</h2>
<h3 id="redis命令">Redis命令</h3>
<blockquote>
<p>redis-server：启动服务端</p>
<p>redis-benchmark：压测</p>
<p>redis-cli -p 端口号：启动客户端。</p>
<p>set key1 "xxxx"：设置key1的值为xxxx</p>
<p>get key1：获取key1对应的值</p>
<p>exit：退出当前连接</p>
<p>shutdown：关闭服务端</p>
<p>keys pattern：表示查找符合pattern的key。如keys *</p>
<p>dbsize：展示数据库key个数。</p>
<p>flushdb：删除当前数据库的操作。</p>
<p>flushall：删除所有数据库的数据。</p>
<p>exists xxx：判断xxx的键是否存在。</p>
<p>type xxx：判断xxx的键存储的值类型。</p>
<p>expire key 秒数(n)：设置key值的有效时间为n秒，过期后该key即被删除。</p>
<p>ttl key：查看key的有效时间，正数未过期。返回-1时说明key没有设置有效时间，返回-2说明key已不存在。</p>
<p>pexpire key 毫秒数：设置key值的有效时间为x毫秒。</p>
<p>pttl key：查看key的有效时间，毫秒为单位。</p>
<p>persist key：让key始终存在。</p>
<p>del key：删去key。</p>
<p>rename key1 key2： 把key1重命名为key2。</p>
<p>randomkey：随机找到一个key。</p>
<p>move key dbId ：把key移动到第dbId个数据库下。</p>
</blockquote>
<h3 id="redis配置">Redis配置：</h3>
<blockquote>
<p>database 16：默认16个数据库，可以通过select x来选择当前使用的数据库。可以通过ip：6379【x】中x值判断当前是哪个数据库。</p>
</blockquote>
<h3 id="redis数据结构">Redis数据结构</h3>
<h4 id="基本数据结构">基本数据结构</h4>
<h5 id="string">String</h5>
<blockquote>
<p>命令：</p>
<p>​ strlen key ：获取key存储的字符串长度</p>
<p>​ append key “xxx" ：在原有的基础上添加字符串。</p>
<p>​ getrange key strat end： 获取子串</p>
<p>​ getset key value ：修改原key对应的值并将旧值返回。</p>
<p>当值为整数时，直接进行数学运算。</p>
<p>​ incr key ：key对应的值自增1</p>
<p>​ incrby key number ：key对应的值自增number</p>
<p>​ decr key：key对应的值自减1</p>
<p>​ decrby key number ：key对应的值自减number</p>
<p>​ setex key 秒数 值：相当于同时设置了过期时间和值。</p>
<p>​ setnx key：不存在时才设置。</p>
<p>​ mget key1 key2.....：一次获取多个key对应的值</p>
<p>​ mset key1 value1 key2 value2.....：一次设置多个key-value。</p>
<p>​ msetnx key1 value1 key2 value2.....：一次设置多个key-value，具体set操作同setnx。</p>
<p>原理：</p>
<p>​ redis字符串是动态字符串，内部类似于ArrayList。采用预分配冗余空间的方式减少内存的频繁分配。当字符串长度&lt;1MB，扩容方式是直接加倍，若&gt;1MB，一次扩容只扩容1MB，直到扩大到512MB。</p>
</blockquote>
<h5 id="list">List</h5>
<blockquote>
<p>lpush key value1 value2 value3 .... ：从左侧存放值。</p>
<p>lpop key：从左侧弹出。</p>
<p>rpush key value1 value2 value3 .... ：从右侧存放值。</p>
<p>rpop key：从右侧弹出。</p>
<p>lrange key start end：按范围查看值。</p>
<p>llen key：查看长度</p>
<p>lindex key index：获取key对应index位置的值。</p>
<p>lrem key count value：移除count绝对值个和value相同的值。</p>
<p>ltrim key start end：截取范围内的值重新赋值给key。</p>
<p>linsert key before/after oldValue newValue 插入数据到某个数据前/后。</p>
<p>lpushx key value ：在列表头部插入数据。</p>
<p>rpushx key value：在列表尾部插入数据。</p>
<p>lset key pos value：把列表的第pos个位置改为value。</p>
<p>最多可存储<span class="math inline">\(2^{32}-1\)</span>个元素</p>
<p>原理：</p>
<p>​ 底层是一个快速链表，在列表元素较少时使用连续的内存压缩列表ziplist。当数据量较多时，改为quicklist，即将多个ziplist使用双向指针串起来使用。</p>
</blockquote>
<h5 id="hash">Hash</h5>
<blockquote>
<p>本质上类似于HashMap&lt;String,Map&gt;</p>
<p>hset key field value</p>
<p>hget key field</p>
<p>hkeys key</p>
<p>hvals key</p>
<p>hmset key field1 value1 field2 value2 ....</p>
<p>hmget key field1 field2 .....</p>
<p>hdel key field</p>
<p>hgetall key</p>
<p>hexists key field</p>
<p>hsetnx key field value</p>
<p>hincrby key field increment 让field增加increment</p>
<p>原理：</p>
<p>​ 底层同HashMap，也是数组+链表，但是redis的值只能为字符串，且二者rehash的方式不同，java的HashMap是一次全部rehash，redis采用渐进式rehash。具体操作为同时保留新旧两个hash结构，然后逐步搬迁。</p>
</blockquote>
<h5 id="set">Set</h5>
<blockquote>
<p>类似于HashSet，也是通过哈希表实现的，相当于所有value都是空的。通过计算hash的方式快速排除重复。</p>
<p>sadd key value1 value2 value3 value4</p>
<p>scard key 查看当前set的元素个数</p>
<p>smembers key 查看当前set的具体元素值</p>
<p>srem key value1 value2 value3 value4 移除元素</p>
<p>sismember key value 判断value是不是set中的元素</p>
<p>srandmember key number 在set中随机查看number个元素。</p>
<p>spop key number 在set中随机弹出number个元素。</p>
<p>smove key1 key2 value 移动元素value从key1到key2</p>
<p>sinter key1 key2 求key1、key2的交集</p>
<p>sunion key1 key2 求key1、key2的并集</p>
<p>sdiff key1 key2 求key1、key2的差集</p>
<p>sunionstore des key1 key2 求出key1、key2的并集然后存入des中</p>
</blockquote>
<h5 id="zset有序集合">Zset(有序集合)</h5>
<blockquote>
<p>和无序集合的区别是每个元素除了值之外还有一个浮点数的分数。内部实现使用了跳表。分数可重复，但值不可重复。</p>
<p>zadd key score1 value1 score2 value2 score3 value3 ....</p>
<p>zrange key start end [with scores] 查看范围内的值，加了with scores可以看见对应分数。</p>
<p>zrangebyscore key min max [limit offset num]查看对应分数范围内的值。 分数前加(表示开区间，[表示闭区间。如 zrangebyscore key (1 [99。加上【】内语句可以分页。</p>
<p>zrem key value 删除</p>
<p>zcard key 统计元素个数</p>
<p>zcount key min max 统计分数在min，max内的值个数</p>
<p>zscore key member 查询指定成员分数</p>
<p>zrank key member 查询指定成员分数排名(正序，从小到大排名)</p>
<p>zrevrank key member 查询指定成员分数排名(逆序，从大到小排名)</p>
</blockquote>
<h4 id="拓展数据结构">拓展数据结构</h4>
<h5 id="geo">GEO</h5>
<blockquote>
<p>基于zset的拓展，用于存储地理位置信息。</p>
<p>geoadd key 经度1 纬度1 member1 经度2 纬度2 member2.....</p>
<p>zrange key start end withscores</p>
<p>geodis key value1 value2 距离单位(m/km) 求两个位置之间的距离。</p>
<p>geopos key value 查询某地位置</p>
<p>geohash key value 对value进行hash</p>
<p>georadius key 经度 纬度 半径长度 长度单位 [withdist/withcoord/withhash]：以某个经纬度位置为中心，然后指定半径，返回满足条件的地址。</p>
</blockquote>
<h5 id="bitmap">Bitmap</h5>
<blockquote>
<p>setbit key index 0/1 零存</p>
<p>set key value 整存</p>
<p>getbit key index 零取</p>
<p>get key 整取</p>
<p>bitcount key 计算有几个1</p>
<p>bitcount key start end 从第start个字符到第end个字符有几个1</p>
</blockquote>
<h5 id="hyperloglog基数统计">HyperLogLog(基数统计)</h5>
<blockquote>
<p>pfadd key field 添加指定元素，若已存储返回0</p>
<p>pfcount key 返回基数值</p>
</blockquote>
<h5 id="stream">Stream</h5>
<blockquote>
<p>具体指令格式省略。</p>
<p>xadd 生成消息，返回消息id(时间戳+顺序)，顺序指该毫秒下消息的顺序。</p>
<p>xlen 查看消息列表长度</p>
<p>xrange 查看消息</p>
<p>xdel 删去消息</p>
<p>xread 读取消息</p>
</blockquote>
<h3 id="发布和订阅">发布和订阅</h3>
<blockquote>
<p>发布者发布消息到调度中心，订阅者从订阅中心订阅消息。类似于观察者模式。</p>
<p>redis中使用subscribe channel订阅，使用publish channel message发布消息。</p>
</blockquote>
<h3 id="redis配置-1">Redis配置</h3>
<h3 id="redis淘汰策略">Redis淘汰策略</h3>
<blockquote>
<p>volatile-lru：对超时key采用最近最少使用策略。</p>
<p>allkeys-lru：对所有key采用最近最少使用策略。</p>
<p>volatile-random：对超时的key采用随机淘汰策略。</p>
<p>allkeys-random：对所有key采用随机淘汰策略。</p>
<p>volatile-ttl：采用删除存活时间最短的键值对策略。</p>
<p>noeviction：不淘汰，当内存已满时再进行写操作会返回错误。</p>
<p>这里的LRU算法和TTL算法都是近似算法，redis使用抽样的方式执行。可以配置maxmemory-samples的值来控制抽样范围。</p>
</blockquote>
<h3 id="redis持久化">Redis持久化</h3>
<h4 id="rdb">RDB</h4>
<blockquote>
<p>在指定时间间隔对数据进行快照存储。是全量备份。</p>
<p>命令触发：</p>
<p>​ save：阻塞当前Redis服务器，直到持久化完成。</p>
<p>​ bgsave：fork一个子进程，由子进程负责持久化过程。</p>
<p>自动触发：</p>
<p>​ 根据配置的save m n 配置规则自动触发</p>
<p>​ 从结点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点触发bgsave</p>
<p>​ 执行debug reload时</p>
<p>​ 执行shutdown若没有开启aof时也会触发。</p>
<p>恢复方式：</p>
<p>​ 将备份文件(dump.rdb)移动到redis安装目录并启动服务即可。</p>
</blockquote>
<h4 id="aof">AOF</h4>
<blockquote>
<p>以日志文本形式记录服务器所处理的每个数据更改指令，通过重放来恢复数据，是增量备份。</p>
<p>本质上就是以日志的形式记录服务器处理的每个更改操作。</p>
<p>但是实际中由于更改操作可能数量巨大，导致恢复数据较慢，所以会对日志进行重写，即让某些操作合并。</p>
<p>具体流程：命令写入-&gt; 追加到aof_buf -&gt; 同步到aof磁盘</p>
<p>aof重写：</p>
<p>​ 手动触发：bgrewriteaof</p>
<p>​ 自动触发：根据配置规则来触发。</p>
<p>写入aof文件时若redis服务器宕机，日志文件会出现格式错误，重启时服务器会拒绝载入。可以通过redis-check-aof -fix file.aof来修复。</p>
</blockquote>
<h3 id="redis分布式锁">Redis分布式锁</h3>
<h4 id="乐观锁">乐观锁</h4>
<blockquote>
<p>每次处理数据时都认为别人都不会去修改数据，所以每次拿数据时都不会上锁。但如果想要更新数据，会在更新前检查在读取至更新这段时间内别人是否修改过这个数据，若修改过则重新读取，再次尝试更新，循环步骤直至成功。</p>
<p>乐观锁回滚重试，适用于写比较少的情况。</p>
<p>CAS算法(非阻塞同步)：</p>
<p>​ 读取一个A，在将其更新到B前，检查值是否还是A。</p>
<p>​ 若还是A则将A更新为B，否则什么也不做。</p>
<p>CAS缺点：ABA问题。</p>
</blockquote>
<h4 id="悲观锁">悲观锁</h4>
<blockquote>
<p>每次处理数据时都认为别人都会去修改数据，所以每次拿数据时都会上锁。</p>
<p>悲观锁阻塞事务，适用于写比较多的情况。</p>
</blockquote>
<h4 id="分布式锁">分布式锁</h4>
<blockquote>
<p>三种方式：数据库乐观锁、基于Redis的分布式锁、基于ZooKeeper的分布式锁。</p>
<p>分布式锁需要满足四个条件：</p>
<p>​ 互斥性。任意时刻只有一个客户端能持有锁。</p>
<p>​ 不会发生死锁。即使一个客户端崩溃了未能主动解锁，其他客户端也能加锁。</p>
<p>​ 具有容错性。</p>
<p>​ 加锁和解锁必须是同一个客户端。</p>
<p>redis实现分布式锁：</p>
<p>​ 通过setnx，和del来实现加锁和解锁的功能。</p>
<p>​ 其中setnx key value ex 在加锁的同时加上锁的过期时间，避免产生死锁。</p>
<p>​ 也可能配合lua脚本使用，因为lua可以保证连续多个子命令的原子性执行的。</p>
</blockquote>
<h2 id="主从模式">主从模式</h2>
<blockquote>
<p>slave of</p>
<p>从节点只允许读。</p>
<p>复制过程：</p>
<p>​ 旧版是SYNC：主库先生成一个RDB文件，然后将这个文件通过网络发送给从库</p>
<p>​ 新版(2.8以后)是PSYNC：分为完整重同步和部分重同步。完整重同步用于初次复制，类似于旧版的SYNC。部分重同步用于处理断线后重复制的情况。当从服务器断线后重连主服务器时，条件允许的话主服务器可以将主从服务器断开连接期间的写命令发送给从服务器，从服务器只要接收执行这些命令即可完成同步。</p>
<p>​ 部分重同步的实现需要：</p>
<p>​ 主服务器的复制偏移量和从服务器的复制偏移量。</p>
<p>​ 主服务器的复制积压缓冲区。</p>
<p>​ 服务器的运行ID。</p>
</blockquote>
<h2 id="哨兵模式">哨兵模式</h2>
<blockquote>
<p>主服务器中断服务时，将一个从服务器升级为主服务器。为了实现自动执行这一操作，就出现了哨兵模式。</p>
<p>哨兵作用是监控redis系统的运行状况，功能包括：</p>
<p>​ 监控主服务器和从服务器是否正常运行。</p>
<p>​ 主服务器出现故障时自动将从服务器转换为主服务器。</p>
<p>哨兵模式优点：</p>
<p>​ 主从可以切换，系统更加健壮，可用性更高。</p>
<p>哨兵模式缺点：</p>
<p>​ Redis较难在线扩容，在集群容量达到上限时在线扩容变得十分复杂。</p>
</blockquote>
<h2 id="cluster模式">Cluster模式</h2>
<blockquote>
<p>集群：使用多个主从模式的redis搭建，每个主从模式的redis又充当彼此的哨兵。</p>
</blockquote>
<h2 id="缓存可能遇到的问题">缓存可能遇到的问题</h2>
<h3 id="缓存穿透">缓存穿透</h3>
<blockquote>
<p>访问一个不存在的key，缓存不起作用，请求穿透到DB。这个key在数据库也查询不出结果，导致反复查询都会直接去查询数据库。</p>
<p>解决方案：采用布隆过滤器，使用一个足够大的位图，存储可能访问的key，不存在的key直接过滤。或者对应key去查询数据库时即使查询不出结果也在缓存中设置一个缓存，让下次查询可以访问缓存。</p>
</blockquote>
<h3 id="缓存雪崩">缓存雪崩</h3>
<blockquote>
<p>大量的key设置了相同的过期时间，导致缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<p>解决方案：给缓存设置过期时间的同时加上一个随机值时间，使得每个key的过期时间发布开，不会集中在同一时刻失效。</p>
</blockquote>
<h3 id="缓存击穿">缓存击穿</h3>
<blockquote>
<p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求会击穿到DB，造成瞬时DB请求量大。</p>
<p>解决方案：在访问key之前，采用SETNX来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>框架入门</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>数据库</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>http基本知识及改进</title>
    <url>/2021/02/20/codeAnalyse/http%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%8F%8A%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<h1 id="http基本知识及改进">http基本知识及改进</h1>
<h2 id="http介绍">HTTP介绍</h2>
<h3 id="版本">0.9版本</h3>
<blockquote>
<p>GET /index.html</p>
<p>服务端只能返回html格式，传输过程只能处理文字</p>
</blockquote>
<h3 id="版本-1">1.0版本</h3>
<blockquote>
<p>支持任何格式的内容，包括图像、视频、二进制等。</p>
<p>引入了POST命令、HEAD命令。</p>
<p>增加了请求头、状态码，以及权限缓存等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 请求包</span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent:Mozilla/1.0</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line"># 应答包</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 12345</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Content-Type表示当前数据格式：text/html、image/png、application/pdf、video/mp4。</p>
<p>前面是一级格式，后面是二级类型，用斜杆分隔，还可以增加其他参数，如编码格式</p>
<p>Content-Type：text/plain；charset=utf-8</p>
<p>Content-Encoding表示数据压缩的方式：gzip、compress、deflate。</p>
<p>对应客户端的字段为Accept-Encoding，代表接收哪些压缩方式。</p>
<h4 id="缺点和问题">缺点和问题：</h4>
<p>每个TCP连接只能发送一个请求，发送完毕连接关闭，使用成本很高，性能较差。</p>
<p>Connection：keep-alive (非标准字段)</p>
</blockquote>
<h2 id="版本-2">1.1版本</h2>
<blockquote>
<p>持久连接：默认不关闭TCP连接，可以被多个请求复用。</p>
<p>管道机制：支持客户端发送多个请求，管理请求的顺序。服务器还是按照接受请求的顺序，返回对应的响应结果。</p>
<p>Content-Length：用于区分数据包的字段。</p>
<p>支持了DELETE、PUT、PATCH等命令。</p>
<h4 id="缺点和问题-1">缺点和问题</h4>
<p>当部分请求耗时较长时，仍会阻塞后续请求的处理速度，这种现象叫做“队头阻塞/线头阻塞”。</p>
</blockquote>
<h3 id="版本-3">2.0版本</h3>
<blockquote>
<p>解决了队头阻塞的问题。多路复用。</p>
</blockquote>
<h2 id="http的缺陷">HTTP的缺陷</h2>
<blockquote>
<p>通信只能由客户端发起，需要一种服务端能够主动推送的能力-websocket。</p>
<p>这种双向通信的能力，也叫"全双工"，协议标识符：http://127.0.0.1/ 变为 ws://127.0.0.1/ 通信的最小单位是帧frame。</p>
</blockquote>
<h2 id="websocket">WebSocket</h2>
<blockquote>
<p>websocket是由浏览器发起的。</p>
<p>响应码101代表本次协议需要更改为websocket。</p>
<p>建立连接后，支持文本信息和二进制信息。</p>
<p>Websocket实现的原理：</p>
<p>​ 通过http协议进行连接的建立，建立连接后不再使用http，而tcp自身是支持双向通信的，所以可以达到全双工的效果。</p>
<p>通信使用的单位叫帧frame</p>
<p>客户端：发送时，将消息切割成多个帧。</p>
<p>服务端：接收时，将关联的帧重新组装。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot常用配置</title>
    <url>/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="springboot常用配置">SpringBoot常用配置</h1>
<h2 id="选择不同配置">选择不同配置</h2>
<blockquote>
<p>也可以通过在类中使用@Profile("xx")来表示这个类只有在xx为active的情况下才可使用。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/springboot多配置文件设置启用.png" alt="springboot多配置文件设置启用"><figcaption aria-hidden="true">springboot多配置文件设置启用</figcaption>
</figure>
</blockquote>
<h2 id="自动加载配置文件的内容">自动加载配置文件的内容</h2>
<blockquote>
<p><span class="citation" data-cites="Value">@Value</span></p>
<p><span class="citation" data-cites="ConfigurationProperties">@ConfigurationProperties</span>(prefix = "spring.datasource.druid.write") 使用该注解需要引入且要启用@EnableConfigurationProperties(使用前面一个注解的类.class)</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><span class="citation" data-cites="PropertySource">@PropertySource</span></p>
</blockquote>
<h2 id="配置文件的加载顺序下覆盖上">配置文件的加载顺序(下覆盖上)</h2>
<blockquote>
<ol type="1">
<li>Application properties packaged inside your jar (application.properties and YAML variants).</li>
<li>Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants).</li>
<li>Application properties outside of your packaged jar (application.properties and YAML variants)</li>
<li>Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants).</li>
</ol>
</blockquote>
<h2 id="自动加载的-application.properties-的加载顺序下覆盖上">自动加载的 application.properties 的加载顺序(下覆盖上)</h2>
<blockquote>
<ol type="1">
<li><p>The classpath root</p></li>
<li><p>The classpath /config package</p></li>
<li><p>The current directory</p></li>
<li><p>The /config subdirectory in the current directory</p></li>
<li><p>Immediate child directories of the /config subdirectory</p></li>
</ol>
<p>4、5的差别就是如果config目录的根目录里有application.properties，则会将config子目录的application.properties覆盖。</p>
<p>而classpath中springboot不会自动扫描config子目录中的目录。</p>
<p>可以通过修改spring.config.name来修改默认配置文件名。</p>
<p>修改spring.config.location 可以修改springboot获取配置文件的位置。</p>
<p>修改spring.config.additional-location可以在springboot默认获取配置文件的位置的基础上补充一些获取配置文件的位置。optional: 前缀</p>
</blockquote>
<h2 id="可以使用来获取外部目录classpath中不能使用">可以使用*来获取外部目录，classpath中不能使用*</h2>
<h2 id="可以使用---在.pro配置文件中划分逻辑页">可以使用#---在.pro配置文件中划分逻辑页</h2>
<h2 id="使用---在.yml配置文件划分逻辑页">使用---在.yml配置文件划分逻辑页</h2>
<h2 id="在多个配置文件中均存在同一个list的值则只会去最高优先级的list值">在多个配置文件中均存在同一个list的值，则只会去最高优先级的list值</h2>
<h2 id="在多个配置文件中均存在同一个map的值则使用互补配置的方式构造map">在多个配置文件中均存在同一个Map的值，则使用互补配置的方式构造Map</h2>
<h2 id="spring自动注入的注解">spring自动注入的注解</h2>
<blockquote>
<p><span class="citation" data-cites="Component">@Component</span>("name")将一个类生成一个Bean实例并用spring管理。<span class="citation" data-cites="Controller">@Controller</span>、<span class="citation" data-cites="Repository">@Repository</span>、<span class="citation" data-cites="Service都是类似的功能">@Service都是类似的功能</span>。这些注解要放在类上。</p>
<p><span class="citation" data-cites="Bean">@Bean</span>("name")将一个方法返回的对象实例用spring管理。该注解放在方法上。</p>
<p><span class="citation" data-cites="Autowired">@Autowired</span> 自动注入。该注解可以放在构造器方法、方法、参数、属性、注解上。</p>
<p><span class="citation" data-cites="Primary">@Primary</span> 写在类上或方法上。为了消除自动装配的歧义性，如spring管理了两个都实现了同一父类的类，则存在@Primary 的类会被最先调用。</p>
<p><span class="citation" data-cites="Qualifier">@Qualifier</span>("name")写在变量、方法、参数、类上、注解上，可以根据传入的name按名字查找spring管理的类。</p>
</blockquote>
<h2 id="spring监听器">Spring监听器</h2>
<blockquote>
<p>使用过程:</p>
<p>​ 自定义事件，继承org.springframework.context.ApplicationEvent类。</p>
<p>​ 自定义事件监听器，实现org.springframework.context.ApplicationListener接口。</p>
<p>​ 在spring容器中发布事件。</p>
<p>实现监听的方式：</p>
<p>​ 自定义类实现ApplicationListener，在主函数中装载监听。</p>
<p>​ 自定义类实现ApplicationListener，在接口上加上@Component注解</p>
<p>​ 自定义类不实现接口，在对应方法上标明@EventListener注解。</p>
<p>​ 自定义类实现ApplicationListener，在application.properties中配置context.listener.classes</p>
</blockquote>
<h2 id="spring内置容器的配置">Spring内置容器的配置</h2>
<blockquote>
<p>修改配置：</p>
<ol type="1">
<li><p>可以在application.properties中按server.xxx:的方式修改</p></li>
<li><p>创建一个配置类通过编写public WebServerFactoryCustomizer<ConfigurableWebServerFactory> customizer()方法来设置。</ConfigurableWebServerFactory></p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/内嵌服务器配置修改.png" alt="内嵌服务器配置修改"><figcaption aria-hidden="true">内嵌服务器配置修改</figcaption>
</figure></li>
</ol>
<p>更换容器：</p>
<p>​ 通过先将start内的容器依赖去除然后导入新依赖即可。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/修改内嵌容器.png" alt="修改内嵌容器"><figcaption aria-hidden="true">修改内嵌容器</figcaption>
</figure>
</blockquote>
<h2 id="过滤器和拦截器">过滤器和拦截器</h2>
<blockquote>
<p>过滤器：在进入servlet前过滤。</p>
<p>实现方式：</p>
<p>​ 创建类实现接口javax.servlet.Filter，加上@Component，然后使用一个如下的配置类注入spring容器。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/filterConfig.png" alt="filterConfig"><figcaption aria-hidden="true">filterConfig</figcaption>
</figure>
<p>​ 创建类实现接口javax.servlet.Filter，加上@WebFilter，然后在主启动类中加上@ServletComponentScan注解。</p>
<p>拦截器：拦截方法。</p>
<p>​ 创建类实现HandlerInterceptor接口，然后创建配置类实现WebMvcConfigurer接口，配置类如下。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/interceptorConfig.png" alt="interceptorConfig"><figcaption aria-hidden="true">interceptorConfig</figcaption>
</figure>
</blockquote>
<h2 id="错误及异常处理">错误及异常处理</h2>
<h3 id="数值校验">数值校验</h3>
<blockquote>
<p>在参数前加入@Valid/<span class="citation" data-cites="Validated注解">@Validated注解</span>，然后跟上BindingResult对象即可获取错误时的错误信息。如图</p>
<p>利用配置文件ValidationMessages.properties中设置发生错误的提示信息。在bean的注解属性中通过{key}获取属性。</p>
</blockquote>
<h3 id="错误页指定">错误页指定</h3>
<blockquote>
<p>用到了再查</p>
</blockquote>
<h3 id="全局异常处理">全局异常处理</h3>
<blockquote>
<p>实现一个异常处理类并加上@ControllerAdvice注解。如图</p>
<figure>
<img src="/2021/02/20/codeAnalyse/springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/全局异常处理.png" alt="全局异常处理"><figcaption aria-hidden="true">全局异常处理</figcaption>
</figure>
</blockquote>
<h2 id="日志">日志</h2>
<h3 id="日志文件输出">日志文件输出</h3>
<blockquote>
<p>在application中添加logging.file.path = xxx 默认日志名为spring.log</p>
<p>或添加logging.file.name = xxxx 默认输出路径为项目当前路径。</p>
<p>二者不能同时使用。</p>
</blockquote>
<h3 id="日志级别控制">日志级别控制</h3>
<blockquote>
<p>日志级别有TRACE、DEBUG、INFO、WARN、ERROR、FATAL、OFF。</p>
<p>logging.level.包名 = xxx级别</p>
<p>logging.level.root = 设置全局日志级别</p>
</blockquote>
<h2 id="文档生成">文档生成</h2>
<h3 id="swaggle">swaggle</h3>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">		</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).select()</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问http://localhost:8080/v2/api-docs拿到api的json</p>
<p>访问http://localhost:8080/swagger-ui.html获取页面</p>
</blockquote>
<h2 id="监控">监控</h2>
<blockquote>
<p>本质上是通过log收集信息，然后利用信息分析。</p>
</blockquote>
<h2 id="缓存">缓存</h2>
<blockquote>
<p><span class="citation" data-cites="Cacheable">@Cacheable</span>(value = "xx", key = "zz", condition = "yyy")</p>
<p>​ value 表示缓存名</p>
<p>​ key为缓存键，需要用SPEL写</p>
<p>​ condition为缓存触发的条件，需要用SPEL写</p>
<p>​ 缓存值为对应方法的返回值</p>
<p><span class="citation" data-cites="CacheEvict">@CacheEvict</span>(beforeInvocation = true表示在方法触发前就移除了缓存) 移除缓存</p>
<p><span class="citation" data-cites="CachePut">@CachePut</span> 添加缓存</p>
</blockquote>
<h2 id="微服务">微服务</h2>
<blockquote>
<p>注册中心</p>
<p>服务提供者</p>
<p>服务追踪</p>
<p>服务治理</p>
</blockquote>
]]></content>
      <categories>
        <category>框架入门</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx了解</title>
    <url>/2021/02/20/codeAnalyse/nginx%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="nginx">Nginx</h1>
<h2 id="概述">概述</h2>
<blockquote>
<p>Nginx是高性能的http和反向代理服务器，也是一个IMAP/SMTP/POP3等邮件代理服务器。</p>
<p>正向代理和反向代理</p>
<p>正向代理：客户端client通过设置，使用代理服务器proxy去访问远程服务器server。客户端知道代理存在。</p>
<p>​ | client - proxy | - server</p>
<p>使用场景：</p>
<p>​ 可以访问原来无法访问的资源。</p>
<p>​ 做缓存使用，加快访问速度。</p>
<p>​ 对客户端授权或记录访问信息。</p>
<p>反向代理：服务器通过代理服务接收连接请求，再转发给内部网络的服务器，将结果返回给客户端。客户端不知道代理存在。</p>
<p>​ client - | proxy - server |</p>
<p>使用场景：</p>
<p>​ 保证内网安全，阻止web攻击。</p>
<p>​ 负载均衡。</p>
</blockquote>
<h2 id="nginx命令">Nginx命令</h2>
<blockquote>
<p>启动命令./Nginx</p>
<p>杀死进程 kill SIGNAL pid</p>
<p>​ kill -9 pid 强制停止</p>
<p>​ kill -TERM pid 快速停止</p>
<p>​ kill -QUIT pid 平缓停止</p>
<p>查看版本 ./Nginx -V</p>
<p>信号处理 ./Nginx -s SIGNAL(stop、quit、reopen、reload)</p>
<p>​ 关闭 ./Nginx -s stop</p>
<p>​ 重加载 ./Nginx -s reload</p>
<p>​ 平缓停止 ./Nginx -s quit</p>
<p>​ 快速停止 ./Nginx -s stop</p>
</blockquote>
<h2 id="nginx配置">Nginx配置</h2>
<h3 id="全局块">全局块</h3>
<blockquote>
<p>全局块：指定运行时的用户组、进程id存放位置、日志存放位置、worker process数量等。</p>
<p>#user nobody ：配置用户或用户组</p>
<p>#worker_processes 1 ：运行启动的进程数</p>
<p>#error_log logs/error.log 级别 ：日志路径及级别设置</p>
<p>#pid logs/nginx.pid 进程id的文件地址</p>
</blockquote>
<h3 id="events块">events块</h3>
<blockquote>
<p>events块：影响Nginx服务器和用户网络连接配置，如每个进程最大连接数、选择哪种事件驱动模型、是否序列化events块：影响Nginx服务器和用户网络连接配置，如每个进程最大连接数、选择哪种事件驱动模型、是否序列化。</p>
<p>events{</p>
<p>​ #worker_connections 1024：每个进程的最大连接数</p>
<p>}</p>
</blockquote>
<h3 id="http块">http块</h3>
<blockquote>
<p>http块：配置代理、缓存、日志等绝大部分功能的地方。可以嵌套多个server块，而不同的server可以对应不同的域名(虚拟主机)。</p>
<p>虚拟主机：同一台Nginx服务器，可以支持多个网站的运行，每个虚拟主机之间都互相独立，具有完整功能。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 相对路径</span><br><span class="line">			root html;</span><br><span class="line">			# 默认跳转的首页地址</span><br><span class="line">			index index.html index.htm;</span><br><span class="line"></span><br><span class="line">		&#125;	</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志配置：可以获取用户地址信息、跳转来源、终端、url访问量等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">#access_log logs/access.log main;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th></th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>remote_addr</td>
<td>客户端的ip地址</td>
</tr>
<tr class="even">
<td>remote_user</td>
<td>客户端的用户名称</td>
</tr>
<tr class="odd">
<td>time_local</td>
<td>访问时间和时区</td>
</tr>
<tr class="even">
<td>request</td>
<td>请求方法</td>
</tr>
<tr class="odd">
<td>status</td>
<td>响应状态码 如：200</td>
</tr>
<tr class="even">
<td>body_bytes_sent</td>
<td>主体内容字节数 如：612</td>
</tr>
<tr class="odd">
<td>http_referer</td>
<td>记录是从哪个链接访问过来的</td>
</tr>
<tr class="even">
<td>http_user_agent</td>
<td>用户使用的代理（浏览器）</td>
</tr>
<tr class="odd">
<td>http_x_forwarded_for</td>
<td>通过代理服务器来记录客户端的ip地址</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="反向代理配置">反向代理配置</h3>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 相对路径</span><br><span class="line">			root html;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://127.0.0.1:8080</span><br><span class="line">			# 默认跳转的首页地址</span><br><span class="line">			index index.html index.htm;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理多个tomcat服务器，通过路径来映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location ~ path1 &#123;</span><br><span class="line">			# 相对路径</span><br><span class="line">			root html;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://127.0.0.1:8080</span><br><span class="line">			# 默认跳转的首页地址</span><br><span class="line">			index index.html index.htm;</span><br><span class="line">        &#125;	</span><br><span class="line">		location ~ path2 &#123;</span><br><span class="line">			# 相对路径</span><br><span class="line">			root html;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://127.0.0.1:8081</span><br><span class="line">			# 默认跳转的首页地址</span><br><span class="line">			index index.html index.htm;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="负载均衡">负载均衡</h3>
</blockquote>
<blockquote>
<p>早期使用DNS(域名解析系统)做负载，具体来说就是给客户端解析不同的ip地址，让流量直接到达服务器。</p>
<p>优点： 1） 通过健康检查，避免单点故障 2） 当发现节点故障时，从集群中移除，保证应用的高可用</p>
<p>四层负载均衡，在OSI模型的传输层，主要是转发。 七层负载均衡，在OSI模型的应用层，主要是代理。</p>
<p>负载均衡器可以处理HTTP/HTTPS/TCP/UDP等的请求。</p>
<p>负载均衡的调度算法：</p>
<p>​ 轮询。</p>
<p>​ 最小连接：优先选择连接数最少的服务器，适用于会话时间较长的业务处理。</p>
<p>​ IP映射，根据请求的ip地址进行散列，让同一ip下的请求都映射到同一服务器上，可以解决session问题。</p>
<p>Nginx设置默认轮询算法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080;</span><br><span class="line">		server 192.168.1.20:8081;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置权重的情况，默认权重是1。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080 weight = 1;</span><br><span class="line">		server 192.168.1.20:8081 weight = 2;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据ip地址固定server处理，使用ip_hash。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080 weight = 1;</span><br><span class="line">		server 192.168.1.20:8081 weight = 2;</span><br><span class="line">		ip_hash;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 定位出路径或文件地址</span><br><span class="line">		location / &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="动静分离">动静分离</h3>
<blockquote>
<p>将静态资源和动态资源分开。</p>
<p>静态资源直接查找Nginx的静态资源地址。</p>
<p>动态资源请求通过反向代理映射到tomcat路径下的资源。</p>
<p>实现方式：</p>
<p>​ 单独把静态文件放在独立的服务器及独立的域名下(推荐)。</p>
<p>​ 将动态资源和静态资源混合在一起，通过Nginx分开。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080 weight = 1;</span><br><span class="line">		server 192.168.1.20:8081 weight = 2;</span><br><span class="line">		ip_hash;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		# 访问动态资源</span><br><span class="line">		location ~ .*.jsp$ &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">		# 访问静态资源</span><br><span class="line">		location ~ .*\.(gif|jpg|css)$ &#123;</span><br><span class="line">			root /usr/local/nginx/image;</span><br><span class="line">			// 缓存时间</span><br><span class="line">			expires 3d;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="location块的匹配规则">location块的匹配规则</h3>
</blockquote>
<blockquote>
<p>匹配规则：</p>
<p>​ location = /uri 精确匹配</p>
<p>​ location ^~ /uri 前缀匹配，顺序在正则之前</p>
<p>​ location ~ pattern 区分大小写的正则匹配</p>
<p>​ location ~* pattern 不区分大小写的正则匹配</p>
<p>​ location /uri 前缀匹配，顺序在正则之后(两种前缀匹配不能同时出现)</p>
<p>​ location / 通用匹配，接收未匹配到其他location的请求。</p>
<p>匹配顺序：</p>
<p>​ 首先会进行精确匹配，然后会进行前缀匹配，具体顺序按指令长度从长到短的顺序依次匹配。</p>
<p>​ 使用正则匹配时，是按照配置文件的顺序依次匹配的。如果不希望前缀匹配后进行正则匹配，那么使用^~。</p>
</blockquote>
<h3 id="url重写">URL重写</h3>
<blockquote>
<p>即对URL的规范化处理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	# 设置需要负载均衡的服务器</span><br><span class="line">	upstream myserver&#123;</span><br><span class="line">		server 192.168.1.20:8080 weight = 1;</span><br><span class="line">		server 192.168.1.20:8081 weight = 2;</span><br><span class="line">		ip_hash;</span><br><span class="line">	&#125;</span><br><span class="line">	# 对应虚拟主机的配置</span><br><span class="line">	server &#123;</span><br><span class="line">		# 监听的端口号</span><br><span class="line">		listen 80;</span><br><span class="line">		# 监听的域名</span><br><span class="line">		server_name localhost;</span><br><span class="line">		</span><br><span class="line">		# 重写URL</span><br><span class="line">		rewrite ^/(.*) http://www.xxxx.com/xxx;</span><br><span class="line"></span><br><span class="line">		# 访问动态资源</span><br><span class="line">		location ~ .*.jsp$ &#123;</span><br><span class="line">			# 将域名请求转发到8080端口交给tomcat处理</span><br><span class="line">			proxy_pass http://myserver</span><br><span class="line">        &#125;	</span><br><span class="line">		# 访问静态资源</span><br><span class="line">		location ~ .*\.(gif|jpg|css)$ &#123;</span><br><span class="line">			root /usr/local/nginx/image;</span><br><span class="line">			// 缓存时间</span><br><span class="line">			expires 3d;</span><br><span class="line">        &#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nginx安装">Nginx安装</h2>
</blockquote>
<blockquote>
<p>在各官网下载相关组件 nginx openssl zlib pcre 等等</p>
<p>以openssl为例 1） 通过rz上传压缩包 2） 通过tar -xvf *.tar.gz 进行解压缩 3）cd openssl-1.1.1d 进行配置检查以及编译 ./config 执行配置检查 make &amp; make install 进行编译和安装</p>
<p>​ 如上过程，适用于zlib和pcre ​ 注意： 对于 pcre而言， 执行检查命令为 ./configure 4) 安装nginx过程中 执行配置检查</p>
<pre><code>./configure --sbin-path=/usr/local/nginx/nginx \
--conf-path=/usr/local/nginx/nginx.conf \
--pid-path=/usr/local/nginx/nginx.pid \
--with-http_ssl_module \
--with-pcre=/usr/local/src/pcre-8.44 \
--with-zlib=/usr/local/src/zlib-1.2.11 \
--with-openssl=/usr/local/src/openssl-1.1.1d</code></pre>
<ol start="5" type="1">
<li>仍然执行 make 以及 make install<br>
</li>
<li>nginx安装成功 ./nginx验证</li>
</ol>
<p>注意事项：nginx服务器，需要虚拟机开放80端口的访问 防火墙配置 （同样适用于开放8080 8081端口） firewall-cmd --list-all 查看当前配置 firewall-cmd --add-service=http --permanent 开放http访问 firewall-cmd --add-port=80/tcp --permanent 开放80端口 firewall-cmd --reload 重启防火墙保存</p>
<p>jdk的安装 1） 解压缩 -- 拷贝目录到 /usr/local/java 2) 更改环境变量 vim /etc/profile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export JAVA_BIN=$JAVA_HOME/bin</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>让环境变量生效 source /etc/profile</li>
<li>验证版本 java -version</li>
</ol>
<p>tomcat的安装 1） 解压缩 -- 拷贝目录到 /usr/local/tomcat 2) 执行启动 ./startup.sh</p>
</blockquote>
]]></content>
      <categories>
        <category>框架入门</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>并发</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/2021/02/20/codeAnalyse/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="数据库连接池">数据库连接池</h1>
<h2 id="常用数据库连接池">常用数据库连接池</h2>
<h3 id="dbcp">DBCP</h3>
<h4 id="常用参数">常用参数</h4>
<blockquote>
<p>initialSize 初始连接数</p>
<p>maxActive 最多可容纳活跃连接数</p>
<p>maxIdle 最大空闲连接数(已创建但未被使用的连接，会被定期回收，回收直到maxIdle数量)</p>
<p>minIdle 最小空闲连接数</p>
<p>maxWait 获取连接的最大等待时间</p>
</blockquote>
<h3 id="c3p0">C3P0</h3>
<h4 id="常用参数-1">常用参数</h4>
<blockquote>
<p>initialPoolSize 初始连接数</p>
<p>maxPoolSize 最大连接数</p>
<p>minPoolSize 最小连接数</p>
<p>acquireIncrement 当没有空闲连接时，一次性创建新连接的数量</p>
<p>maxIdleTime 连接的最大空闲时间，即若一直未使用则自动断掉连接。</p>
</blockquote>
<h3 id="druid">Druid</h3>
<h4 id="常用参数-2">常用参数</h4>
<blockquote>
<p>initialSize 初始连接数</p>
<p>maxActive 最多可容纳活跃连接数</p>
<p>maxIdle 最大空闲连接数(已创建但未被使用的连接，会被定期回收，回收直到maxIdle数量)</p>
<p>minIdle 最小空闲连接数</p>
<p>maxWait 获取连接的最大等待时间</p>
<p>timeBetweenEvictionRunsMillis 间隔多长时间检测是否关闭空闲连接。</p>
<p>minEvictableIdleTime 控制一个连接在资源池中最小的生存时间</p>
<p>maxEvictableIdleTime 控制一个连接在资源池中最大的生存时间</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>2.垃圾收集</title>
    <url>/2021/02/20/JVMKnowledge/2.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="垃圾收集">垃圾收集</h1>
<blockquote>
<p>垃圾收集的步骤：判断对象是否存活(可回收) -&gt;</p>
</blockquote>
<h2 id="判断对象存活">判断对象存活</h2>
<h3 id="引用计数">引用计数</h3>
<blockquote>
<p>在对象中添加一个引用计数器，当一个地方有引用它时计数器值加一；引用失效时，计数器值就减一。计数器为0的对象是不可能再被引用的。</p>
<p>存在循环引用的问题</p>
<p>Java中没有使用。</p>
</blockquote>
<h3 id="可达性分析算法">可达性分析算法</h3>
<blockquote>
<p>基本思路：通过一系列称为GC Roots的根对象作为起始点集，当某个对象到起始点集间没有任何引用链相连时，这个对象就是不可能再被使用的。</p>
<p>Java中固定可作为GC Roots的对象：</p>
<p>​ 在虚拟机栈中引用的对象，如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p>
<p>​ 在方法区类静态属性引用的对象，如Java类引用类型静态变量。</p>
<p>​ 在本地方法栈中JNI(Native方法)引用的对象。</p>
<p>​ Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(NullPointExcepiton、OutOfMemoryError）还有系统类加载器。</p>
<p>​ 所有被同步锁持有的对象。</p>
<p>​ 反应Java虚拟机内部情况的JM XBean、JVMTI中注册的回调、本地代码缓存等。</p>
<p>除了固定GC Roots集合外，根据用户选用的垃圾收集器及当前回收的内存区域不同，还可以有其他对象加入。</p>
<p>被判定为不可达的对象还不会被立即回收。真正回收需要经历至少两个标记过程：</p>
<p>​ 若对象在进行可达性分析后分析没有和GC Roots相连接的引用链，会被第一次标记。随后进行一次筛选，若这个对象没有覆盖finalize方法或该方法已经被虚拟机调用，则没有必要执行finalize方法。</p>
<p>​ 若需要执行finalize方法，则会将对象放入F-Queue队列中，然后自动启用线程执行队列中对象的finalize方法。执行后收集器会对队列中对象进行第二次小规模标记，若对象在finalize方法中重新和引用链上的任何一个对象建立关联，第二次标记时它会被移除即将回收的集合。否则，它通常要被回收。</p>
</blockquote>
<h2 id="回收方法区">回收方法区</h2>
<blockquote>
<p>主要回收废弃的常量和不再使用的类型。</p>
<p>回收常量要求：当前常量进入了常量池，且当前系统没有任何一个对象的值是该常量。</p>
<p>回收类型的条件：</p>
<p>​ 该类所有的实例已经被回收。</p>
<p>​ 加载该类的类加载器被回收。</p>
<p>​ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</blockquote>
<h2 id="引用的概念">引用的概念</h2>
<blockquote>
<p>Java的引用在JDK1.2后分为强引用、软引用、弱引用、虚引用。</p>
<p>强引用：最传统的引用的概念，只有强引用关系存在，垃圾收集器就永远不回收被引用的对象。</p>
<p>软引用：描述一些还有用但非必须的对象。只被软引用关联的对象，在系统将要发生内存溢出异常时，会将这些对象列入回收访问进行第二次回收，若回收还没有足够内存，抛出内存溢出异常。</p>
<p>弱引用：描述非必须的对象，被弱引用关联的对象只能生存到下一次垃圾收集发送为止。</p>
<p>虚引用：最弱的引用关系。无法通过虚引用来取得一个对象实例，为对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p>
</blockquote>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<blockquote>
<p>可以分为引用计数式垃圾收集和追踪式垃圾收集。</p>
<p>Java主流虚拟机中只有追踪式垃圾收集。</p>
</blockquote>
<h3 id="分代收集理论">分代收集理论</h3>
<blockquote>
<p>弱分代假说：绝大多数对象都是朝生夕灭的。</p>
<p>强分代假说：熬过越多次垃圾收集过程的对象越难消灭。</p>
<p>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</p>
<p>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</p>
<p>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</p>
<p>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。</p>
<p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</p>
</blockquote>
<h3 id="标记-清除算法">标记-清除算法</h3>
<blockquote>
<p>先标记所有需要回收的对象，标记完成后统一回收掉所有被标记的对象。</p>
<p>存在的问题：</p>
<p>​ 若Java堆中包含大量对象，且大部分都是需要被回收的，需要进行大量的标记清除动作。</p>
<p>​ 内存空间碎片化，标记、清除后会产生大量不连续的内存碎片。</p>
</blockquote>
<h3 id="标记-复制">标记-复制</h3>
<blockquote>
<p>为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。</p>
<p>半区复制：将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块内存用完了，将还存活着的对象复制到另一块上，然后将已使用过的内存空间一次清理掉。</p>
<p>Appel式回收：分为1块Eden，两块Survivor，分配时使用1块Eden，1块Survivor。回收时将存活的对象放入另一块Survivor中，清理之前使用的Eden和Survivor。内存只浪费了1块Survivor。</p>
<p>优点：当多数对象是可回收的情况时，算法复制的对象少，且分配内存时不用考虑有空间碎片的复杂情况，实现简单。</p>
<p>缺点：浪费了内存空间。</p>
</blockquote>
<h3 id="标记-整理算法">标记-整理算法</h3>
<blockquote>
<p>一般是针对老年代对象。标记完成后不是直接对可回收对象进行清理，而是让所有存活的对象都想内存空间一端移动，然后直接清理掉边界外的内存。</p>
<p>缺点：移动过程耗时较长。</p>
<p>优点：不用考虑内存碎片化问题，降低了内存分配器及内存访问器的复杂度。</p>
</blockquote>
<h2 id="hotpot算法细节">Hotpot算法细节</h2>
<blockquote>
<p>根节点枚举(使用一个OopMap记录)</p>
<p>安全点(到达安全点时将引用关系收集到OopMap，主动式中断和抢占式中断)</p>
<p>安全区域(类似于安全点的扩展)</p>
<p>记忆集和卡表：</p>
<p>​ 记忆集：为了解决对象跨代引用问题，建立的从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<p>​ 卡表：以卡精度实现的记忆集。每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p>
<p>写屏障：为了在机器码的层面将维护卡表的动作放到每个赋值操作之中。赋值操作会在写屏障的覆盖范围中，赋值前部分为写前屏障，赋值后部分为写后屏障，一般来说，都是在写后屏障执行卡表的更新。</p>
<p>卡表带来的高并发问题：伪共享，由于CPU的缓存系统是缓存行为单位存储的，当多线程修改互相独立的变量时，若这些变量刚好共享同一个缓存行，就会互相影响。为了避免这个问题，简单的解决方案是先检查卡表标记，当卡表元素未被标记时才将其标记变脏。</p>
<p>并发的可达性分析：扫描过程时垃圾收集器和用户线程存在并发问题，，可用的解决方法有增量更新(插入引用时记录，扫描完成后以记录的再扫描)、原始快照(删除引用时记录，扫描完成时按记录的再扫描)。</p>
</blockquote>
<h2 id="经典垃圾收集器">经典垃圾收集器</h2>
<h3 id="serial收集器">Serial收集器</h3>
<blockquote>
<p>单线程、简单高效、是所有收集器里额外内存消耗最小的，但是进行垃圾收集时必须暂停其他所有工作线程。</p>
<p>新生代采用复制算法暂停所有用户线程，老年代采用标记-整理算法暂停所有用户线程。</p>
</blockquote>
<h3 id="parnew收集器">ParNew收集器</h3>
<blockquote>
<p>是Serial收集器的多线程并行版本。可以和CMS收集器配合使用。</p>
<p>新生代采用多线程复制算法暂停所有用户线程，老年代采用标记-整理算法暂停所有用户线程。</p>
</blockquote>
<h3 id="parallel-scavenge收集器">Parallel Scavenge收集器</h3>
<blockquote>
<p>基于标记-复制算法实现的新生代收集器，也是能够并行收集的多线程收集器。</p>
<p>而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)，吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。</p>
<p>-XX：MaxGCPauseMillis：允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值，会降低吞吐量。</p>
<p>-XX：GCTimeRatio：值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。</p>
<p>-XX：+UseAdaptiveSizePolicy：一个开关参数，开启后可以自动调节参数。</p>
</blockquote>
<h3 id="serial-old收集器">Serial Old收集器</h3>
<blockquote>
<p>是Serial收集器的老年代版本，是一个单线程收集器，使用标记-整理算法。</p>
</blockquote>
<h3 id="parrallel-old收集器">Parrallel Old收集器</h3>
<blockquote>
<p>是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法。</p>
</blockquote>
<h3 id="cms收集器">CMS收集器</h3>
<blockquote>
<p>是一种以获取最短回收停顿时间为目标的收集器。它是基于标记-清除算法实现的。其运作过程分为4步：</p>
<p>​ 初始标记(需要stop the world)</p>
<p>​ 并发标记</p>
<p>​ 重新标记(需要stop the world)</p>
<p>​ 并发清除</p>
<p>缺点：</p>
<p>​ CMS收集器对处理器资源非常敏感。会因为占据了一部分线程导致应用程序变慢。CMS默认启动回收线程为(处理器核心数量 + 3 )/4。导致处理器核心&lt;4时占用的性能过多。</p>
<p>​ CMS处理器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”，从而引发Full GC。因为标记结束后，很可能产生新垃圾，CMS无法在当次收集时处理，只能留到下次。所以CMS需要预留一部分空间给并发收集时程序运行使用，可以通过-XX：CMSInitiatingOccupancyFraction来调节。</p>
<p>​ 由于CMS是基于标记-清除算法实现的，会产生大量空间碎片。当碎片过多，大对象很难分配，触发Full GC。-XX：+UseCMS-CompactAtFullCollection:开关参数，让CMS触发Full GC时进行碎片整理。</p>
</blockquote>
<h3 id="garbage-first收集器">Garbage First收集器</h3>
<blockquote>
<p>简称G1，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。它是一款主要面向服务端应用的垃圾收集器。</p>
<p>在G1之前的垃圾收集器垃圾收集的范围要么是整个新生代，要么是整个老年代，要么就是Full GC，G1则是面向堆内存任何部分来组成回收集，衡量标准是哪块内存中存放的垃圾数量最多。</p>
<p>它开创了基于Region的堆内存布局。相当于将堆内存划分为大小相同的连续独立区域，每个区域按需要划分出空间。Region中还要特殊的Humongous区域，专门用于存储大对象。G1将大小超过一个Region容量一半的对象就判定为大对象。超过整个Region容量的对象会被存放到n个连续的Region中。</p>
<p>流程：</p>
<p>​ 初始标记</p>
<p>​ 并发标记</p>
<p>​ 最终标记</p>
<p>​ 筛选回收</p>
</blockquote>
<h3 id="低延迟垃圾收集器">低延迟垃圾收集器</h3>
<blockquote>
<p>Shenandoah收集器</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap分析</title>
    <url>/2021/02/20/JavaBasicKnowledge/ConcurrentHashMap/</url>
    <content><![CDATA[<h1 id="concurrenthashmap">ConcurrentHashMap</h1>
<h2 id="初始化">初始化</h2>
<blockquote>
<p>无参构造</p>
<p>带初始容量的构造</p>
<p>带初始容量和负载因子的构造</p>
<p>带初始容量和负载因子及并发级别的构造：并发级别会规定初始化时最少需要的大小</p>
<p>传入Map的构造</p>
</blockquote>
<h2 id="put操作">Put操作</h2>
<blockquote>
<p>先计算key的hash值，然后判断当前是否存在table，若不存在table则调用initTable方法，这里使用了线程相关及CAS</p>
<p>若存在table判断则判断当前桶位是否为null，为null则创建新结点插入，这里使用CAS锁(会有ABA问题)</p>
<p>然后判断当前结点hash值是否为MOVE，(本质上就是判断当前结点是否为ForwardingNode)，若为MOVE则帮助扩容(此时已经有线程在执行扩容操作了)。</p>
<p>若不是则进行插入操作，此时使用synchronized(f)将当前结点锁住，然后再次判断当前结点f是否为需要插入的位置。</p>
<p>插入完成后判断bitcount是否超过TREEIFY_THRESHOLD，若超过则树化。</p>
<p>最后让集合的大小加一，使用了同步方法。</p>
</blockquote>
<h2 id="inittable">initTable</h2>
<blockquote>
<p>sizeCtl为-1时表示在初始化</p>
<p>当table为空或table长度为0时无限循环，判断此时sizeCtl是否小于0，(当一个线程抢夺成功后会让sizeCtl值为-1，其他线程抢占失败后会进入Thread.yield())，抢夺成功的线程则会判断当前sc值是否大于0，若大于0说明初始化时传入了初始容量，使用该容量创建数组，然后将sc值改为当前容量的0.75。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">     Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">             <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">             Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">             table = tab = nt;</span><br><span class="line">             sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         sizeCtl = sc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容">扩容</h2>
</blockquote>
<blockquote>
<p>sizeCtl &lt; 0时表示在扩容</p>
<p>sizeCtl在扩容时高16位表示扩容标识，低16位表示并行扩容线程数+1。</p>
<p>计算扩容戳本质上是计算当前table长度的前导0个数再或运算一个1000 0000 0000 0000。目的是让sizeCtl在移位后变为负数。</p>
<p>帮助扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line"><span class="comment">// 当table不为空且当前结点为ForwardingNode且当前结点存在nextTable时</span></span><br><span class="line"><span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">(nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//产生扩容戳</span></span><br><span class="line"><span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"><span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">      (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">       sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">       transfer(tab, nextTab);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nextTab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的扩容方法：</p>
<p>先利用CPU数和当前table大小同最小区间间隔进行比较，如果小于最小区间间隔则将间隔设置为MIN_TRANSFER_STRIDE即16。</p>
<p>具体扩容则是每个线程抢夺table的一个区间区间大小为设置的区间间隔大小，如[nextIndex - stride，nextIndex - 1]，抢夺区间的操作使用CAS。</p>
<p>每个线程对于对应区间都会进行依次操作，这里使用synchronized来锁住当前操作的结点。</p>
<p>处理完成后，最后一个正在进行的线程会判断设置finishing标志，最终完成扩容，并设置sizeCtl为原table的1.5倍，即新table的0.75倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="tips">tips</h2>
<blockquote>
<p>最大容量为2^30，默认容量16，默认并发级别16(为了兼容之前的版本)，默认负载因子0.75。最大数字大小Integer.MAX_VALUE - 8。</p>
<p>树阈值8，链表阈值6。最小树化容量64(只有大于该值时才会树化)</p>
<p>若key为null，会报空指针异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Java</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>1.JAVA内存管理</title>
    <url>/2021/02/20/JVMKnowledge/1.JAVA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="java内存管理">JAVA内存管理</h1>
<h2 id="java内存区域">Java内存区域</h2>
<h3 id="总览">总览</h3>
<blockquote>
<p>堆+栈+程序计数器</p>
<p>堆: 方法区 + 堆</p>
<p>栈: 虚拟机栈 + 本地方法栈</p>
</blockquote>
<figure>
<img src="/2021/02/20/JVMKnowledge/1.JAVA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Java内存区域.png" alt="Java内存区域"><figcaption aria-hidden="true">Java内存区域</figcaption>
</figure>
<h3 id="各部分的作用">各部分的作用</h3>
<h4 id="程序计数器">程序计数器</h4>
<blockquote>
<p>是当前线程所执行的字节码的行号指示器。各线程均有一个程序计数器。如果执行的是Java方法，则程序计数器记录的值为正在执行的虚拟机字节码的地址。若执行的是本地方法，则此时程序计数器的值为undefined。该区域没有规定任何OutOfMemoryError情况。</p>
</blockquote>
<h4 id="java虚拟机栈">Java虚拟机栈</h4>
<blockquote>
<p>生命周期和线程一致，且是线程私有的。当每个方法被执行时，Java虚拟机栈就会创建一个栈帧来保存局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从被调用到执行完毕的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>局部变量表用于存储各种Java虚拟机的<strong>基本数据类型</strong>、<strong>对象引用</strong>(reference类型，不等同与对象本身，可以是对象起始地址的引用指针，也可以是指向一个代表对象句柄或其他与此对象有关的位置)和<strong>returnAdress类型</strong>(指向了一条字节码指令的地址)。在虚拟机栈中，这些数据类型都是用变量槽来表示的。其中64位的long和double占两个变量槽，其他的均只占一个变量槽。局部变量表的大小在<strong>编译期间</strong>就已经完成，故方法所需栈帧分配的局部变量表空间是完全确定的，且不会发生改变。这里空间是指变量槽数，不是具体字节/比特数。</p>
<p>当调用的方法是非static方法时，局部变量表中第0索引的Slot变量槽默认是this关键字指向的对象。</p>
<p>可能出现的异常：</p>
<p>​ StackOverflowError：线程请求栈深度超过虚拟机允许的深度。</p>
<p>​ OutOfMemoryError：当虚拟机栈容量可以动态拓展时，不能申请到足够的内存。</p>
</blockquote>
<h4 id="本地方法栈">本地方法栈</h4>
<blockquote>
<p>和虚拟机栈类似，虚拟机栈为虚拟机执行Java方法服务，而本地方法栈是为虚拟机使用到的本地方法服务。</p>
</blockquote>
<h4 id="java堆">Java堆</h4>
<blockquote>
<p>Java堆是虚拟机所管理的内存中最大的一块。它是被所有线程共享的一块内存区域，在虚拟机启动时创建。java堆的唯一目的就是存放对象实例。它也是垃圾收集器管理的内存区域。大部分垃圾收集器都是基于分代收集理论设计的。</p>
<p>从分配内存的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区。</p>
<p>可能出现的异常：</p>
<p>​ OutOfMemoryError：Java堆中没有内存完成实例分配，且堆无法再拓展。</p>
</blockquote>
<h4 id="方法区">方法区</h4>
<blockquote>
<p>HotSpot：JDK8后使用在本地内存中实现的元空间来代替JDK7中永久代还剩余的内容，JDK6之前使用永久代来实现方法区。</p>
<p>方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>这个区域的回收目标主要是针对常量池的回收和对类型的卸载。</p>
<p>可能出现的异常：</p>
<p>​ OutOfMemoryError：方法区无法满足新的内存分配需求。</p>
</blockquote>
<h5 id="运行时常量池">运行时常量池</h5>
<blockquote>
<p>运行时常量池是方法区的一部分。该部分用于存放编译器生成的各种字面量与符号引用即常量池表。</p>
</blockquote>
<h4 id="直接内存">直接内存</h4>
<blockquote>
<p>直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。</p>
<p>如JDK1.4引入的NIO可以使用Native函数分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作。</p>
<p>本机的直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存大小及处理器寻址空间的限制。</p>
</blockquote>
<h2 id="hotspot虚拟机对象相关内容">HotSpot虚拟机对象相关内容</h2>
<h3 id="对象创建">对象创建</h3>
<blockquote>
<p>步骤分为：类加载检查 -&gt; 分配内存 -&gt; 初始化 -&gt; 对象设置 -&gt; 等待执行构造函数</p>
<p>类加载检查：当Java虚拟机遇到一条字节码new指令时，首先检查这个指令的参数是否可以从常量池地位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化过。若没有执行相应类的类加载过程。</p>
<p>分配内存：类加载完成后对象所需内存大小可以完全确定，分配内存的方法分为指针碰撞法和空闲列表法。</p>
<p>​ 指针碰撞法：将Java堆的内存视为绝对规整，使用过的内存在一边，未使用过的内存在另一边，分配内存时只需要将指针朝未使用过的内存那边移动即可。该方法要求垃圾收集器需要有空间压缩整理能力。</p>
<p>​ 空闲列表法：Java堆的内存中使用过的内存和未使用过的内存交错在一起，需要维护一个列表记录哪些内存块可用。</p>
<p>分配内存时需要考虑并发问题：即当A利用指针分配内存但还为修改指针位置时，B也使用原来的指针分配内存。解决该问题可以使用CAS加失败重试或把内存操作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为TLAB(本地线程分配缓冲)，只有本地缓冲区的内存用完了，分配新缓冲区时才需要同步锁定。</p>
<p>初始化：虚拟机将分配到的内存空间都初始化为0值。</p>
<p>对象设置：将对象信息如对象是哪个类的实例、如何找到类的元数据信息、对象的GC分代年龄等存入对象的对象头中。</p>
<p>等待执行构造函数：虚拟机等到执行了<init>()方法，完成对对象的全部初始化，此时对象才算被完全的构造出来。</init></p>
</blockquote>
<h3 id="对象内存布局">对象内存布局</h3>
<blockquote>
<p>存储布局划分为三个部分：对象头、实例数据、对齐填充(padding)</p>
<p>对象头可以分为两类：</p>
<p>​ 一类存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。被称为Mark Word。</p>
<p>​ 另一类为类型指针，即对象指向它的类型元数据的指针。Java虚拟机通过这个指针来确定该对象是哪个类的实例。若对象为Java数组，对象头中还要一块用于记录数组长度的数据。</p>
<p>实例数据：即对象真正存储的有效信息，无论是从父类继承还是子类自己定义的字段。存储顺序可以通过(-XX:FieldsAllocationStyle参数)及字段在源码中定义顺序来调整。HotSpot默认分配顺序会将相同宽度的字段分配到一起存放，如longs/doubles。</p>
<p>padding：即填充部分，无意义，只是用于将数据对齐。</p>
</blockquote>
<h3 id="对象访问定位">对象访问定位</h3>
<blockquote>
<p>Java程序会通过栈上的reference数据来操作栈上的具体对象。</p>
<p>主流的访问方式分为句柄和直接指针：</p>
<p>​ 句柄：Java堆中可能划分出一块内存作为句柄池，reference存储的就是对象的句柄地址，而句柄包含对象实例数据与类型数据各自具体的地址信息。</p>
<p>​ 直接指针：reference存储的就是对象地址，访问对象本身不需要多一次间接访问。</p>
<p>​ 两者的优点：句柄访问的优势在于reference存储的是稳定的句柄地址，对象被移动(垃圾回收时对象常常需要被移动)时只需要改变句柄中实例数据指针即可。直接指针的优势在于速度更快，减少了一次指针定位的开销。</p>
</blockquote>
<h2 id="触发异常的情况">触发异常的情况</h2>
<h3 id="java堆内存的outofmemoryerror异常">Java堆内存的OutOfMemoryError异常</h3>
<blockquote>
<p>不断创建对象且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象。</p>
</blockquote>
<h3 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h3>
<blockquote>
<p>-Xss设置栈容量。</p>
<p>1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。</p>
<p>创建太多线程也会导致OutOfMemoryError异常。</p>
</blockquote>
<h2 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出</h2>
<blockquote>
<p>运行时常量池，从JDK7开始后原本存放到永久代的字符串常量池被移动到Java堆中。</p>
<p>-XX：PermSize和-XX：MaxPermSize限制永久代大小。</p>
<p>方法区溢出会在运行时产生大量的类时出现，OutOfMemoryError。</p>
</blockquote>
<h3 id="本机直接内存溢出">本机直接内存溢出</h3>
<blockquote>
<p>大小默认与Java堆最大值一致。可以通过-XX：MaxDirectMemorySize参数指定。</p>
<p>直接或间接(NIO)使用了太多是Unsafe::allocateMemory()分配过多的直接内存会触发OutOfMemoryError异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap分析</title>
    <url>/2021/02/20/JavaBasicKnowledge/HashMap/</url>
    <content><![CDATA[<h1 id="hashmap">HashMap</h1>
<h2 id="hashmap初始化">HashMap初始化</h2>
<blockquote>
<p>初始化时可以设置初始大小和负载因子。默认负载因子0.75，默认容量为16。</p>
<p>HashMap的threshold为负载因子 * 容量。</p>
</blockquote>
<h2 id="hashmap的get方法">HashMap的get方法</h2>
<blockquote>
<p>就是根据传入的key求出对应的hash值，然后根据hash值和数组长度-1进行&amp;运算获得对应下标位置，获取位置后判断当前结点是树结点还是链表结点，从而采取不同的处理方式。</p>
</blockquote>
<h2 id="hashmap的remove方法">HashMap的remove方法</h2>
<blockquote>
<p>根据传入的key求出对应hash值，找到对应桶位，然后根据对应结点的类型为树结点还是链表结点，根据不同结点的类型执行不同的删除操作。链表需要改变指向，树则需要再次平衡。</p>
</blockquote>
<h2 id="hashmap的resize方法">HashMap的resize方法</h2>
<blockquote>
<p>先判断当前是否有table，如果没有table且未设置初始大小，则初始化容量为默认值，阈值为默认值 * 负载因子的数组。若设置了初始大小则初始化容量为设置的大小的二次幂值的数组。</p>
<p>若存在table，先判断旧容量是否大于最大值，若大于则设置阈值为Integer.MAX_VALUE，返回table，否则判断旧容量左移1位后是否不超过最大容量且判断当前容量是否超过默认容量16，若不超过最大容量且当前容量超过默认容量则将旧阈值左移一位。否则将计算newCap * loadFactor，判断新容量是否大于最大容量，若不大于则使用newCap * loadFactor作为新阈值，使用newCap作为数组的新容量。</p>
<p>创建完新数组后，需要将旧table的数据复制到新table之中。</p>
<p>复制的过程：</p>
<p>​ 遍历桶位，若某个桶位只有一个元素则直接根据hash值&amp;新数组容量-1判断需要插入到新数组的什么位置。</p>
<p>​ 若该元素是树结点则使用spilt方法，插入到新数组。</p>
<p>​ 若桶位存在多个链表结点，则大致流程为使用4个指针来记录新旧两个数组的头尾链表位置。即先记录头位置，然后将头位置赋值给尾位置，利用尾位置不断连接结点，最后将头结点赋值给桶位元素。</p>
</blockquote>
<h2 id="hashmap的put方法">HashMap的put方法</h2>
<blockquote>
<p>获取已存在的table，若当前table不存在则resize一个table，若存在则找到对应桶位，根据结点类型采取不同的插入操作，对于链表，插入完成后还会判断当前桶位元素个数是否大于树化阈值，若大于则将桶树化。对于树结点，插入时需要进行平衡。最后插入完成后，判断当前HashMap元素个数是否大于总阈值，若大于则resize扩容。</p>
</blockquote>
<h2 id="tips">tips</h2>
<blockquote>
<p>jdk8后，HashMap红黑树和链表转化是根据泊松分布的，链表转化为树阈值为8，树退化为链表阈值为6。</p>
<p>且红黑树的排序是根据节点的hashcode大小，对于实现了Comparable接口的则使用compare方法来比较。</p>
<p>hashmap默认负载因子0.75，默认容量为16，最大容量为2^30次方，且容量必须为2的次幂大小，因为使用位运算来执行取模操作。</p>
<p>hashmap在操作时会自增modcount，若在遍历时对hashmap执行了操作，则会由于modcount改变而抛出异常。</p>
<p>HashMap线程非安全，HashTable线程安全，ConcurrentHashMap线程安全。</p>
<p>HashTable本质是上是将各方法都加上了synchronized。</p>
</blockquote>
<h2 id="面试题">面试题</h2>
<h3 id="key为null时执行put操作数据放在哪个桶位">key为null时，执行put操作，数据放在哪个桶位？</h3>
<blockquote>
<p>key为null时HashMap求出的hash值为0，故放在第0个桶位。</p>
</blockquote>
<h3 id="hashmap的hash函数为什么需要将hash值移位并异或">HashMap的hash函数为什么需要将hash值移位并异或？</h3>
<blockquote>
<p>注释里有说，为了让高位的hash值对数据产生影响。</p>
</blockquote>
<h3 id="为什么hashmap内部的散列表数组长度一定是2的次方数">为什么HashMap内部的散列表数组长度一定是2的次方数？</h3>
<blockquote>
<p>让查找位置时使用数组长度-1的值会对应2进制的000011111111，后位均为1，提高HashMap的散列性。</p>
</blockquote>
<h3 id="hashmap内部的散列表结构什么时候初始化初始化大小有几种情况">HashMap内部的散列表结构，什么时候初始化？初始化大小有几种情况？</h3>
<blockquote>
<p>构造方法共四种：无参构造、传入初始容量、传入初始容量及负载因子、传入Map</p>
<p>传入Map时会调用resize会初始化。</p>
<p>resize时会初始化。</p>
</blockquote>
<h3 id="hashmap为什么需要扩容扩容又是如何实现的">HashMap为什么需要扩容，扩容又是如何实现的？</h3>
<blockquote>
<p>因为数组过小，会导致插入时会插入到同一个桶位导致查询效率下降，故用空间换时间的方式优化。</p>
</blockquote>
<h3 id="jdk8为什么hashmap引入红黑树">JDK8为什么HashMap引入红黑树？</h3>
<blockquote>
<p>因为数据增大时链表的查询速度低。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>并发相关内容</title>
    <url>/2021/02/20/JavaBasicKnowledge/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="并发相关">并发相关</h1>
<h2 id="可见性">可见性</h2>
<blockquote>
<p>由于内存读取速度和CPU处理速度不匹配的问题，所以往往在CPU和内存之间存在缓存机制，而多个线程执行程序时，会先从内存中读取数据放入CPU缓存中，并且在程序执行的过程中往往不会对数据进行及时更改。导致两个线程之间的数据存在不可见的问题。如子线程使用一个boolean变量来循环，此时主线程改变了该变量，但子线程却不一定会退出循环。</p>
<p>java中使用volatile解决这个问题。</p>
</blockquote>
<h2 id="原子性">原子性</h2>
<blockquote>
<p>一系列操作是不可拆分的。</p>
<p>如count++指令；</p>
<p>会对应汇编的三条指令：</p>
<p>​ count值加载到CPU寄存器</p>
<p>​ 寄存器中+1操作</p>
<p>​ 结果写入操作</p>
</blockquote>
<h2 id="有序性">有序性</h2>
<blockquote>
<p>编译时会进行优化。</p>
<p>int a = 6;</p>
<p>int b = 10;</p>
<p>优化时可能顺序交换了，导致问题。如下可能导致操作1和操作2互换位置，操作3和操作4互换位置，从而使得x = y = 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            a = <span class="number">1</span>; <span class="comment">//操作1</span></span><br><span class="line">            x = b; <span class="comment">//操作2</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            b = <span class="number">1</span>; <span class="comment">//操作3</span></span><br><span class="line">            y = a; <span class="comment">//操作4</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(a + <span class="string">&quot;---&quot;</span> + b + <span class="string">&quot;---&quot;</span> + x + <span class="string">&quot;---&quot;</span> + y + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="happens-before原则">happens-before原则</h2>
</blockquote>
<blockquote>
<p>happens-before原则定义如下： 1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</p>
<p>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</p>
<p>管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</p>
<p>volatile变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</p>
<p>线程启动规则：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p>
<p>线程终止规则：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</p>
<p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</p>
<p>传递规则：这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</p>
<p>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</p>
</blockquote>
<h2 id="线程池">线程池</h2>
<blockquote>
<p>可缓存线程池 Executors.newCachedThreadPool()</p>
<p>​ 无上限</p>
<p>定长线程池 Executors.newFixedThreadPool()</p>
<p>​ 最大线程数即为设定的线程数</p>
<p>单线程的线程池 Executors.newSingleThreadExecutor()</p>
<p>​ 只容许一个线程</p>
<p>计划任务线程池 Executors.newScheduledThreadPool()</p>
<p>​ 定时任务。</p>
<p>自定义线程池 ExecutorService myPool = new ThreadPoolExecutor();</p>
<p>线程池可以传入callable对象和runnable对象。</p>
<p>runnable没有返回值和异常，callable可以有返回值也可以抛出异常</p>
<p>submit方法可以获得future对象，用于获取线程返回值和异常。</p>
</blockquote>
<h4 id="底层实现">底层实现</h4>
<blockquote>
<p>调用poolExecutor.execute(t1);方法时会执行的逻辑如下</p>
<p>当当前线程数小于核心线程数数，调用addWorker方法</p>
<p>addWorker方法主要判断了当前线程池状态，当线程池状态符合条件(处于Runing且数量小于规定数量时)，利用CAS操作判断是否可以添加新线程。</p>
<p>若成功添加则调用new Worker创建新线程。然后利用ReentrantLock，锁定，并判断当前线程池状态是否为running，同时检查是否已经启动，若为running且未启动，则将worker添加到workers中(本质是个HashSet<Worker>)，更新largestPoolSize，然后启动线程。返回结果。</Worker></p>
<p>这里启动线程的方法调用的实际上是worker的runWorker方法，该方法会判断(task != null || (task = getTask()) != null)，当当前worker存在任务或任务队列中存在任务时，worker会依次执行beforeExecute，task.run()，afterExecute方法，这个流程会加锁(使用Acquire和Release)</p>
<p>getTask方法则本质上会使用阻塞队列的take方法，阻塞获取任务，或调用设定了超时时间的poll方法，获取任务。</p>
<p>当没有可执行任务时，processWorkerExit，从workers中移除worker。</p>
<p>当当前线程数大于核心线程数，会判断当前线程池状态是否为runnning，且能否成功添加到任务队列中。若成功入队，再次检查当前线程池状态是否符合running，若不是则移除任务。</p>
<p>若无法入队，且当前线程数大于核心线程数，则尝试addWorker，若还不成功则reject任务，reject方式为自己选择的策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="juc工具">juc工具</h2>
</blockquote>
<h3 id="countdownlatch">CountDownLatch</h3>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>在线程中调用cdl.countdown()</p>
<p>主线程使用cdl.await()</p>
<p>只有当cdl变为0时才能触发await后的操作。</p>
</blockquote>
<h3 id="cyclicbarrier">CyclicBarrier</h3>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>先设置栅栏大小，然后在线程中调用cb.await()可以同时等待设置大小个数的线程执行完操作再运行。可以重复使用。</p>
<p>也可以如下初始化，在等待完成时自动执行runnable的run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="semaphore">Semaphore</h3>
<blockquote>
<p>信号量，通过acquire方法和release实现类似锁的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>
<h3 id="phaser">Phaser</h3>
</blockquote>
<blockquote>
<p>可以随时注册，注销</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">9</span>);</span><br><span class="line"><span class="comment">//执行register后，上限值从9变为10</span></span><br><span class="line">phaser.register();</span><br><span class="line">phaser.arriveAndAwaitAdvance();</span><br><span class="line"><span class="comment">//执行以下方法后，下一轮的上限值从10变为9</span></span><br><span class="line">phaser.arriveAndDeregister();</span><br></pre></td></tr></table></figure>
<p>当最后一个线程到达10时，线程会同时唤醒并运行。同时触发onAdvance方法，该方法可以通过自己创建一个phaser类继承Phaser，重写onAdvance方法，然后创建phaser时传入自己的类，即可。</p>
</blockquote>
<h3 id="exchanger">Exchanger</h3>
<blockquote>
<p>线程之间数据交换。需要两个线程都调用此方法，不然会阻塞。只能用于两个线程之间。</p>
<p>exchanger.exchange("xxxx")；</p>
<p>Exchanger<String> exchanger 创建时需要使用泛型。</String></p>
</blockquote>
<h2 id="forkjoin并行计算框架">ForkJoin并行计算框架</h2>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Long time1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// fork 拆解, join 合并</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(<span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">100000000</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get().toString());</span><br><span class="line"></span><br><span class="line">            Long time2 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(time2 - time1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(end - start &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 拆解</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt;= end ; i++)&#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 拆分</span></span><br><span class="line">                <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">                CountTask leftTask = <span class="keyword">new</span> CountTask(start, mid);</span><br><span class="line">                CountTask rightTask = <span class="keyword">new</span> CountTask(mid + <span class="number">1</span>,end);</span><br><span class="line">                <span class="comment">// 拆分任务</span></span><br><span class="line">                invokeAll(leftTask,rightTask);</span><br><span class="line"><span class="comment">//                leftTask.fork();</span></span><br><span class="line"><span class="comment">//                rightTask.fork();</span></span><br><span class="line">                <span class="comment">//获取结果</span></span><br><span class="line">                <span class="keyword">long</span> leftResult = leftTask.join();</span><br><span class="line">                <span class="keyword">long</span> rightResult = rightTask.join();</span><br><span class="line"><span class="comment">//                System.out.println(leftResult + &quot;----&quot; + rightResult);</span></span><br><span class="line">                sum = leftResult + rightResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拆解任务的阈值,如何定义一个任务是最小任务</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="threadlocal">ThreadLocal</h2>
</blockquote>
<blockquote>
<p>线程本地变量，创建一个线程独立的变量。</p>
<p>底层实现的原理：本质上是一个线程中存在一个ThreadLocalMap，用于存储ThreadLocal，该map的key为创建的ThreadLocal对象，而非Thread本身</p>
<p>ThreadLocal对象使用结束后需要调用remove方法，使其从map中被移除，避免在线程复用时拿到了上次的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"> Thread t = Thread.currentThread();</span><br><span class="line"> ThreadLocalMap map = getMap(t);</span><br><span class="line"> <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">     map.set(<span class="keyword">this</span>, value);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Thread t = Thread.currentThread();</span><br><span class="line"> ThreadLocalMap map = getMap(t);</span><br><span class="line"> <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">     ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">         T result = (T)e.value;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized">synchronized</h2>
</blockquote>
<blockquote>
<p>同步普通方法，同步的是this</p>
<p>同步静态方法，同步的是类</p>
<p>同步代码块</p>
</blockquote>
<h2 id="reentrantlock">ReentrantLock</h2>
<blockquote>
<p>可重入锁，即自己加了锁还可以再次加锁，如a.lock(); xxxx; a.lock(); a.unlock(); a.unlock();</p>
<p>tryLock() 返回是否拿到锁了。</p>
</blockquote>
<h2 id="readwritelock">ReadWriteLock</h2>
<blockquote>
<p>读写锁一般如下使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">lock.readLock().lock();</span><br><span class="line">lock.writeLock().lock();</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Object类分析</title>
    <url>/2021/02/20/JavaBasicKnowledge/Object/</url>
    <content><![CDATA[<h1 id="object类">Object类</h1>
<blockquote>
<p>Object类是Java中未指定父类的类的默认继承类，也可以说是所有类的祖先。本文档编写目的为通过查看Java源码来加强自己对Object类的理解。不涉及native实现的方法。</p>
</blockquote>
<h4 id="registernatives">registerNatives()</h4>
<blockquote>
<p>native实现，目的是在底层创建对应的java本机函数使JVM找到native方法</p>
</blockquote>
<h4 id="getclass">getClass()</h4>
<blockquote>
<p>返回当前对象运行时对应的类对象，且这个类是静态类型擦除后的结果。如T-&gt;Object;List<String>-&gt;List</String></p>
</blockquote>
<h4 id="hashcode">hashCode()</h4>
<blockquote>
<p>返回当前对象的hash值，在同一个程序执行中，约定当对象相同时即执行equals方法比较的信息不被更改时，不管调用几次hashcode方法，均要返回相同的值。但不要求不同程序产生相同的hashcode</p>
<p>如果两个对象可通过equals方法判定相同，则调用hashcode方法会产生两个相同的值。</p>
<p>如果两个对象通过equals方法判定不同，也不要求hashcode方法产生两个不同的值，但如果产生不同的值会提升哈希表的性能。</p>
<p>如果可以的话，不同对象应该有不同的hash值，这个通常可以根据将对象在内存中的地址转化为整数来实现，但不强制要求。</p>
</blockquote>
<h4 id="equals">equals()</h4>
<blockquote>
<p>判断某些对象是否equals to调用该方法的对象。</p>
<p>实现了非空对象引用上的等价关系判断。</p>
<p>四个特性:自反、对称、传递、一致。</p>
<p>自反: x.equals(x) == true</p>
<p>对称: x.equals(y) == y.equals(x)</p>
<p>传递: x.equals(y), y.equals(z) ------&gt; x.equals(z)</p>
<p>一致: 只要用于equals比较的信息不被改变，则不管调用几次equals方法其值总是不变的。</p>
<p>非空对象引用同null比较值总是为false。</p>
<p>对象之间equals比较只有两个对象是完全相同即地址一致时才会返回true。</p>
<p>为了维持hashcode的原则，在重写equals方法的时候，往往需要重写hashcode方法。</p>
</blockquote>
<h4 id="clone">clone()</h4>
<blockquote>
<p>根据对象的类复制一个对象的副本。</p>
<p>往往有</p>
<p>​ x.clone() != x;</p>
<p>​ x.clone().getClass() == x.getClass()</p>
<p>​ x.clone.equals(x) == true</p>
<p>​ 通常返回的clone对象都是调用super.clone得到的。</p>
<p>​ clone的对象需要和被clone的对象相互独立。这便要求对被clone对象中所有可变属性进行复制，并用副本的引用替换对这些对象的引用。</p>
<p>Object类的clone方法</p>
<p>​ 首先需要继承Cloneable接口。数组类型默认实现了Cloneable接口，且T类型的数组clone的结果的类型为T，需要注意的时，数组clone是直接复制原数组的值即对象引用只是将引用拷贝了，故为浅拷贝。</p>
<p>Object对象没有实现Cloneable接口，故对Object对象使用clone会产生异常。CloneNotSupportedException</p>
</blockquote>
<h4 id="tostring">toString()</h4>
<blockquote>
<p>返回对象的字符串表示形式。往往需要重写这个方法。</p>
<p>这个方法的默认表现为“类名+@+hashcode的十六进制表示”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="notify">notify()</h4>
<blockquote>
<p>唤醒正在wait()该线程所拥有的对象的一个线程。如果有多个线程都在wait该对象，则随机唤醒一个线程，由具体实现决定。</p>
<p>被唤醒的线程只有在对象没有被锁定的情况下才能执行。且被唤醒的线程仍然需要以通常的方式同其他线程竞争对象的使用权，没有其他特权。</p>
<p>该方法只能由当前具有对象使用权的线程调用，获取对象使用权的方式</p>
<p>​ 1.执行对象的synchronize修饰的方法</p>
<p>​ 2.执行synchronize修饰的代码段。</p>
<p>​ 3.执行synchronize修饰的静态方法。</p>
<p>未拥有对象monitor的线程调用会抛出IllegalMonitorStateException异常。</p>
</blockquote>
<h4 id="notifyall">notifyAll()</h4>
<blockquote>
<p>唤醒正在wait()该线程所拥有的对象的所有线程。</p>
</blockquote>
<h4 id="waitlong-timeout">wait(long timeout)</h4>
<blockquote>
<p>让当前线程等待一段时间，直到被notify/notifyAll/一段时间过后唤醒。</p>
<p>调用该方法的线程必须有对象的monitor。</p>
<p>该方法会让线程进入该对象的等待集中，然后放弃对该对象的所有同步声明。 出于线程调度目的，该线程被禁用，并且在发生以下四种情况之一之前一直处于休眠状态：</p>
<ol type="1">
<li>某些线程调用了notify方法并恰好唤醒该线程。</li>
<li>某些线程调用了notifyAll方法。</li>
<li>某些线程调用了interrupt方法。</li>
<li>一段特定时间过去。若为设置特定时间线程会等到被notify为止。</li>
</ol>
<p>从wait方法返回的对象和线程的同步状态会和调用该方法时的状态完全相同。</p>
<p>存在虚假唤醒(spurious wakeup)的问题需要在while中调用wait来避免。</p>
<p>如果该线程在等待之前，或等待期间被另一个线程调用该线程的interrupt()方法，那么当被interrupt线程获得锁之后，会立刻抛出InterruptedException异常，我们可以对这个异常进行捕获，然后处理，以实现线程的唤醒和通信。</p>
<p>wait方法将当前线程放入该对象的等待集中，只会解锁该对象，若当前线程还锁定了其他对象，那么这些对象不会被解锁。(死锁)</p>
</blockquote>
<h4 id="waitlong-timeout-int-nanos">wait(long timeout, int nanos)</h4>
<blockquote>
<p>同一个参数的wait基本一致，但可以输入纳秒级的精度。实际上只是nanos大于0直接让timeout++而已。</p>
</blockquote>
<h4 id="wait">wait()</h4>
<blockquote>
<p>不支持超时自动唤醒。相当于wait(0)</p>
</blockquote>
<h4 id="finalize">finalize()</h4>
<blockquote>
<p>当资源不可达时GC会自动调用对象的finalize方法</p>
<p>这个方法内部可以执行任何操作，包括让这个对象重新可达。但往往只是执行清除操作，如中断I/O连接。</p>
<p>Java编程语言对于所有的对象都不能够保证哪个线程会调用它的finalize方法。然而可以保证一点，调用终结方法的线程必然不会被任何用户可见的同步锁锁住。如果一个没有被捕获的异常在执行终结方法时被抛出，异常会被忽略并且哪个对象的终结过程会被终止。</p>
<p>调用该方法后，java虚拟机会再次判断对象是否可达，若仍不可达对象往往会被摧毁。</p>
<p>finalize()方法不会调用多次。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基本类</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程相关</title>
    <url>/2021/02/20/JavaBasicKnowledge/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程">多线程</h1>
<h2 id="进程和线程">进程和线程</h2>
<blockquote>
<p>进程是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位。</p>
<p>通常一个进程中包含多个线程，一个进程至少含一个线程。线程是CPU调度和执行的单位。</p>
</blockquote>
<h3 id="java创建线程的方式">JAVA创建线程的方式</h3>
<blockquote>
<ol type="1">
<li>继承Thread类，重写run方法。调用是使用start方法调用，若使用run方法调用则变为单线程。</li>
<li>实现runnable接口，重写run方法，执行线程需丢入runnable接口实现类，调用start方法。(避免使用继承)</li>
<li>实现callable接口，需要返回值类型，重写call方法，需要抛出异常。(可以返回结果，可以抛出异常)<img src="/2021/02/20/JavaBasicKnowledge/%E5%A4%9A%E7%BA%BF%E7%A8%8B/实现callable.png" alt="实现callable"></li>
</ol>
</blockquote>
<h2 id="java线程的状态">Java线程的状态</h2>
<blockquote>
<p>NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</p>
<p>NEW：线程还没有启动。</p>
<p>RUNNABLE：线程已经在jvm中运行了，但可能还在等待操作系统的处理器之类的资源。</p>
<p>BLOCKED：线程等待monitor lock。</p>
<p>WAITING：正在等待另一个线程执行的状态。</p>
<p>TIMED_WAITING：有着指定特定等待时间等待另一个线程执行的状态。</p>
<p>TERMINATED：线程终止，线程已经结束执行。</p>
<p>线程分为用户线程和守护线程(Daemon)，虚拟机必须确保用户线程执行完毕，虚拟机不用等待守护线程执行完毕。可以通过调用线程的setDaemon(true)，将某个线程变为守护线程</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="数据链路层">数据链路层</h1>
<h2 id="数据链路层基本概念">数据链路层基本概念</h2>
<blockquote>
<p>数据链路层的需要解决的问题:</p>
<p>​ 向网络层提供一个定义良好的服务接口。</p>
<p>​ 处理传输错误。</p>
<p>​ 调节数据流，保证慢速的接收方不会被快速的发送方淹没。</p>
<p>使用的信道类型:点对点信道、广播信道</p>
<p>链路:一条点到点的物理线路段，中间没有任何其他的点。</p>
<p>数据链路:除物理线路外，还要有通信协议来控制数据的传输，而实现这些协议的硬件和软件加入到链路上就构成了数据链路。</p>
<p>最常用的方法就是使用适配器(即网卡)来实现这些协议的硬件和软件，一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
</blockquote>
<h2 id="帧">帧</h2>
<blockquote>
<p>数据链路层传送的是帧</p>
</blockquote>
<h2 id="数据链路层的三个基本问题">数据链路层的三个基本问题</h2>
<h3 id="封装成帧">封装成帧</h3>
<blockquote>
<p>就是在一段数据的前后分别添加首部(SOH)和尾部(EOT)。即形成帧首部+帧的数据部分+帧尾部的结构，帧首部和尾部的重要作用就是帧定界。其中帧的数据部分一般不能超过1500(最大传输单元MTU)。为什么最大一般为1500？这是网络带宽和传输效率的统一决定的，MTU太大导致传输时间过长，MTU过小会导致传输效率不高(因为帧的头尾需要占14 + 4个字节)。</p>
<p>接收方会判断收到的帧是否含有头尾部分，若无此部分则会丢弃该数据帧。</p>
</blockquote>
<h3 id="透明传输只知道数据但不知道数据是如何传输的">透明传输(只知道数据但不知道数据是如何传输的)</h3>
<blockquote>
<p>帧的头尾是使用ASCII码的可打印字符集之外的字符组成，若传输的数据不是仅由ASCII码的可打印字符组成时会导致帧的数据部分中可能出现帧尾，会导致接收方提前判断帧结束，且丢弃部分数据。</p>
<p>解决方法:发送端的数据链路层会在数据出现SOH与EOT的前面插入一个字符“ESC"用于转义，若转义字符中也出现在数据中则应该在转义字符前插入一个转义字符，接收端在将数据传送给网络层时会删除其中用于转义的字符。</p>
</blockquote>
<h2 id="差错控制">差错控制</h2>
<blockquote>
<p>比特差错:1可能变为0,0可能变为1。</p>
<p>误码率:传输错误的比特占所传输比特总数的比率称为误码率。</p>
<p>循环冗余检验(CRC)可以做到无差错接收。检验到有差错的帧就丢弃。CRC是一种无比特差错，而不是无传输差错的检测机制。</p>
<p>可靠传输还需要确认和重传机制</p>
</blockquote>
<h2 id="点到点的数据通信">点到点的数据通信</h2>
<blockquote>
<p>PPP协议是全世界使用最多的数据链路层协议</p>
<p>PPP协议的组成部分(由顶到底)</p>
<p>​ NCP网络控制协议</p>
<p>​ LCP链路控制协议</p>
<p>​ 类似于HDLC高级数据链路控制协议，但PPP面向字节而不是面向比特</p>
<p>PPP协议应该满足的要求:</p>
<p>​ 简单、封装成帧、支持多种网络层协议、多种类型链路、差错检测、检测连接状态、最大传送单元、网络层地址协商、数据压缩协商</p>
<p>PPP协议不需要满足的要求:</p>
<p>​ 纠错、流量控制、序号、多点线路、半双工或单工链路</p>
<p>PPP协议的帧格式:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">F(7E)</th>
<th style="text-align: center;">A(FF)</th>
<th style="text-align: center;">C(03)</th>
<th style="text-align: center;">协议</th>
<th style="text-align: center;">消息部分(IP数据报)</th>
<th style="text-align: center;">FCS</th>
<th style="text-align: center;">F(7E)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">一个字节</td>
<td style="text-align: center;">一个字节且为固定值</td>
<td style="text-align: center;">一个字节且为固定值</td>
<td style="text-align: center;">用于表示消息字段中是什么类型的消息</td>
<td style="text-align: center;">不超过1500</td>
<td style="text-align: center;">两个字节</td>
<td style="text-align: center;">一个字节</td>
</tr>
</tbody>
</table>
<p>实现透明传输的方式:</p>
<p>​ 如果是字节传递数据时可以通过插入转义字符并在转义字符0x7D后的一个字符用0x20异或来实现透明传输。</p>
<p>​ 如果采用同步通信，比特流传递数据时，通过零比特填充法，连续5个1在其中插入0。</p>
<p>不使用序号和确认机制的原因</p>
<p>​ 在数据链路层出现的差错的概率不大时使用比较简单的PPP协议较为合理。</p>
<p>​ 在因特网环境下，PPP的信息字段放入的数据是IP数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</p>
<p>​ 帧检验序列FCS字段可保证无差错接受。</p>
</blockquote>
<h2 id="使用广播信道的数据链路层">使用广播信道的数据链路层</h2>
<h3 id="局域网的拓扑">局域网的拓扑</h3>
<blockquote>
<p>星型网、总线网、环形网、树型网</p>
</blockquote>
<h3 id="局域网的特点与优点">局域网的特点与优点</h3>
<blockquote>
<p>主要特点:网络为一个单位所拥有且地理位置和站点数目均有限。</p>
<p>主要优点:具有广播功能，从一个站点可以很方便地访问全网。局域网的主机可以共享连接在局域网上的各种硬件和软件资源。</p>
<p>便于系统的拓展和逐渐演变，各设备的位置可以灵活调整和改变。</p>
<p>提高了系统的可靠性、可用性和生存性。</p>
</blockquote>
<h3 id="以太网通信使用的协议-----csmacd协议">以太网通信使用的协议-----CSMA/CD协议</h3>
<blockquote>
<p>CSMA/CD协议特点:</p>
<p>多点接入:表示许多计算机以多点接入的方式连接在一根总线上。</p>
<p>载波监听:是指每个站在发送数据之前先要检测总线上是否有其他计算机在发送数据，如果有则暂时不发送数据，避免发生碰撞。</p>
<p>​ 通过总线上的电压摆动来判断当前总线上是否存在多个计算机同时发送数据的情况</p>
<p>争用期:最先发送数据帧的站，在发送数据帧后至多经过2t(两倍的端到端时延)即可知道发送的数据帧是否遭受了碰撞。</p>
<p>最短有效帧长:争用期(2t)内可发送的总字节数------64字节。</p>
<p>发生碰撞怎么解决:</p>
<p>​ 推迟一个随机时间再发送，其中基本退避时间为2t，参数k = min(当前重传次数，10)，倍数为r = 1到2^k - 1，重传时延即为r倍的基本退避时间，若重传次数超过16次，则丢弃该帧并向高层报告。</p>
</blockquote>
<h2 id="以太网的其他信息">以太网的其他信息</h2>
<blockquote>
<p>两个标准:DIX Ethernet V2、802.3标准</p>
<p>以太网和数据链路层的两个子层:</p>
<p>​ 逻辑链路控制子层LLC</p>
<p>​ 媒体接入控制子层MAC</p>
<p>以太网提供的访问是不可靠的交付，接收到有差错的数据帧就丢弃，其他什么也不做</p>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各个工作站使用的还是CSMA/CD协议，集线器工作在物理层。</p>
</blockquote>
<h2 id="信道利用率计算">信道利用率计算</h2>
<blockquote>
<p>争用期长度为2t，帧长为L(bit)，数据发送速率为C(b/s)，帧的发送时间为L/C=T0 (s)</p>
<p>信道利用率的参数a = t/T0，故帧长不能太短(为了增大T0)，以太网连线不能太长(为了减小t)。无碰撞的理想情况下，极限信道利用率为</p>
<p><span class="math display">\[S_{max} = T_0 / (T_0 + t) = 1 /(1+a)\]</span></p>
</blockquote>
<h2 id="mac地址">MAC地址</h2>
<blockquote>
<p>硬件地址又称为物理地址，或MAC地址</p>
<p>MAC帧格式(MAC层)</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">目的地址</th>
<th style="text-align: center;">源地址</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">数据</th>
<th style="text-align: center;">FCS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">6个字节</td>
<td style="text-align: center;">6个字节</td>
<td style="text-align: center;">2个字节</td>
<td style="text-align: center;">46~1500</td>
<td style="text-align: center;">4个字节</td>
</tr>
</tbody>
</table>
<p>​ 帧检验序列FCS字段可保证无差错接受。</p>
<p>传到物理层会在前端插入8个字节表示帧开始。</p>
<p>无效的MAC帧:</p>
<p>​ 帧长度不为整数个字节。</p>
<p>​ 用收到的帧检验序列FCS查出有差错。</p>
<p>​ 数据字段的长度不在46~1500字节之间。</p>
<p>​ 有效的MAC帧长度不在64~1518字节之间。</p>
<p>​ 无效的MAC会直接丢弃，以太网不负责重传。</p>
<p>帧间最小间隔为9.6us，相当于96bit的发送时间，目的是为了使刚刚收到数据帧的站接受缓存来得及清理，做好接收下一帧的准备。</p>
</blockquote>
<h2 id="使用网桥拓展以太网">使用网桥拓展以太网</h2>
<blockquote>
<p>优点:过滤通信量、扩大物理范围、提高了可靠性、可互连不同的物理层、不同MAC子层和不同速率的局域网。</p>
<p>缺点:存储转发增加了时延、MAC子层并没有流量控制功能、具有不同MAC子层的网段桥接在一起时时延更大、网桥只适合于用户数不太多和通信量不太大的局域网，否则有时会因传播过多的广播信息产生网络拥塞。</p>
<p>记录的原理:A发出的帧送到网桥，网桥可以记录下哪个接口对应于A，将A的地址放入转发表中，对于不在转发表中的地址采用广播手段进行信息传输，对于在转发表中的地址，则根据记录的地址发送。</p>
</blockquote>
<h2 id="以太网的不同类型">以太网的不同类型</h2>
<blockquote>
<p>速率达到/超过100Mb/s的以太网叫高速以太网</p>
<p>100BASE-T以太网(快速以太网)</p>
<p>​ 在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE 802.3的CSMA/CD协议(半双工时)。</p>
<p>​ 可以在全双工的方式下工作且无冲突发生，不使用CSMA/CD协议，MAC帧格式仍是802.3标准规定的。最短帧长不变，但最大电缆长度减小到100m，帧间时间间隔变为0.96us。</p>
<p>吉比特以太网</p>
<p>​ 允许在1Gb/s下全双工和半双工两种方式工作。使用802.3协议规定的帧格式，在半双工方式下使用CSMA/CD,兼容10BASE-T和100BASE-T</p>
</blockquote>
<h2 id="滑动窗口协议">滑动窗口协议</h2>
<blockquote>
<p>一位滑动窗口协议 停----等式</p>
<p>回退N协议</p>
<p>选择重传协议</p>
</blockquote>
<h2 id="mac层各协议">MAC层各协议</h2>
<blockquote>
<p>ALOHA：想发就发，冲突后随机时间发。</p>
<p>分槽ALOHA：时间槽开始时发，冲突后随机时间发。</p>
<p>1坚持CSMA：监听到空闲一定发，信道忙则一直监听到空闲为止。冲突后随机时间重复此过程。</p>
<p>非坚持CSMA：监听到空闲一定发，信道忙则随机时间再监听。冲突后随机时间重复此过程。</p>
<p>p坚持CSMA：监听到空闲p概率发，信道忙则下一个时间槽再监听，1-p概率下一个时间槽再发送。</p>
<p>CSMA/CD：空闲则直接发送，若忙则等待到通道空闲。检测到冲突终止传输，随机等待一段时间后重新开始监听。则带冲突检测。802.3中使用1坚持-二进制后退的CSMA/CD。</p>
<p>CSMA/CA：空闲时等待一定时间发送，先发送帧，然后接收方会给发送方发送一个确认帧。若发送方没有收到确认帧或遇到冲突则二进制回退再发送。</p>
</blockquote>
<h2 id="无线局域网协议">无线局域网协议</h2>
<blockquote>
<p>存在问题：隐藏终端和暴露终端。</p>
<p>发送方先发送RTS(Request to send)，接收方收到RTS回应CTS(Clear to send)。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC2%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="物理层">物理层</h1>
<h2 id="物理层的基本概念">物理层的基本概念</h2>
<blockquote>
<p>尼奎斯特定理 $ C = 2Blog_2V $ 。C为最大数据速率，B为带宽频率，V为离散等级。</p>
<p>香农定理<span class="math inline">\(C = B log_2(1+S/N)\)</span> 。S/N是信噪比，<span class="math inline">\(10log_{10}S/N\)</span>为分贝，B为带宽频率，C为最大数据速率。</p>
</blockquote>
<h3 id="物理层的主要任务">物理层的主要任务</h3>
<p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流。</p>
<p>确定与传输媒体的接口的一些特性:</p>
<blockquote>
<p>机械特性:如接口形状、大小、引线数目</p>
<p>电气特性:如规定电压范围</p>
<p>功能特性:如规定-5V表示0</p>
<p>过程特性/规程特性:规定建立连接时各个相关部件的工作步骤</p>
</blockquote>
<h2 id="数据通信的基础知识">数据通信的基础知识</h2>
<blockquote>
<p>单向通信/单工通信 ---------只能有一个方向的通信而没有反方向的交互，如电台</p>
<p>半双工通信---------通信双方都可以发送消息，但不能双方同时发送。如对讲机</p>
<p>全双工通信--------通信的双方-可以同时发送和接收消息。如电话</p>
<p>数据比特流传输距离较短,用解调器变为模拟信号后传输距离会加长。</p>
<p>数据--------传送消息的实体</p>
<p>信号--------数据的电气/电磁表现</p>
<p>​ 模拟信号--------连续</p>
<p>​ 数字信号---------离散</p>
<p>码元----------在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p>
<p>信号调制方法:调幅、调频、调相</p>
</blockquote>
<h2 id="物理层下的传输媒体">物理层下的传输媒体</h2>
<h3 id="导向传输媒体">导向传输媒体</h3>
<blockquote>
<p><span class="math display">\[
常用传输频率10^4-------- 10^{16}
\]</span></p>
<p>双绞线:</p>
<p>​ 屏蔽双绞线STP</p>
<p>​ 无屏蔽双绞线UTP</p>
<p>同轴电缆:</p>
<p>​ 50Ω同轴电缆用于数字传输，基带同轴电缆</p>
<p>​ 75Ω同轴电缆用于模拟传输，宽带同轴电缆</p>
</blockquote>
<h2 id="信道复用技术">信道复用技术</h2>
<blockquote>
<p>频分复用:每个用户使用不同的频率传递。</p>
<p>时分复用:将单位时间划分为若干个时间片，每个用户使用对应的时间片传递。 统计时分复用在发送数据时在数据中添加标记，接收方根据标记判定谁接收并将标记去除。</p>
<p>波分复用:每个用户使用不同的波长传递。</p>
<p>码分复用:自己的码片乘积为1，同他人码片乘积为0，传输的信号为原数据同对应码片的乘积，总的传输信号为各个设备传输的信号之和，接收者只要将总信号同自己的码片相乘即可得到需要接收的值。</p>
<p>码分复用的缺点:设备数变多后码片需要越多</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>概论</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC1%E7%AB%A0-%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="概论">概论</h1>
<h2 id="网络大小划分">网络大小划分</h2>
<blockquote>
<p>个域网</p>
<p>局域网：用于企业时被称为企业网络</p>
<p>城域网</p>
<p>广域网</p>
<p>互联网</p>
</blockquote>
<h2 id="报文的不同称呼">报文的不同称呼</h2>
<blockquote>
<p>网络层中叫数据包/包</p>
</blockquote>
<h1 id="因特网边缘部分的通信方式">因特网边缘部分的通信方式</h1>
<blockquote>
<h4 id="客户服务器方式-cs">客户服务器方式 C/S</h4>
<h4 id="对等方式-p2ppeer-to-peer">对等方式 P2P(peer to peer)</h4>
<p>既是服务器又是客户机</p>
</blockquote>
<h1 id="数据交换方式">数据交换方式</h1>
<blockquote>
<h4 id="电路交换---面向连接">电路交换---面向连接</h4>
<p>交换机位于中心，需要连接时会通过电路连接两个主机。</p>
<p>建立连接:申请占用通信资源。</p>
<p>通话:一直占用通信资源。</p>
<p>释放连接:释放通信资源</p>
<p>适用于数据量很大的实时传输，核心路由器之间可以用电路交换</p>
<h4 id="报文交换">报文交换</h4>
<p>报文一般比分组长的多</p>
<p>报文发送时间长</p>
<h4 id="分组交换计算机使用的方式">分组交换:计算机使用的方式</h4>
<p>发送端对报文进行拆分成不同小组，添加首部组合成一个数据然后发送给接收端。</p>
<p>接收端对数据进行拆除首部，然后根据首部的信息将收到的数据组合成报文</p>
</blockquote>
<h1 id="局域网和广域网不单单从覆盖范围划分还要从使用的技术是什么">局域网和广域网不单单从覆盖范围划分，还要从使用的技术是什么</h1>
<blockquote>
<p>局域网 自己购买设备、自己维护、带宽固定 距离100米内</p>
<p>广域网 花钱买服务、花钱买带宽</p>
</blockquote>
<h1 id="网络的拓扑结构">网络的拓扑结构</h1>
<blockquote>
<p>总线型、环形、星型、树型、网状结构</p>
</blockquote>
<h1 id="网络工作方式">网络工作方式</h1>
<blockquote>
<p>资源子网、通信子网、接入网</p>
</blockquote>
<h1 id="计算机网络的性能">计算机网络的性能</h1>
<blockquote>
<p>速率:主机在数字信道传送数据位数的速率，也成为data rate 或bit rate。</p>
<p>带宽:数据信道所能传送的最高数据率。</p>
<p>吞吐量:单位时间内通过某个网络的数据量。</p>
<p>时延:</p>
<blockquote>
<p>发送时延 数据块长度/信道带宽</p>
<p>传播时延:信道长度/信号在信道上的传播速率</p>
<p>处理时延:在</p>
<p>排队时延:在接收方主机处等待的时间</p>
</blockquote>
<p>时延带宽积 :传播时延 * 带宽</p>
<p>往返时间RTT:从发送方发送数据开始到发送方收到接收方确认。</p>
<p>利用率:</p>
<blockquote>
<p>信道利用率 = 有数据通过时间 / (有 + 无数据通过的时间)</p>
<p>网络利用率：信道利用率加权平均值</p>
</blockquote>
<p>非性能指标:费用、质量、标准化、可靠性、可扩展性、可升级性、管理与维护</p>
</blockquote>
<h1 id="计算机网络的体系结构">计算机网络的体系结构</h1>
<blockquote>
<p>OSI(开放式系统互联)七层模型:分层有利于标准化，且分层后各层之间的变化不会影响到其他层，尽量降低了相互之间的依赖。</p>
<p>物理层:规定电压、接口标准</p>
<p>数据链路层:输入如何封装，添加物理层地址，MAC</p>
<p>网络层:选择最佳路径，IP地址编址</p>
<p>传输层:可靠传输(建立会话)、不可靠传输(不建立会话)、流量控制。</p>
<p>会话层:服务和客户端建立的会话。 netstat -nb</p>
<p>表示层:加密、压缩、编码，开发人员考虑。</p>
<p>应用层: 能够产生网络流量，能够和用户交互的应用程序。</p>
</blockquote>
<h1 id="网络排错">网络排错</h1>
<blockquote>
<p>需要从底层到高层逐一排查</p>
</blockquote>
<h1 id="网络安全和osi参考模型的关系">网络安全和OSI参考模型的关系</h1>
<blockquote>
<p>物理层安全</p>
<p>数据链路层安全:ADSL、无线AP</p>
<p>网络层安全</p>
<p>应用层安全: SQL注入漏洞、上传漏洞</p>
</blockquote>
<h1 id="一些基本概念">一些基本概念</h1>
<blockquote>
<p>实体:交换信息的硬件或软件进程。</p>
<p>协议:控制两个对等实体通信的规则。</p>
<p>服务:下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能。</p>
<p>服务访问点:相邻两层实体间交换信息的地方。</p>
<p>AP接入点和无线路由器和基站作用相差不大，主要负责中继无线计算机之间的数据包，还负责中继无线计算机和Internet之间的数据包。</p>
<p>IEEE802.11俗称WIFI。以太网IEEE802.3。</p>
<p>将两个或多个网络连接起来并提供必要转换的机器，其硬件和软件方面的总称是网关。路由器就是一个网关，在网络层交换数据包。</p>
<p>不可靠的无连接服务通常称为数据报服务。</p>
</blockquote>
<h1 id="tpcip">TPC/IP</h1>
<blockquote>
<p>五层模型:</p>
<p>应用层:</p>
<blockquote>
<p>数据单元:传输数据单元PDU</p>
</blockquote>
<p>运输层:</p>
<blockquote>
<p>数据单元:报文</p>
</blockquote>
<p>网络层:</p>
<blockquote>
<p>数据单元:(IP数据报/IP分组/包)</p>
</blockquote>
<p>数据链路层:</p>
<blockquote>
<p>数据单元:数据帧</p>
</blockquote>
<p>物理层:</p>
<blockquote>
<p>数据单元:比特010101</p>
</blockquote>
</blockquote>
<h1 id="osi参考模型">OSI参考模型</h1>
<blockquote>
<p>应用层:</p>
<p>​ 所有可以和用户交互产生网络流量的程序。</p>
<p>​ 文件传输FTP、电子邮件SMTP、万维网HTTP</p>
<p>表示层</p>
<p>​ 用于处理两个通信系统中交换信息的表示方式。</p>
<p>​ 数据格式变换、数据加密解密、数据压缩和恢复</p>
<p>​ JPEG、ASCII</p>
<p>会话层</p>
<p>​ 向表示层实体/用户进程提供建立连接并在连接上有序地传输数据。</p>
<p>​ 建立、管理、终止会话。</p>
<p>​ 使用检验点可以使会话在通信失效时从检验点/同步点进行恢复通信，实现数据同步。</p>
<p>​ ADSP、ASP</p>
<p>传输层</p>
<p>​ 负责主机中两个进程的通信，即端到端的通信。传输单位是报文/用户数据报</p>
<p>​ 可靠传输、不可靠传输</p>
<p>​ 差错控制</p>
<p>​ 复用分用</p>
<p>网络层</p>
<p>​ 路由选择</p>
<p>​ 流量控制</p>
<p>​ 差错控制</p>
<p>​ 拥塞控制</p>
<p>数据链路层 加上报头和报尾。</p>
<p>​ 把网络层传下来的数据报组装成帧</p>
<p>​ 差错控制</p>
<p>​ 流量控制</p>
<p>​ 接入控制</p>
<p>​ SDLC、HDLC、PPP、STP</p>
<p>物理层</p>
<p>​ 在物理媒体上实现比特流的透明传输</p>
<p>​ 定义接口特性</p>
<p>​ 定义传输模式</p>
<p>​ 定义传输速率</p>
<p>​ 比特同步</p>
<p>​ 比特编码</p>
<p>​ RJ45、802.3</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC4%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h1 id="网络层">网络层</h1>
<h2 id="网络层传输单元为数据报">网络层传输单元为数据报</h2>
<h2 id="网络层提供的两种服务">网络层提供的两种服务</h2>
<blockquote>
<p>网络层关注的是如何将分组从源端沿着网络路劲送达目的端。</p>
<p>它向运输层通过了虚电路服务和数据报服务。</p>
<p>计算机通信的过程中可靠交付由端系统负责，而不是网络负责。</p>
<p>虚电路服务</p>
<p>​ 通过指定数据的逻辑连接，向端系统保证了数据的按序到达，免去了端系统在顺序控制上的开销。</p>
<p>​ 逻辑上的连接而非真正建立了一条物理连接。</p>
<p>数据报服务</p>
<p>​ 网络层向上提供简单灵活的、<strong>无连接的</strong>、尽最大努力交付的数据报服务。</p>
<p>​ 优点:传输网络不提供端到端的可靠传输服务，使得网络造价降低，运行方式灵活，适用多种应用。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">两个服务对比</th>
<th style="text-align: center;">虚电路服务</th>
<th style="text-align: center;">数据报服务</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">思路</td>
<td style="text-align: center;">可靠通信由网络保证</td>
<td style="text-align: center;">可靠通信由用户主机保证</td>
</tr>
<tr class="even">
<td style="text-align: center;">连接的建立</td>
<td style="text-align: center;">必须有</td>
<td style="text-align: center;">不需要</td>
</tr>
<tr class="odd">
<td style="text-align: center;">终点地址</td>
<td style="text-align: center;">仅在连接建立阶段使用，每个分组使用短的虚电路号</td>
<td style="text-align: center;">每个分组都要有终点的完整地址</td>
</tr>
<tr class="even">
<td style="text-align: center;">分组的转发</td>
<td style="text-align: center;">属于同一条虚电路的分组均按照同一路由进行转发</td>
<td style="text-align: center;">每个分组独立选择路由进行转发</td>
</tr>
<tr class="odd">
<td style="text-align: center;">当结点出故障时</td>
<td style="text-align: center;">所有通过出故障结点的虚电路均不能工作</td>
<td style="text-align: center;">出故障的结点可能丢失分组，一些路由可能发生变化</td>
</tr>
<tr class="even">
<td style="text-align: center;">分组的顺序</td>
<td style="text-align: center;">总数按发送顺序到达终点</td>
<td style="text-align: center;">到达终点时不一定按发送顺序</td>
</tr>
<tr class="odd">
<td style="text-align: center;">端到端的差错处理和流量控制</td>
<td style="text-align: center;">可以由网络负责,也可以由用户主机负责</td>
<td style="text-align: center;">由用户主机负责</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="网际协议ip">网际协议IP</h2>
<h3 id="虚拟互联网">虚拟互联网</h3>
<blockquote>
<p>网络互连的设备:</p>
<p>​ 概念:中间设备又称为中间系统或中继系统</p>
<p>​ 物理层中继系统:转发器。</p>
<p>​ 数据链路层中继系统:网桥或桥接器。</p>
<p>​ 网络层中继系统:路由器。</p>
<p>​ 网络层以上的中继系统:网关。</p>
<p>网络层协议:IP协议最主要。与IP协议配套的协议:</p>
<p>​ ARP地址解析协议。(位于底层)解析MAC地址</p>
<p>​ RARP逆地址解析协议。(位于底层)</p>
<p>​ ICMP网际控制报文协议。(位于顶层)报告网络故障</p>
<p>​ IGMP网际组管理协议。(位于顶层)</p>
</blockquote>
<h2 id="ipv4地址组成">IPv4地址组成</h2>
<blockquote>
<p>IPv4地址由32位IP组成，其中分为网络ID和主机ID。主机ID不能全为0(全0表示网段)也不能全为1(全1表示广播)</p>
<p>A类地址:前8位为网络ID，后24位为主机ID。 0xxxxxxx | x....x 1~126 (127的地址用于做循环测试，本机地址)</p>
<p>B类地址:前16位为网络ID，后8位为主机ID。 10x.....x | x....x 128~191</p>
<p>C类地址:前24位为网络ID，后8位为主机ID。 110x....x | x...x 192~223</p>
<p>D类组播使用。 1110| x.....x(多播地址) 224~239</p>
<p>E类研究使用。 1111| x.....x(保留为今后使用) 240~255</p>
<p>特殊的几个地址:</p>
<p>​ 127.0.0.1 本地环回地址</p>
<p>​ 169.254.0.0 微软在无法自动获取IP时自动分给计算机的IP地址。</p>
<p>​ 保留的私网地址。</p>
<ul>
<li>10.0.0.0 ------ 10.255.255.255</li>
<li>172.16.0.0 ------ 127.31.255.255</li>
<li>192.168.0.0 ------- 192.168.255.255</li>
</ul>
</blockquote>
<h2 id="子网掩码的作用">子网掩码的作用</h2>
<blockquote>
<p>同IP地址作与运算，得到的结果用于判断两个IP是否位于同一网段，从而判断这两个IP的信息交换是否要通过路由器。</p>
<p>可以用于屏蔽IP地址的主机ID部分，来凸显IP地址的网络ID部分，借此判断两个IP能否直接信息交换。</p>
<p>还可以将大的IP网络划分为若干小的网络。(划分子网、等分划分/边长划分)</p>
<p>超网:通过子网掩码把若干个小网络合并为一个大网络。</p>
</blockquote>
<h2 id="ip地址与mac地址">IP地址与MAC地址</h2>
<blockquote>
<p>网络层以上使用IP地址，链路层及以下使用MAC地址</p>
<figure>
<img src="/2021/02/20/computerNetwork/%E7%AC%AC4%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/IP地址和MAC地址.png" alt="IP地址和MAC地址"><figcaption aria-hidden="true">IP地址和MAC地址</figcaption>
</figure>
<p>相比于IP数据报，MAC帧增加了</p>
<p>交换机基于数据帧的MAC地址转发数据帧，路由器基于数据包的IP地址转发数据包。</p>
<p>数据包在传输过程不变，过网络设备数据帧要用新的物理层地址重新封装。</p>
<p>MAC地址决定了数据帧下一跳哪个设备接收，而IP地址决定了数据包的起点和终点</p>
</blockquote>
<h2 id="协议">协议</h2>
<blockquote>
<p>ARP协议:将IP地址转化为物理地址。会使用到广播。</p>
<p>RARP协议:将物理地址转化为IP地址。</p>
<p>ARP欺骗。</p>
</blockquote>
<h2 id="ip数据报">IP数据报</h2>
<blockquote>
<p>IP数据报的首部和数据两部分组成。首部的前一部分是固定，共20字节，是所有IP数据报必须具有的。</p>
<figure>
<img src="/2021/02/20/computerNetwork/%E7%AC%AC4%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/IP地址.png" alt="IP地址"><figcaption aria-hidden="true">IP地址</figcaption>
</figure>
<p>在首部的固定部分的后面是一些可选字段，其长度是可变的。</p>
<p>各字段</p>
<p>0-4位版本(表示为IPv4/IPv6) 4-8位首部长度(最小值为固定长度部分共20个字节。可表示最大15个单位，一个单位4个字节，故首部最大60个字节) 8-16区分服务(数据包所需的服务，定义优先级) 16-32总长度(数据包总大小，一般为1500)</p>
<p>标识(每产生一个数据包就增加1) 标志(判断数据包是否分片) 片偏移(偏移量单位为8个字节)</p>
<p>TTL生存时间值，指定IP包被路由器丢弃之前允许通过的最大网段数量。</p>
<p>协议用于指明上层协议是什么，如ICMP、TCP、UDP等。</p>
<p>首部校验和用于校验数据报是否可用。计算过程:发送端把数据报首部的信息拆成许多单字，然后初始校验和为0，将校验和同这些单字进行反码运算求和，结果取反码即为校验和。接收方重复此过程，若结果为0则保留，不为0则直接丢弃。</p>
<p>源地址、目的地址即为IP地址。</p>
<p>可选字段用于支持排错、测量及安全等措施</p>
</blockquote>
<h2 id="数据路由">数据路由</h2>
<blockquote>
<p>数据路由在不同网段转发数据报。能去能回--------网络畅通。</p>
<p>负载均衡</p>
</blockquote>
<h2 id="icmp协议">ICMP协议</h2>
<blockquote>
<p>报文类型:ICMP差错报告报文、ICMP询问报文</p>
<p>报文前四个字节格式统一共3个字段:类型、代码、检验和，接着的四个字节内容与ICMP的类型有关。</p>
<p>差错报告报文共五种:终点不可达、源点抑制(发数据报的速度过快)、时间超过、参数问题、改变路由/重定向。</p>
<p>询问报文有两种:回送请求和回答报文、时间戳请求和回答报文。</p>
</blockquote>
<h2 id="动态路由协议">动态路由协议</h2>
<blockquote>
<p>RIP最早的动态路由协议，周期性广播，30s广播一次。跳数16次。</p>
</blockquote>
<h2 id="ospf协议开放式最短路径优先---动态路由协议">OSPF协议(开放式最短路径优先)---动态路由协议</h2>
<h2 id="bgp------外部网关协议">BGP ---- 外部网关协议</h2>
<blockquote>
<p>不同自治系统的路由器之间交换路由信息的协议</p>
<p>报文类型：</p>
<p>OPEN</p>
<p>UDDATE</p>
<p>KEEPALIVE</p>
<p>NOTIFICATION</p>
<p>ROUTE-REFRESH</p>
<p>重要属性：</p>
<p>AS-PATH: 包含前缀通告所经过的AS序列</p>
<p>NEXT-HOP(下一跳): 开始一个AS-PATH的路由器接口，指向下一跳AS.</p>
</blockquote>
<h2 id="nat和pat">NAT和PAT</h2>
<blockquote>

</blockquote>
<h2 id="igmp-组播多播">IGMP 组播/多播</h2>
<h2 id="dhcp">DHCP</h2>
<blockquote>

</blockquote>
<h2 id="arp">ARP</h2>
<blockquote>
<p>默认网关为网络上的最低地址，如192.32.65.0/24的默认网关为192.32.65.1</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful基本使用</title>
    <url>/2021/02/20/designPattern/Restful%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="restful风格">Restful风格</h1>
<blockquote>
<p>本质上就是将接口的功能让http的语义来表示。</p>
<p>查询-&gt;GET</p>
<p>新增-&gt;POST</p>
<p>更新-&gt;PUT</p>
<p>删除-&gt;DELETE</p>
<p>本质上要做到，看url知道要什么，看http method知道要做什么，看http status code知道哪里有问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
        <category>代码风格</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="传输层">传输层</h1>
<h2 id="各层协议">各层协议</h2>
<blockquote>
<p>应用层: http、https、ftp、DNS、SMTP、PoP3、RDP</p>
<p>传输层: TCP、UDP</p>
<p>网络层: IP(RIP、OSPF、BGP) 、ICMP、IGMP、ARP</p>
</blockquote>
<h2 id="传输层两个协议应用场景">传输层两个协议应用场景</h2>
<h3 id="tcp">TCP</h3>
<blockquote>
<p>分段、编号、流量控制、可靠传输、建立会话、面向连接。</p>
</blockquote>
<h3 id="udp">UDP</h3>
<blockquote>
<p>一个数据包就能完成数据通信、不建立会话。</p>
</blockquote>
<h2 id="传输层和应用层之间的关系">传输层和应用层之间的关系</h2>
<blockquote>
<p>http = TCP + 80</p>
<p>https = TCP + 443</p>
<p>ftp = TCP + 21</p>
<p>SMTP = TCP + 25</p>
<p>POP3 = TCP + 110</p>
<p>RDP = TCP + 3389</p>
<p>共享文件夹 = TCP + 445</p>
<p>SQLServer = TCP + 1433</p>
<p>DNS = UDP + 53 OR TCP + 53</p>
</blockquote>
<h2 id="应用层协议和服务之间的关系">应用层协议和服务之间的关系</h2>
<blockquote>
<p>服务运行后在TCP或UDP的某个端口监听客户端请求。</p>
</blockquote>
<h2 id="udp协议">UDP协议</h2>
<blockquote>
<p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元。</p>
<p>TCP传送的协议数据单元是<strong>TCP报文段</strong>。</p>
<p>UDP传送的协议数据单元是<strong>UDP报文</strong>或<strong>用户数据报</strong>。</p>
<p>UDP的首部格式<img src="/2021/02/20/computerNetwork/%E7%AC%AC5%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/UDP首部格式.png" alt="UDP首部格式"></p>
</blockquote>
<h2 id="tcp协议">TCP协议</h2>
<blockquote>
<p><strong>TCP的特点</strong></p>
<p>​ TCP是面向连接的传输层协议，每条TCP连接只能有两个端点，故TCP连接是点对点的。</p>
<p>​ TCP提供可靠交付的服务，TCP提供全双工通信。</p>
<p>​ TCP面向字节流。</p>
<p>​ 提供流量控制。</p>
<p>​ 避免网络拥塞</p>
</blockquote>
<h3 id="tcp如何">TCP如何</h3>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2021/02/20/computerNetwork/%E7%AC%AC6%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="使用tcp">使用TCP</h2>
<blockquote>
<p>HTTP、FTP、Telnet、SMTP</p>
</blockquote>
<h2 id="使用udp">使用UDP</h2>
<blockquote>
<p>流媒体、DNS、网络电话、电话会议</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>常用设计模式介绍</title>
    <url>/2021/02/20/designPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式">设计模式</h1>
<h2 id="策略模式">策略模式</h2>
<blockquote>
<p>将行为抽象，通过子类实现不同的行为来将某个对象的行为从父类抽取出，通过组合的方式来消除耦合。</p>
</blockquote>
<h2 id="命令模式">命令模式</h2>
<blockquote>
<p>也是将行为抽象，但是目的是将行为和行为执行者二者解耦，通过将行为和行为执行者组合的方式，加上控制器控制，来便于拓展。</p>
</blockquote>
<h2 id="工厂模式">工厂模式</h2>
<blockquote>
<p>简单工厂即在类中直接添加工厂对象，在工厂对象中直接创建实例。</p>
<p>工厂模式：将工厂的创建实例方法抽象化，通过子类继承并重写对应方法的方式完成。</p>
<p>抽象工厂模式：将一系列创建实例的方法抽象化，形成接口，子类实现该接口，有点类似工厂模式。</p>
</blockquote>
<h2 id="单例模式">单例模式</h2>
<blockquote>
<p>即让一个类只能有一个对象实例。</p>
<p>double check方式实现比较好。</p>
<figure>
<img src="/2021/02/20/designPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/单例模式.png" alt="单例模式"><figcaption aria-hidden="true">单例模式</figcaption>
</figure>
</blockquote>
<h2 id="装饰者模式">装饰者模式</h2>
<blockquote>
<p>子类继承分类时，不是将父类的方法直接重写，而是在父类方法的基础上添加自己的功能。</p>
</blockquote>
<h2 id="观察者模式">观察者模式</h2>
<blockquote>
<p>分为主题(observable)和观察者(observer)两个模块，根主题是一种接口/类，提供添加观察者、移除观察者、通知观察者等方法，观察者则需要实现一个接口表示它为观察者，通常要实现update方法。主题的数据改变时可以通知观察者，数据可以有主题直接推送给观察者和观察者向主题拉取数据两个方式。</p>
</blockquote>
<h2 id="适配器模式">适配器模式</h2>
<blockquote>
<p>将一个类的接口转换成另一个接口，让本来不兼容的类可以合作无间。</p>
</blockquote>
<h2 id="外观模式">外观模式</h2>
<blockquote>
<p>将多个接口简化为一个接口</p>
</blockquote>
<h2 id="模板方法模式">模板方法模式</h2>
<blockquote>
<p>将算法分抽象为许多步骤，将统一的流程由父类实现，子类实现具体的不同部分。</p>
</blockquote>
<h2 id="迭代器模式">迭代器模式</h2>
<blockquote>
<p>给不同集合一种相同的遍历方法。</p>
</blockquote>
<h2 id="组合模式">组合模式</h2>
<blockquote>
<p>通过一致的方式处理个别对象及对象的组合，如对树和树的叶子节点采用统一的抽象方式。</p>
</blockquote>
<h2 id="状态模式">状态模式</h2>
<blockquote>
<p>状态机，将状态进行抽象，具体的状态类则实现自己具体的行为，状态类自己控制状态的转化。</p>
</blockquote>
<h2 id="代理模式">代理模式</h2>
<blockquote>
<p>给客户一个某种对象的代理，该代理对象控制对原对象的引用，目的是控制客户对对象的访问。</p>
<p>动态代理、静态代理、远程代理等。</p>
<p>静态代理</p>
<p>动态代理：JDK代理和cglib代理。JDK代理需要被代理类实现接口，而cglib没有这个限制</p>
</blockquote>
<h2 id="mvc">MVC</h2>
<blockquote>
<p>模型、视图、控制器。</p>
</blockquote>
]]></content>
      <categories>
        <category>代码规范</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O及Netty分析</title>
    <url>/2021/02/20/codeAnalyse/Netty/</url>
    <content><![CDATA[<h1 id="netty">Netty</h1>
<h2 id="io基础">I/O基础</h2>
<blockquote>
<p>输入流：InputStream(字节流)和Reader(字符流)。</p>
<p>输出流：OutputStream(字节流)和Writer(字符流)。</p>
<p>字节8bit，计算机处理的最小单位，字符16bit，人处理的最小单位。</p>
<p>字节流常用于处理文件、图片、视频等二进制数据，而字符流处理文本数据。</p>
</blockquote>
<h2 id="socket基础">Socket基础</h2>
<blockquote>
<p>Socket是应用层和传输层的抽象层，是一组接口，类似设计模式的门面模式。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/Netty/socket流程.png" alt="socket流程"><figcaption aria-hidden="true">socket流程</figcaption>
</figure>
<p>ServerSocket -&gt; serverSocketChannel -&gt; NioServerSocketChannel</p>
<p>Socket -&gt; SocketChannel</p>
</blockquote>
<h2 id="nio">NIO</h2>
<blockquote>
<p>阻塞：面向CPU等待慢操作完成才切换。</p>
<p>非阻塞：面向CPU在慢操作执行时，先去做别的事，等到慢操作完成时切换。</p>
<p>NIO和BIO区别：</p>
<p>​ BIO是面向流的，NIO是面向块/缓冲区的。</p>
<p>​ 最大不同在于NIO将文件或文件中的一段区域映射到内存中，可以像访问内存一样访问文件。</p>
<p>​ BIO是阻塞型IO,NIO是非阻塞型IO,NIO使用了多路复用的技术。</p>
</blockquote>
<h3 id="nio核心">NIO核心</h3>
<blockquote>
<p>通道Channel、缓冲区buffer、选择器selector。</p>
</blockquote>
<h4 id="channel">Channel</h4>
<blockquote>
<p>FileChannel 文件管道的数据</p>
<p>Pipe.SinkChannel</p>
<p>Pipe.SourceChannel 线程间通信的管道</p>
<p>ServerSocketChannel</p>
<p>SocketChannel 用于TCP网络通信的管道</p>
<p>DatagramChannel 用于UDP网络通信的管道</p>
</blockquote>
<h4 id="buffer">Buffer</h4>
<blockquote>
<p>底层是数组，可以进行set/get操作。</p>
<p>Buffer没有构造器，通过使用XxxBuffer.allocate(int n)方法分配，创建容量为n的对象。</p>
<p>capacity总体容量大小，limit存储容量的大小，是可读写和不可读写的界限，position已读容量的大小，是已读和未读区域的界限 。</p>
<p>具体使用：</p>
<p>​ 初始化时，position=0，limit = capacity。</p>
<p>​ 调用put方法存入数据，position向后移动，代表数据处理的位置，直到存储结束。</p>
<p>​ 写完成时调用flip方法刷新，limit = position，position = 0，保证limit记录可读写区域大小，positon已读部分重置为空。</p>
<p>​ 读数据知道读完成，需要调用clear方法，position = 0， limit = capacity。</p>
</blockquote>
<h4 id="selector">Selector</h4>
<blockquote>
<p>三个元素</p>
<p>​ Selector、SelectableChannel、SelectionKey。</p>
<p>selector实例有select()方法判断当前有几个操作已经就绪，keys()可以获取当前所有的SelectableChannel，selectedKeys获取就绪的key。</p>
<p>选择器Selector和通道SelectableChannel的关系，是将通道注册进选择器中，前提是通道是可选择的。注册关系对应的是选择键SelectionKey所代表的具体操作。</p>
<p>本质上Selector是监听器，监听的是通道是否具有我们关心的操作产生。</p>
<p>Selector，被注册的通道集合，以及他们的状态。</p>
<p>SelectableChannel，是一个抽象类，提供了可被选择需要实现的API。</p>
<p>​ FileChannel就是不可选择的，Socket相关的通道都是可选择的。</p>
<p>​ 一个通道可以被注册到多个选择器上，但对于每个选择器而言，一个通道只能被注册一次。</p>
<p>SelectionKey，封装了要监听的事件，连接、接收、读、写。</p>
<p>​ 一方面，Selector关心通道要处理哪些事件。</p>
<p>​ 另一方面，当事件触发时，通道要处理哪些事件。</p>
</blockquote>
<h3 id="零拷贝">零拷贝</h3>
<blockquote>
<p>零拷贝是基于操作系统层面的优化方式。(以下基于Linux系统)</p>
<p>需求：将socket要发送的数据从磁盘中读取，然后发送。</p>
<p>CPU拷贝：在操作系统中进行的拷贝。</p>
<p>DMA拷贝：连接磁盘或网卡的硬件拷贝。</p>
<p>零拷贝即无CPU拷贝。</p>
<p>原始操作：</p>
<p>​ 磁盘-&gt;操作系统内核缓冲区-&gt;应用程序缓存buffer-&gt;socket网络缓冲区(也属于操作系统内核缓冲区)-&gt;网卡。共四次copy。</p>
<p>mmap(内存映射)操作：</p>
<p>​ 磁盘-&gt;操作系统内核缓冲区-&gt;socket网络缓冲区(也属于操作系统内核缓冲区)-&gt;网卡。三次copy。将操作系统内核缓冲区和应用程序buffer映射。</p>
<p>sendfile(linux2.1内核支持)：</p>
<p>​ 磁盘-&gt;操作系统内核缓冲区-&gt;socket网络缓冲区(也属于操作系统内核缓冲区)-&gt;网卡。三次copy。操作系统内核到socket网络缓冲区不拷贝全部数据只记录数据的位置和长度。</p>
<p>sendfile with scatter/gather copy 批量sendfile：</p>
<p>​ 从单个文件的处理，上升到多个物理地址的处理。</p>
<p>splice(拼接，在linux2.6内核支持)：</p>
<p>磁盘-&gt;操作系统内核缓冲区 (管道------&gt;) socket网络缓冲区(也属于操作系统内核缓冲区)-&gt;网卡。三次copy。操作系统内核到socket网络缓冲区通过管道连接。</p>
</blockquote>
<h3 id="nio线程模型">NIO线程模型</h3>
<blockquote>
<p>Reactor模型：事件驱动，可以处理一个或多个数据源。</p>
<p>​ Reactor：监听事件的发生，并分发给对应的handler处理，或分发给acceptor。</p>
<p>​ Acceptor：处理客户端建立连接事件，并创建handler。</p>
<p>​ handler：处理后续读写事件。</p>
<p>主从reactor模型：</p>
<p>​ 主reactor负责接收事件处理、从reactor负责读写事件处理。</p>
</blockquote>
<h3 id="netty的线程模型">Netty的线程模型</h3>
<blockquote>
<p>BossGroup(主reactor)和WorkerGroup(从reactor)-&gt; NioEventGroup</p>
</blockquote>
<h3 id="netty编解码器">Netty编解码器</h3>
<h2 id="http-handler">HTTP Handler</h2>
<blockquote>
<p>请求/响应：HttpResponseDecoder 解码器(客户端)、HttpRequestEncoder 编码器(客户端)。HttpResponseEncoder 编码器(服务端)、HttpRequestDecoder 解码器(服务端)。</p>
<p>编解码器：HttpClientCodeC：HttpResponseDecoder + HttpRequestEncoder 。HttpServerCodeC：HttpResponseEncoder + HttpRequestDecoder 。</p>
<p>压缩：HttpContentCompressor压缩，HttpContentDecompressor解压缩。</p>
<p>聚合：HttpObjectAggregator -&gt; FullHttpRequest / FullHttpResponse</p>
</blockquote>
<h2 id="遇到的问题">遇到的问题</h2>
<blockquote>
<p>使用selector监听事件时，发现当客户端断开连接时，服务端仍会收到连续的读操作。</p>
<p>原因：</p>
<p>​ selector没有检查当前读到的字符长度是否为-1,-1表示服务端断开连接，需要单独处理，让channel关闭。</p>
<p>注册写事件时收到连续写。</p>
<p>原因：</p>
<p>​ 写操作的就绪条件为底层缓冲区有空闲空间，而写缓冲区绝大部分时间都是有空闲空间的，所以当你注册写事件后，写操作一直是就绪的，选择处理线程全占用整个CPU资源。所以，只有当你确实有数据要写时再注册写操作，并在写完以后马上取消注册。</p>
</blockquote>
<h3 id="一些测试">一些测试</h3>
<blockquote>
<p>使用普通io进行文件copy速度最慢。</p>
<p>使用mmap、sendfile、nio进行文件copy速度相差不大。</p>
<p>理论上sendfile应该最快。</p>
<p>下图mmap copy(使用inChannel.map())、zero/Sendfile copy(使用inChannel.transferTo())、nio copy(使用ByteBuffer和FileChannel)均测试复制同一个文件10000次用时。</p>
<p>而最后normal copy(使用BufferedOutputStream和BufferedInputStream) 测试同一个文件2000次用时。</p>
<figure>
<img src="/2021/02/20/codeAnalyse/Netty/文件copy测试.png" alt="文件copy测试"><figcaption aria-hidden="true">文件copy测试</figcaption>
</figure>
</blockquote>
<h2 id="bytebuf-对应-buffer">ByteBuf 对应 Buffer</h2>
<blockquote>
<p>NIO中ByteBuffer的缺点：</p>
<p>长度固定，无法动态扩容的缩容，缺乏灵活性。</p>
<p>​ 使用一个position记录读写的索引位置，在读写模式切换时需要手动调用flip方法，增加了使用的复杂度。</p>
<p>​ 功能有限，使用过程中往往需要自行封装。</p>
</blockquote>
<h3 id="分类">分类</h3>
<blockquote>
<p>按照内存的位置：分为堆内存缓冲区heap buffer、直接内存缓冲区direct buffer、复合内存缓冲区composite buffer。</p>
</blockquote>
<h4 id="heap-buffer">heap buffer</h4>
<blockquote>
<p>将数据存储到JVM的堆空间中，实际使用字节数组byte[]存放。</p>
<p>优点：数据可以快速创建和释放，并且能够直接访问内部数组。</p>
<p>缺点：在读写数据时，需要将数据复制到直接缓冲区，再进行网络传输。</p>
<p>应用场景：业务消息使用缓冲区时往往使用heap bufffer。</p>
</blockquote>
<h4 id="direct-bufffer">direct bufffer</h4>
<blockquote>
<p>不在堆中，而是使用了操作系统的本地内存。</p>
<p>优点：在使用socket进行数据传输过程中，减少一次拷贝，性能更高。</p>
<p>缺点：释放和分配的空间更昂贵，使用时需要更谨慎。</p>
<p>应用场景：通信线程使用缓冲区时往往使用direct bufffer。</p>
<p>对于内存空间分配和释放的复杂度和效率，netty通过内存池的方式来解决。</p>
<p>内存池可以循环利用ByteBuf，提供使用率。但是管理和维护较复杂。</p>
<p>Unpooled是非池化缓冲区的工具类。</p>
<p>主要区别在于，池化的内存由netty管理，非池化内存由GC回收。</p>
<p>回收方式为引用计数，规则为：当对象被调用时，引用记为+1，当对象被释放时，引用记为-1，当引用次数为0时，对象可以回收。</p>
<h3 id="弊端">弊端</h3>
<p>当对象不可达时，JVM会通过GC回收，但此时引用计数可能不为0，对象无法归还内存池，导致内存泄漏。netty只能通过对内存缓冲区进行采样来检查。</p>
</blockquote>
<h4 id="composite-buffer">composite buffer</h4>
<blockquote>
<p>将两个或多个不同内存的缓冲区合并。</p>
<p>优点可以统一进行操作</p>
<p>应用场景：在解决http包，请求头+请求体特性不同而选择不同位置存储时，可以将两者拼接使用。</p>
</blockquote>
<h3 id="工作原理">工作原理</h3>
<blockquote>
<p>和ByteBuffer不同，增加了一个指针，通过两个指针来记录读模式和写模式的索引位置。读指针叫readerIndex，写指针叫做writerIndex。</p>
<p>写入数据时，写指针移动。读取数据时读数据移动。已读部分会变为可回收区域，被回收后，读指针和写指针会移动到新的位置。</p>
<p>buf.duplicate()方法，是浅拷贝。</p>
<p>buf.copy()方法，是深拷贝。</p>
</blockquote>
<h3 id="自动扩容原理">自动扩容原理</h3>
<blockquote>
<p>当写数据时，先判断是否需要扩容，若当前空间较小，以64为基数倍增。若当前空间较大(&gt;4M)，每次扩容增加4M。</p>
<p>具体实现位于AbstractByteBuf。ByteBuf的公共功能和属性都在此实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeBytes</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = src.remaining();</span><br><span class="line">    <span class="comment">// 判断是否可写入</span></span><br><span class="line">    ensureWritable0(length);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    setBytes(writerIndex, src);</span><br><span class="line">    writerIndex += length;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetCapacity = writerIndex + minWritableBytes;</span><br><span class="line">    <span class="comment">// 容量足够无须扩容</span></span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &lt;= capacity()) &#123;</span><br><span class="line">        <span class="comment">// 判断是否可达，利用了引用计数</span></span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//目标容量超过最大容量抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; targetCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取可写空间大小</span></span><br><span class="line">    <span class="comment">// Normalize the target capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fastWritable = maxFastWritableBytes();</span><br><span class="line">    <span class="comment">//若可写空间 &gt; 所需空间，新容量 = 写操作索引 + 可写空间大小</span></span><br><span class="line">    <span class="comment">//否则先创建一个buf，容量为calculateNewCapacity()</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable</span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新容量的值，调用本地的copy方法来将旧数组复制到新数组中。</span></span><br><span class="line">    <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALCULATE_THRESHOLD = <span class="number">1048576</span> * <span class="number">4</span>; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateNewCapacity</span><span class="params">(<span class="keyword">int</span> minNewCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    checkPositiveOrZero(minNewCapacity, <span class="string">&quot;minNewCapacity&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; maxCapacity) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                <span class="string">&quot;minNewCapacity: %d (expected: not greater than maxCapacity(%d)&quot;</span>,</span><br><span class="line">                minNewCapacity, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阈值为4MB</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threshold = CALCULATE_THRESHOLD; <span class="comment">// 4 MiB page</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity == threshold) &#123;</span><br><span class="line">        <span class="keyword">return</span> threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If over threshold, do not double but just increase by threshold.</span></span><br><span class="line">    <span class="comment">// 超过阈值时每次扩容4MB</span></span><br><span class="line">    <span class="keyword">if</span> (minNewCapacity &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = minNewCapacity / threshold * threshold;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; maxCapacity - threshold) &#123;</span><br><span class="line">            newCapacity = maxCapacity;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newCapacity += threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not over threshold. Double up to 4 MiB, starting from 64.</span></span><br><span class="line">    <span class="comment">// 若小于阈值从64开始翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">        newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(newCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优点">优点</h3>
</blockquote>
<blockquote>
<p>池化的方式提高了内存的使用率。</p>
<p>提出了复合型缓冲区的整合方案。</p>
<p>增加了读写指针，使读写分离。</p>
<p>解决了ByteBuffer长度固定的问题。</p>
<p>使用引用计数的方式进行对象回收。</p>
</blockquote>
<h2 id="channel-1">Channel</h2>
<blockquote>
<p>Channel是通讯的载体，对应通讯的一端，在BIO中对应Socket，Nio中对应SocketChannel。Netty对应NioSocketChannel。</p>
<p>channelHandler是通道的处理器，一个channel往往有多个handler。</p>
<p>channelpipeline是handler的容器，装载并管理hanlder的顺序(本质双向链表)。</p>
<p>一个Channel对应一个channelpipeline，一个channelpipeline对应一个或多个channelHandler。</p>
</blockquote>
<h3 id="流程">流程</h3>
<blockquote>
<p>channel创建时，会对应创建一个channelPipeline，pipeline首先会记录一个头部处理器handler，当pipeline进行分发时，先分发给头部，然后依次进行，执行handler全部执行完成。</p>
<p>同时，channel创建后，会注册到EventLoop之中，EventLoop会监听事件的发生，不同事件调用handler不同的处理方法，让流程运转起来。</p>
<p>channel生命周期：</p>
<p>​ ChannelUnregistered：已创建但未被注册到监听器中。</p>
<p>​ ChannelRegistered：已注册到监听器EventLoop中。</p>
<p>​ ChannelActive：连接完成处于活跃状态，此时可以接收和发送数据。</p>
<p>​ ChannelInactive：非活跃状态，代表连接未建立或已断开。</p>
<p>channelHandler生命周期，对应三种状态，分别为：</p>
<p>​ handlerAdded：把handler添加到pipeline之中。早于ChannelRegistered</p>
<p>​ handlerRemove：从pipeline移除。晚于ChannelUnregistered</p>
<p>​ exceptionCaught：处理过程中有错误产生。</p>
</blockquote>
<h3 id="channel创建流程">Channel创建流程</h3>
<blockquote>
<p>开始时先利用ServerBootstrap来设定channel的类型，产生对应的channel工厂。然后在调用bind方法时底层会利用反射机制创建对应的channel对象。</p>
<p>bind方法主要分为两步，第一步为利用反射机制创建对应的channel对象，然后对对象进行init。第二步为注册</p>
<p>创建出对象后调用init方法，先利用ServerBootstrap给channel设置属性，然后获取channel对应的pipeline，再将ServerBootstrap设置的子通道childOptions、childAttrs拷贝给临时变量，并获取currentChildGroup、currentChildHandler最后再利用pipeline.addlast方法将ChannelInitializer传入pipeline(创建了Acceptor，起到将主reactor接收到的客户端通道传递给从reactor)。</p>
<p>init完成后，再调用register方法对channel进行注册。</p>
<p>注册流程为将eventLoop和channel绑定，然后判断当前线程是否为指定线程，若是则直接调用register0方法，否则将任务放入队列中，并启动一个新线程来执行任务。register0方法本质上是调用NIO的register方法将channel注册进selector中进行监听。</p>
<p>最后执行的任务会是NioEventLoop中的run方法，具体流程为，先判断队列中是否存在任务，若不存在任务则设置搜索策略为SELECT，调用select方法进行获取。然后对事件集合进行处理使用processSelectedKeys()方法，对具体事件处理时调用processSelectedKey()，processSelectedKey方法中便是根据事件的类型调用不同的方法(模板方法模式)，如读事件则调用read方法，调用read方法的主要逻辑为：分配一个ByteBuf，然后利用pipeline调用其内部每个handler的fireChannelRead方法，若读完成则调用pipeline中每个handler的fireChannelReadComplete，若发生异常则会调用pipeline中每个handler的fireExceptionCaught方法。</p>
</blockquote>
<h3 id="channelhandler">ChannelHandler</h3>
<blockquote>
<p>以入站和出站的角度设计的。</p>
<p>handler从一端开始，到另一端结束，以责任链的模式依次执行。</p>
<p>使用了责任链模式和适配器模式。</p>
<p>ChannelInboundHandler、ChanneOutboundHandler、ChanneDuplexHandler(包含出站、入站)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoggingHandler extends ChannelDuplexHandler </span><br><span class="line">ChannelDuplexHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandler</span><br><span class="line">ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler</span><br></pre></td></tr></table></figure>
<p>ChannelHandlerAdapter提供了额外的isSharable()方法，用来判断handler是否可以被共享到多个pipeline之中。默认不共享，若需要启用，则要在对应的继承了适配器的handler上增加注解@Sharable</p>
<p>继承ChannelInboundHandlerAdapter实现handler时最重要的方法是channelRead()，在使用时需要显式的释放ByteBuf相关的内存。使用ReferenceCountUtil工具类。</p>
<p>继承SimpleChannelInboundHandler实现handler时，使用其channelRead0()方法可以自动释放资源，使用更加便利。</p>
</blockquote>
<h3 id="channelpipeline">ChannelPipeline</h3>
<blockquote>
<p>pipeline维护入站和出站链路的执行顺序。</p>
<p>handler只负责处理自身的业务逻辑，对通道而言，它是无状态的。通道的信息会保存到handlerContext处理器上下文中。</p>
<p>pipeline管理的是由handlerContext包裹的handler，也就是说当添加handler时，先将其转为handlerContext，然后添加到pipeline的双向链表中。头结点叫HeadContext，尾结点叫TailContext。</p>
<p>addLast的逻辑：本质上就是在双向链表中添加一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前handler是否是sharable的，若不是且被其他通道添加则抛出异常</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">		<span class="comment">//将handler包装成AbstractChannelHandlerContext</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">		<span class="comment">//将newCtx添加到链表尾部</span></span><br><span class="line">        <span class="comment">//构造器会提前创建头尾节点</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span></span><br><span class="line">        <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">        <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            <span class="comment">//添加一个任务，当通道被注册后，能够回调handlerAdded方法</span></span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//若已被注册则执行调用handlerAdded方法</span></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用pipeline模式的优点：</p>
<p>解耦，让处理器逻辑独立，可以被多个channel共享。</p>
<p>channel相关信息由context维护。</p>
<p>使用处理器具有极大的灵活性，可以方便的添加或删除，或更改顺序。</p>
</blockquote>
<h2 id="eventloop对应selector">EventLoop对应Selector</h2>
<blockquote>
<p>事件循环。封装了reactor模型。监听IO事件，内部封装了线程。</p>
<p>当新建channel时，group会为其分配一个EventLoop，封装了nio中的Selector，监听通道中的所有事件，一个通道的生命周期中，所有操作都由相同的EventLoopGroup所封装的线程处理。同时多个通道可以由一个EventLoopGroup处理。</p>
</blockquote>
<h3 id="eventloopgroup">EventLoopGroup</h3>
<blockquote>
<p>初始化时，会调用默认构造器，然后调用到EventLoopGroup的父类MultithreadEventLoopGroup的构造方法设置线程数为NettyRuntime.availableProcessors() * 2和1中更大的值。最后调用MultithreadEventExecutorGroup构造方法创建。</p>
<p>具体流程为：判断线程数是否小于0，小于0则抛出异常。若executor为空，创建默认executor。然后按照线程数创建对应数量的EventExecutor。若某个EventExecutor创建异常则全部关闭。其中具体的EventExecutor创建过程则调用子类的newChild方法实现。(模板方法)然后根据创建的EventExecutor数量选择对应的选择器chooser，本质上是按数量是否为2的次幂选择的。再给每个EventExecutor设置线程终止的监听器，然后将产生的EventExecutor放入集合中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="eventloop">EventLoop</h3>
</blockquote>
<blockquote>
<p>重要属性Selector 及其父类的父类属性Thread</p>
<p>Thread用于轮询，在channel注册之后启动线程。</p>
<p>轮询的流程为：查询I/O事件是否就绪 -&gt; 处理就绪事件 -&gt; 处理SelectionKey -&gt; 分发结果</p>
</blockquote>
<h2 id="bootstrap启动流程">Bootstrap启动流程</h2>
<blockquote>
<p>bootstrap：引导，对应用程序进行配置，并让他运行。</p>
</blockquote>
<h2 id="future和promise">Future和Promise</h2>
<blockquote>
<p>Future表示一个可能还没有实际完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后做出对应操作。</p>
<p>Future接口就是用于封装异步操作的执行状态的，在执行异步操作时可以立马返回一个Future，Future可以通过Sync方法来等待执行结果。可以通过future.addListener()的方式来在之前的异步操作完成时执行新操作。</p>
<p>Future代表的是一个还没有完成的异步任务的执行结果，可以通过addListener方法，监听执行结果后进行相应的处理，此时它的状态可以分为未完成、已完成(成功、失败、主动取消)等，对Future而言，状态只能读取，无法更改，又出现了Promise，但是Promise只能更改一次。</p>
</blockquote>
<h2 id="心跳检测的实现">心跳检测的实现</h2>
<blockquote>
<p>检测逻辑：</p>
<p>​ 服务端启动，客户端建立连接，连接的目的是互相发送信息。</p>
<p>​ 如果客户端在工作，服务端一定可以收到数据，如果客户端空闲，服务端会出现资源浪费。</p>
<p>​ 服务端需要一种检测机制，验证客户端的活跃状态，不活跃则关闭。</p>
<p>Netty实现的方式：IdleStateHandler提供了readerIdleTime，writerIdleTime，allIdleTime三个用于判断多长时间没有读、多长时间没有写、多长时间没有读写。</p>
<p>底层实现检测的是IdleStateEvent事件，通过管道传递给下一个handler处理，处理方法是userEventTriggered。</p>
</blockquote>
<h2 id="tcp粘包和拆包及解决方案">TCP粘包和拆包及解决方案</h2>
<blockquote>
<p>TCP是流协议，基于字节流，没有界限，只会根据TCP缓冲区的情况进行拆分，所以业务上完整的包可能被拆分为多个进行发送。</p>
<p>粘包即：两个较短的包被合成一个包发送</p>
<p>拆包即：一个较长的包被拆分成两个包发送</p>
<p>UDP则不会发生粘包和拆包，因为UDP不是基于流的，UDP是基于报文的。在UDP的首部使用16bit存储报文的长度，因此不会发生。</p>
<p>TCP发生粘包和拆包的本质原因：</p>
<p>要发送的数据先经过TCP缓冲区。</p>
<p>​ 若要发送的数据 &gt; TCP剩余的缓冲区大小，发生拆包。</p>
<p>​ 若要发送的数据 &gt; 最大报文长度，发送拆包。</p>
<p>​ 若要发送的数据 &lt;&lt; TCP剩余的缓冲区大小，发生粘包(Nagle算法，要求TCP连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组)</p>
<p>​ 若接收数据的应用层没有及时读取缓冲区数据，也会发送粘包</p>
<p>解决方案：</p>
<p>​ 设置消息长度</p>
<p>​ 设置消息的边界---分隔符</p>
<p>Netty提供的解码器，两类。</p>
<p>A 基于长度的解码器，在包头设置出数据的长度。</p>
<p>​ LengthFiledBasedFrameDecoder ---- 自定义长度的处理方式</p>
<p>​ FixedLengthFrameDecoder ---- 固定长度的处理方式</p>
<p>B 基于分隔符的解码器</p>
<p>​ DelimiterBasedFrameDecoder --- 自定义分隔符</p>
<p>​ LineBaseFrameDecoder ---- 行尾符(""或"")分隔</p>
</blockquote>
<h2 id="序列化">序列化</h2>
<blockquote>
<p>将一个对象的状态保存起来，在需要时获取。</p>
<p>主要应用于网络传输和对象持久化。</p>
<p>原生序列化(java提供的)方式的缺点：</p>
<p>​ 无法跨语言</p>
<p>​ 序列化结果很大</p>
<p>​ 序列化耗时很长，性能低。</p>
<p>常用的序列化框架：</p>
<p>​ Protobuf (Google)</p>
<p>​ Thrift (Facebook)</p>
<p>​ Json (Gson/FastJson)</p>
</blockquote>
<h2 id="nagle算法和延迟确认捎带确认可能造成的问题">Nagle算法和延迟确认/捎带确认可能造成的问题</h2>
<blockquote>
<p>当程序为写-写-读时，导致第二次写需要超时才能发出。</p>
</blockquote>
<h2 id="udp实现">UDP实现</h2>
<h3 id="原生">原生</h3>
<blockquote>
<p>使用DatagramSocket代表通信的一端。</p>
<p>使用DatagramPacket传输数据。</p>
<p>使用socket的send和receive方法来发送、接收数据。</p>
</blockquote>
<h3 id="netty实现">Netty实现</h3>
<blockquote>
<p>DatagramSocket对应NioDatagramChannel</p>
<p>DatagramPacket改为netty提供的DatagramPacket</p>
<p>无论服务端还是客户端都是用Bootstrap启动。</p>
<p>通过调用Bootstrap的localAddress指定端口号，也可以调用remoteAddress()指定连接地址。</p>
<p>自定义handler，继承SimpleChannelInboundHandler<DatagramPacket>。</DatagramPacket></p>
<p>主要逻辑仍是channelRead0方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>计算机网络</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>网络</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
</search>
