<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-leaf.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-leaf.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-leaf.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"49.234.221.130","root":"/","images":"/images","scheme":"Pisces","version":"8.2.1","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="Ye的个人技术记录博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Yesomething">
<meta property="og:url" content="http://49.234.221.130/page/4/index.html">
<meta property="og:site_name" content="Yesomething">
<meta property="og:description" content="Ye的个人技术记录博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ye">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://49.234.221.130/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Yesomething</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yesomething</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Ye's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fas fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ye"
      src="/uploads/photo.jpg">
  <p class="site-author-name" itemprop="name">Ye</p>
  <div class="site-description" itemprop="description">Ye的个人技术记录博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/YeHIT" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YeHIT" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1044377312@qq.com" title="E-Mail → mailto:1044377312@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/YeHIT" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://49.234.221.130/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/photo.jpg">
      <meta itemprop="name" content="Ye">
      <meta itemprop="description" content="Ye的个人技术记录博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yesomething">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/" class="post-title-link" itemprop="url">Mysql突击</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-13 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-13T00:00:00+08:00">2021-03-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-20 13:37:28" itemprop="dateModified" datetime="2021-03-20T13:37:28+08:00">2021-03-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/" itemprop="url" rel="index"><span itemprop="name">面试突击</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="mysql突击">Mysql突击</h1>
<h2 id="基础知识">基础知识</h2>
<h3 id="基本sql语句">基本sql语句</h3>
<h4 id="dml数据操作语言">DML(数据操作语言)</h4>
<blockquote>
<p><em>SELECT</em> 、UPDATE、DELETE、INSERT INTO</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查找记录，可以附带条件语句，和分页语句</span><br><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[LIMIT N][<span class="keyword">OFFSET</span> M]</span><br></pre></td></tr></table></figure>
<p>INSERT INTO TABLE_NAME (field1,field2,.....) VALUES(值1,值2,.....)</p>
<p>UPDATE TABLE_NAME SET COL = XXX WHERE COL = YYY 更改表数据</p>
<p>DELETE FROM TABLE_NAME WHERE COL = XXX 删去表中的行</p>
</blockquote>
<h4 id="ddl数据定义语言">DDL(数据定义语言)</h4>
<blockquote>
<p>CREATE DATABASE 数据库名：创建数据库</p>
<p>DROP DATABASE 数据库名：删除数据库</p>
<p>USE DATABASE 数据库名：选用数据库</p>
<p>ALTER DATABASE：变更数据库</p>
<p>CREATE TABLE 表名(列名 列类型，......)：创建数据库表</p>
<p>DROP TABLE;删除表</p>
<p>ALTER TABLE TABLE_NAME DROP COL：删去表格对应列。</p>
<p>ALTER TABLE TABLE_NAME ADD COL TYPE：在表格中增加对应列。</p>
<p>ALTER TABLE TABLE_NAME MODIFY COL TYPE：修改表格中对应列类型</p>
<p>ALTER TABLE TABLE_NAME CHANGE COL1 COL2 TYPE：将表格中COL1列改为COL2列，且指定为TYPE类型</p>
<p>CREATE INDEX;创建索引</p>
<p>DROP INDEX;删除索引</p>
</blockquote>
<h3 id="mysql数据类型">Mysql数据类型</h3>
<blockquote>
<p>数值类型：</p>
<p>​ TINYINT：1个byte 8位</p>
<p>​ SMALLINT：2个bytes 16位</p>
<p>​ MEDIUMINT：3个bytes 24位</p>
<p>​ INT/INTEGER：4bytes 32位</p>
<p>​ BIGINT：8bytes 64位</p>
<p>​ FLOAT：4bytes 32位 单精度浮点数</p>
<p>​ DOUBLE：8bytes 64位 双精度浮点数</p>
<p>​ DECIMAL(a,b)：a指定整数位数，b指定小数位数，适用于高精度场景。默认值10,0</p>
<p>日期和时间类型：</p>
<p>​ DATE：3bytes，格式YYYY-MM-DD，存储日期值</p>
<p>​ TIME：3bytes，格式HH:MM:SS，存储时间值</p>
<p>​ YEAR：1byte，格式YYYY，年份值</p>
<p>​ DATETIME：8bytes，格式YYYY-MM-DD HH:MM:SS，混合了日期和时间值</p>
<p>​ TIMESTAMP：4bytes，存储时间戳。比DATETIME空间效率更高，但是表示的时间范围小。</p>
<p>字符串类型：</p>
<p>​ CHAR：0~255bytes，定长字符串。适合存储很短的字符串，或者所有值都接近同一个长度，如用于存储密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于非常短的列CHAR比VARCHAR在存储空间上更有效率。</p>
<p>​ VARCHAR：0~65535bytes，变长字符串。比定长类型更节省空间因为它只使用必要的空间。VARCHAR需要一个或2个额外字节记录字符串的长度，若列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。它节省了空间但由于它是变长的，所以可能导致特殊情况。如一个行占用的空间增长，且页内没有更多的空间可以存储，在这种情况下不同的存储引擎操作不同。MyISAM会将行拆成不同片段存储，InnoDB通过分裂页来使行可以放入业内。</p>
<p>​ TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB：存储2进制数据，依次为<span class="math inline">\(2^8,2^{16},2^{24},2^{32}\)</span> B</p>
<p>​ TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT：存储文本数据，依次为<span class="math inline">\(2^8,2^{16},2^{24},2^{32}\)</span> B</p>
<p>BLOB和TEXT值太大时，InnoDB会使用专门的外部存储区域来存储，此时每个值在行内需要1~4个字节存储指针，然后在外部存储区域存储实际的值。</p>
</blockquote>
<h3 id="mysql操作符及字句">Mysql操作符及字句</h3>
<blockquote>
<p>UNION：连接两个以上的SELECT语句，将结果组合到数据集中。多个SELECT语句会删除重复的数据。</p>
<p>DISTINCT：表示该值不可重复。如SELECT DISTINCT NAME FROM TABLE_NAME;可以过滤多余的重复记录。</p>
<p>WHERE 字句：设置条件。如SELECT NAME FROM TABLE_NAME WHERE ID &gt; 0；只会查询出id&gt;0的NAME。WHERE字句的格式：WHERE 列 运算符 值。</p>
<p>​ 可以使用的运算符：=，&lt;&gt;(不等于)，&gt;，&lt;，&gt;=，&lt;=，BETWEEN(在某个范围内)，LIKE(搜索某种模式，如LIKE "A%")</p>
<p>​ LIKE支持的通配符：%代替一个或多个，_代替一个字符，[charlist]代替字符列的任意一个字符，[!charlist]或[^charlist]代替除了字符列之外的任意一个字符。</p>
<p>IN(V1,V2,....)/ IN(子查询)：在V1，V2....之中的记录。</p>
<p>AND和OR：可以基于一个及以上条件对记录进行过滤，如WHERE A AND B; 过滤出当A且B的条件满足的记录。</p>
<p>ORDER BY 列名：按xxx列排序，如 ORDER BY COL1，COL2 DESC 表示记录按COL1降序排列，若COL1相同则按COL2降序排列，或后跟ASC表示升序排列。</p>
<p>SELECT * FROM TABLE_NAME LIMIT NUMBER 返回number数量的值。</p>
<p>GROUP BY：根据一个或多个列对结果集进行分组</p>
<p>IS NULL：判断值为空</p>
<p>IS NOT NULL：判断值不为空</p>
<p>EXISTS和NOT EXISTS (sub)：判断该子句是否存在结果。</p>
<p>ANY (subquery)：对结果任一满足条件即可。如 where A &gt; ANY(SELECT * FROM TABLE);即为若A＞子查询任意记录的值即可。相当于多个OR语句</p>
<p>SOME(subquery)：和ANY一样。</p>
<p>ALL(subquery)：要求同时满足，相当于多个AND语句。</p>
<p>REGEXP ‘正则表达式’：在条件中使用正则表达式匹配。</p>
</blockquote>
<h3 id="mysql连接的使用">Mysql连接的使用</h3>
<blockquote>
<p>内连接：<strong>INNER JOIN</strong>、<strong>JOIN</strong>、<strong>CROSS JOIN</strong>。是等价的，都返回笛卡尔积。</p>
<p>外连接：<strong>LEFT JOIN</strong>、<strong>RIGHT JOIN</strong>、<strong>NATURAL JOIN</strong>，分别为左连接，右连接，自然连接。均可以省略OUTER关键字。即<strong>LEFT JOIN = LEFT OUTER JOIN</strong></p>
<p><strong>LEFT JOIN</strong>：会读取左边数据表的全部数据，即使右边表无数据</p>
<p><strong>RIGHT JOIN</strong>：会读取右边数据表的全部数据，即使左边表无数据。</p>
<p><strong>NATURAL JOIN</strong>：是对两张表中字段名和数据类型都相同的字段进行等值连接，并符合符合条件的结果。注意只能有一个列符合条件。</p>
</blockquote>
<h2 id="mysql结构">Mysql结构</h2>
<blockquote>
<figure>
<img src="/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/Mysql架构.png" alt="Mysql架构"><figcaption aria-hidden="true">Mysql架构</figcaption>
</figure>
<p>最上层是连接器即客户端同Mysql连接的架构，提供连接处理、授权认证、安全等功能。</p>
<p>第二层是Mysql的服务层，包括Mysql核心服务功能：解析、分析、优化、缓存及内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。有分析器、优化器、执行器、查询缓存等组件。</p>
<p>最底层即第三层是存储引擎层，Mysql可以使用多种存储引擎如：InnoDB、MyISAM、Memory，存储引擎负责Mysql中数据的存取。</p>
</blockquote>
<h3 id="各组件功能">各组件功能</h3>
<blockquote>
<p>连接器：负责和客户端建立连接、获取权限、维持和管理连接。每个服务端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或CPU中运行。服务器会缓存线程，不需要为每个新建的连接创建或销毁线程。连接过程服务端还会对客户端进行认证，认证基于用户名、原始主机信息和密码。</p>
<p>分析器：有词法分析、语法分析两个功能。对于一个SQL语句，分析器先进行词法分析，对SQL进行拆分，识别出各个字符串代表的含义。然后进行语法分析，分析器根据定义的语法规则判断SQL是否满足Mysql语法。</p>
<p>优化器：优化器在获取分析器的结果后，通过表结构和SQL语句选择执行方案，比如：多表关联时，各个表如何进行连接；当表中有索引时，应该怎样选择索引。</p>
<p>执行器：获取到执行方案后，执行器会根据表的引擎定义，去使用引擎提供的接口。查询过程Mysql执行器内部执行步骤：</p>
<p>​ 1、调用引擎接口取这个表的第一行，判断该行是否满足WHERE字句，若满足则将这行存在结果集中，否则跳过。</p>
<p>​ 2、调用引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行。</p>
<p>​ 3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
<p>​ UPDATE操作的处理逻辑(InnoDB引擎)：</p>
<p>​ 1、Mysql Server发送更新请求到InnoDB引擎。</p>
<p>​ 2、从Buffer Pool加载对应记录的Data Page，若Buffer Pool中没有该记录，则从磁盘中读取记录。</p>
<p>​ 3、将P1存储到Undo Page中，并在Redo Log Buffer中记录Undo操作。</p>
<p>​ 4、更新P1为P1‘，并将P1’写入Dirty Page，记录变更到Redo Log Buffer(Prepare状态)。</p>
<p>​ 5、返回Mysql Server执行完成。</p>
<p>​ 6、Mysql Server 记录binlog。</p>
<p>​ 7、Mysql Server 提交commit。</p>
<p>​ 8、 Redo Log Buffer状态由Prepare 更改为Commit，并刷入磁盘。</p>
<p>​ 9、当Dirty Page过多时，启动ChechPoint机制，将脏页刷入磁盘。</p>
</blockquote>
<h3 id="存储引擎">存储引擎</h3>
<blockquote>
<p>使用SHOW TABLE STATUS可以查看表的相关信息。</p>
</blockquote>
<h4 id="innodb存储引擎">InnoDB存储引擎</h4>
<blockquote>
<p>InnoDB是Mysql的默认事物引擎。被设计用来处理大量短期事务，短期事务大部分情况是正常提交，少部分被回滚。</p>
<p>InnoDB的数据存储在表空间，表空间是InnoDB管理的黑盒，由一系列数据文件组成。</p>
<p>InnoDB采用MVCC来支持高并发，并实现了四个标准的隔离级别，默认隔离级别是REPEATABLE READ，并提供间隙锁策略来防止幻读出现。间隙锁让InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入。</p>
<p>InnoDB表是基于聚簇索引建立的。InnoDB的索引结构和Mysql的其他存储引擎存在很大不同，聚簇索引对主键查询有很高的性能，但是它的二级索引必须包含主键列，所以如果主键列很大，那么其他的所有索引都会很大。</p>
<p>InnoDB还做了许多优化，如从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，能加速插入操作的插入缓冲区等。</p>
<p>InnoDB通过一些机制和工具支持真正的热备份。</p>
</blockquote>
<h4 id="myisam">MyISAM</h4>
<blockquote>
<p>MyISAM不支持事务和行级锁，不能热备份，且崩溃后无法安全恢复。当对于只读的数据或者表比较小、可以忍受修复操作，可以使用MyISAM。</p>
<p>MyISAM的特性：</p>
<p>​ 加锁和并发：MyISAM对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但当表有读取查询时，也可以往表中插入新记录。</p>
<p>​ 修复：可以手工或自动执行检查和修复操作。但是执行表的修复可能导致数据丢失。</p>
<p>​ 索引特性：对于MyISAM表即使是BLOB和TEXT长字段，也可以基于前500个字符创建索引。也支持全文索引。</p>
<p>​ 压缩表：即使用myisampack对MyISAM进行压缩，压缩表是不能进行修改的(除非先解压缩，修改数据，再压缩)，压缩表可以减少磁盘占用，也减少磁盘I/O。</p>
</blockquote>
<h4 id="innodb和myisam的区别">InnoDB和MyISAM的区别</h4>
<h5 id="事务">事务</h5>
<blockquote>
<p>MyISAM：不支持事务。</p>
<p>InnoDB：支持事务。</p>
</blockquote>
<h5 id="外键">外键</h5>
<blockquote>
<p>MyISAM：不支持外键。</p>
<p>InnoDB：支持外键。</p>
</blockquote>
<h5 id="索引">索引</h5>
<blockquote>
<p>InnoDB使用聚簇索引和辅助(非聚簇)索引。实现方式都是B+树，但基于聚簇索引的查询，InnoDB查询的结果为具体的数据，而基于辅助索引的查询，查询的结果为对应的主键。即B+树的叶子节点是存储的数据一个是整个记录，一个是对应的主键。</p>
<p>MyISAM使用非聚簇索引。实现方式是B+树，非聚簇索引的两颗树没有什么不同，区别在于叶子节点存储的是具体数据的地址。无论是主键查询，还是基于辅助索引查询，都可以直接获取具体数据的地址。索引和数据是分离的。</p>
</blockquote>
<h5 id="锁">锁</h5>
<blockquote>
<p>InnoDB支持表、行(默认)级锁。InnoDB行锁是实现在索引上的，若访问没有命中索引，无法使用行锁，要退化为表锁。</p>
<p>MyISAM支持表级锁。</p>
</blockquote>
<h4 id="存储引擎的切换">存储引擎的切换</h4>
<blockquote>
<p>ALTER TABEL table_name ENGINE = XXXX</p>
<p>导入导出：使用mysqldump工具将数据导出到文件，然后修改文件中CREATE TABLE语句中存储引擎选项。</p>
<p>创建和查询：即先创建一个同结果的表，然后修改表存储引擎，最后使用insert into 配合select将旧数据插入到新表。</p>
</blockquote>
<h2 id="mysql事务">Mysql事务</h2>
<h3 id="事务的基本特性acid">事务的基本特性ACID</h3>
<blockquote>
<p>A：原子性，即一个事务的操作要么全部完成，要么全部不完成。</p>
<p>C：一致性，即在事务开始之前和之后数据库的完整性没有被破坏。所有写入的规则都必须完全符合所有预设规则。</p>
<p>I：隔离性，数据库对多个并发事务同时对其数据进行读写和修改的能力。</p>
<p>D：持久性，事务处理结束后，对数据库的修改就是永久的。</p>
</blockquote>
<h3 id="事务隔离级别">事务隔离级别</h3>
<blockquote>
<p>READ UNCOMMITTED：读未提交，即事务中的修改即使没有提交，对其他事务也是可见的。存在脏读、不可重复读、幻读的问题</p>
<p>READ COMMITED：读已提交，一个事务开始时只能看见已经提交的事物所做的修改。解决了脏读的问题。</p>
<p>REPEATABLE READ：可重复读，Mysql的默认事物隔离级别。解决了不可重复读的问题，保证了在同一个事务中多次读取同样记录的结果是一致的。解决了脏读和不可重复读的问题。</p>
<p>SERIALIZABLE：串行化。最高的隔离级别，强制事务串行处理，避免了幻读问题。</p>
<p>脏读：会读到其他事务没有提交的内容。</p>
<p>不可重复读：执行两次同样的查询可能得到不一样的结果，即其他事务修改了当前读取的记录。</p>
<p>幻读：指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新记录，当之前的事务再次读取该范围的记录时，会产生幻行。</p>
</blockquote>
<h3 id="多版本并发控制mvcc">多版本并发控制MVCC</h3>
<blockquote>
<p>MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，开销更低。只在READ COMMITED和REPEATABLE READ下工作，因为READ UNCOMMITED总是读取最新的数据行。SERIALIZABLE会对所有读取的行都加锁。</p>
<p>MVCC的实现是通过保存数据在某个时间点的快照来实现的，也就是说不管需要执行多次时间，每个事务看到的数据都是一致的。根据事务开始时间的不同，不同事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>理论上的MVCC需要保存数据的创建时间和过期时间来控制版本。</p>
<p>InnoDB的MVCC，是通过在每行记录后保存两个隐藏的列来实现的。这两个列一个保存了DATA_TRX_ID事务ID，一个保存DATA_ROLL_PTR回滚指针。每开启一个新的事务并执行增删改，系统版本号将会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用于和查询到的每行记录的版本号进行比较。此外若表中没有显式定义主键/没有唯一索引，Mysql会自动创建一个6字节的row id存入记录中，即DB_ROW_ID。同时InnoDB还会使用删除标志位来确保删除操作不可见。</p>
<p>语句更新时会生成undo log即回滚日志，用于从某个版本回退到历史版本。故而MVCC的本质就是保持多个不同版本的数据。</p>
<p>而解决脏读和不可重复读问题，则是基于MVCC并配合一致性视图ReadView的。</p>
</blockquote>
<h4 id="一致性视图readview">一致性视图ReadView</h4>
<blockquote>
<p>其中RR和RC生成视图的时间不同，RR是在事务开启/执行第一条SELECT语句时产生一致性视图，RC则是在每条语句执行前生成一次一致性视图。</p>
<p>一致性视图主要由m_ids即当前活跃的事务列表，up_limit_id最小活跃的事务，low_limit_id最大活跃事务，及m_creator_trx_id创建该视图的事务id。</p>
<p>而具体查询的流程进行如下操作：</p>
<p>​ 如果被访问版本的 trx_id 小于 m_ids 中的最小值 up_limit_id，说明生成该版本的事务在 ReadView 生成前就已经提交了，所以该版本可以被当前事务访问。</p>
<p>​ 如果被访问版本的 trx_id 大于 m_ids 列表中的最大值 low_limit_id，说明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。需要根据 Undo Log 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。 ​ 如果被访问版本的 trx_id 属性值在 m_ids 列表中最大值和最小值之间（包含），那就需要判断一下 trx_id 的值是不是在 m_ids 列表中。如果在，说明创建 ReadView 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 DB_TRX_ID 再从头计算一次可见性；如果不在或为创建该视图的事务id，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</p>
<p>此时就会存在当前读和快照读的区别：</p>
<p>​ 当前读指在事务开启后，执行更新语句时会读取当前数据库中最新的数据，即可以读到在事务开启之后提交的数据用于更新，避免数据操作丢失。</p>
<p>​ 快照读指的是事务开启后，只能读出当前事务id之前操作的值，用于避免读取的数据是不可重复读的。</p>
<p>当前读和快照读的触发时机：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">快照读</th>
<th style="text-align: center;">当前读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">RR事务隔离级别情况下，不显式加锁的读操作</td>
<td style="text-align: center;">显式加锁的读操作和增删改等写操作</td>
</tr>
</tbody>
</table>
<p>在读提交情况下一致性视图是在每次执行语句创建的，在可重复读的情况下一致性视图是在创建事务时创建的。</p>
</blockquote>
<h4 id="repeatable-read下mvcc的具体操作">REPEATABLE READ下MVCC的具体操作</h4>
<blockquote>
<p>SELECT：InnoDB会根据以下条件来检查记录</p>
<p>​ InnoDB只查找版本&lt;=当前事务版本的数据行，这样可以确保事务读取的行要么是事务开启前已经存在的，要么是事务自身插入或修改过的。</p>
<p>​ 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行在事务开始之前没有被删除。</p>
<p>INSEART：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除表示。</p>
<p>UPDATE：InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>
</blockquote>
<h3 id="事务隔离级别的实现">事务隔离级别的实现</h3>
<blockquote>
<p>可重复读RR(Repeatable Read)：在Mysql中每条记录在更新时会同时记录一条回滚操作。记录上的最新值可以通过回滚操作得到前一个状态的值。同一条记录在系统中可以存着多个版本，即MVCC。其中回滚日志会在系统中没有比这个回滚日志更早的read-view时删除。(因此最好不要使用长事务。)</p>
</blockquote>
<h3 id="innodb上锁操作">InnoDB上锁操作</h3>
<blockquote>
<p>上锁分为隐式锁定和显式锁定。</p>
<p>InnoDB采用的是两阶段锁定协议，在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。这就是隐式锁定，InnoDB会根据隔离级别在需要时自动加锁。</p>
<p>显示锁定：</p>
<p>​ 如SELECT .... LOCK IN SHARE MODE</p>
<p>​ SELECT .... FOR UPDATE</p>
</blockquote>
<h3 id="事务日志">事务日志</h3>
<blockquote>
<p>事务日志可以提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再将该修改行为记录到持久在硬盘上的事务日志中，而不用每次将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域的顺序I/O，而非随机I/O需要在磁盘的多个地方移动磁头。事务日志持久后，内存被修改的数据在后台可以被慢慢地刷回磁盘。这是目前大多数存储引擎的实现方式，被叫作预写式日志，修改数据需要写两次磁盘。</p>
</blockquote>
<h3 id="事务基本操作">事务基本操作</h3>
<blockquote>
<p>BEGIN/START TRANSACTION：开启事务。</p>
<p>COMMIT/COMMIT WORK：提交事务。</p>
<p>ROLLBACK/ROLLBACK WORK：回滚事务。</p>
<p>SAVEPOINT IDENTIFIER：在事务中创建一个保存点。</p>
<p>RELEASE SAVEPOINT IDENTIFIER：删除一个事务的保存点，当没有指定的保存点时会抛出异常。</p>
<p>ROLLBACK TO IDENTIFIER：把事务回滚到保存点。</p>
<p>SET TRANSACTION 隔离级别：设置事务的隔离级别。READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</p>
</blockquote>
<h2 id="mysql索引">Mysql索引</h2>
<blockquote>
<p>索引可以大大提高查询速度，但会降低更新表的速度，因为更新表时Mysql不仅要保存数据还需要保存索引文件。同时索引也会占用磁盘空间的索引文件。</p>
<p>创建索引：</p>
<p>​ CREATE INDEX INDEX_NAME ON TABLE_NAME()</p>
<p>唯一索引：UNIQUE INDEX。索引值必须是唯一的，除了NULL之外。可能出现多个NULL。</p>
<p>主键索引：PRIMARY KEY。索引值必须是唯一的且不能为NULL。</p>
<p>普通索引：INDEX。索引值可以出现多次。</p>
<p>全文索引：FULLTEXT。</p>
</blockquote>
<h3 id="索引的类型">索引的类型</h3>
<h4 id="b-tree索引">B-TREE索引</h4>
<blockquote>
<p>是Mysql对索引的称呼，底层的存储引擎可能采用不同的数据结构。如InnoDB采用的是B+树实现的索引。</p>
<p>B-Tree索引的限制：</p>
<p>​ 若不是按照索引的最左列开始查找，则无法使用索引。如索引是A-B-C，查找B无法利用索引。</p>
<p>​ 不能跳过索引中的列，即若索引是A-B-C，查找A-C则只能利用索引的第一列</p>
<p>​ 若查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。如索引为A-B-C，查询操作中B使用了如LIKE ‘%’的语句，则只能索引索引的前两列。</p>
</blockquote>
<h4 id="哈希索引">哈希索引</h4>
<blockquote>
<p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。只有精确匹配索引所有列的查询才有效。对于每行数据，存储引擎会对所有的索引计算一个哈希码。哈希索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，让哈希索引查找的速度非常快。</p>
<p>哈希索引的限制：</p>
<p>​ 哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。</p>
<p>​ 哈希索引数据不是按照索引值顺序存储的，所以无法用于排序。</p>
<p>​ 哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容计算哈希值的。如索引A-B，查询A无法使用哈希索引。</p>
<p>​ 哈希索引只支持等值比较查询，如=、IN()、&lt;=&gt;(可以判断NULL的=)，不支持任何的范围查询。</p>
<p>​ 访问哈希索引的数据非常快，除非有很多哈希冲突。出现哈希冲突时需要遍历链表里的所有行指针。</p>
<p>​ 如果哈希冲突很多的话，一些索引维护操作的代价也很高。如：删去一行需要在链表中查找到对应行才能删去。</p>
<p>InnoDB的自适应哈希索引：当InnoDB注意到某些索引值被使用得很频繁时，会在内存上基于B-Tree索引上再创建一个哈希索引，这样让B-Tree索引也有哈希索引的一些优点。</p>
<p>创建自定义哈希索引：只需要很小的索引就可以为超长的键创建索引。只需要在B-Tree的基础上创建一个伪哈希索引。使用B-Tree查找，但使用哈希值而非键本身进行索引查找。</p>
</blockquote>
<h4 id="全文索引">全文索引</h4>
<blockquote>
<p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p>
</blockquote>
<h4 id="聚簇索引">聚簇索引</h4>
<blockquote>
<p>聚簇索引不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>当表有聚簇索引时，它的数据行实际上放在索引的叶子页。聚簇是指数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，故一个表只能有一个聚簇索引。InnoDB是通过主键聚集数据。若没有定义主键，InnoDB会选择一个唯一的非空索引代替。若没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。</p>
<p><strong>聚簇索引的优点</strong>：</p>
<p>​ 可以把相关数据保存在一起。如实现电子邮箱时按用户ID聚集数据，这样只需要从磁盘读取少量数据页即可获取用户的全部邮件。</p>
<p>​ 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据往往比非聚簇索引中查找更快。</p>
<p>​ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>
<p><strong>聚簇索引的缺点</strong>：</p>
<p>​ 插入速度严重依赖于插入顺序。若按主键顺序插入速度最快，若不是按主键顺序插入，那加载完成后最好使用OPTIMIZE TABLE命令重新组织表。</p>
<p>​ 更新聚簇索引列的代价很高。因为会强制InnoDB将每个被更新的行移动到新位置。</p>
<p>​ 基于聚簇索引的表在插入新行，或者主键被更新需要移动时，可能存在页分裂的情况。</p>
<p>​ 聚簇索引可能导致全表扫描变慢，特别是当行比较稀疏，或由于页分裂导致数据存储不联系时。</p>
<p>​ 二级索引(非聚簇索引/辅助索引)的空间占用可能较大，因为二级索引叶子节点中包含主键列。</p>
<p>​ 二级索引访问需要两次索引查找而非一次。</p>
<p><strong>聚簇索引的使用</strong>：</p>
<p>​ <strong>最好避免随机的聚簇索引</strong>，即索引值不应该是不连续且值分布访问非常大。因为这会导致聚簇索引的插入变得完全随机。随机的聚簇索引插入不仅花费的时间更长而且索引占用的空间也更大。这既是由于主键字段长，也是由于页分裂和碎片导致的。</p>
<p><strong>采用顺序的主键值插入</strong>，由于主键的值是顺序的，InnoDB会将每一条记录存储在上一条记录的后面，当达到页的最大填充因子时下一条记录会写入新的页中，主键页会被以近似顺序的记录填满：</p>
<figure>
<img src="/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/聚簇索引顺序插入.png" alt="聚簇索引顺序插入"><figcaption aria-hidden="true">聚簇索引顺序插入</figcaption>
</figure>
<p><strong>采用随机的主键值插入</strong>，由于新行的主键不一定比之前插入的大，所以InnoDB不能简单地总把新行插入到索引的最后，而要为新行寻找合适的位置，通常是已有数据的中间位置，且分配空间。这样带来了缺点：</p>
<p>​ 写入的目标页可能已经刷到磁盘上并从缓存中移除，或没有加载到缓存中，InnoDB在插入之前需要先找到并从磁盘中读取目标页到内存。这样导致了随机I/O。</p>
<p>​ 因为写入是乱序的，InnoDB需要频繁地进行页分裂操作，以便为新行分配空间。导致移动大量数据，一次插入至少修改三个页，而非一个页。</p>
<p>​ 由于频繁页分裂，页会变得稀疏且不规则，最终数据会有碎片。</p>
<p><strong>顺序主键的缺点</strong>：并发场景下，InnoDB按主键顺序插入可能造成明显争用。</p>
</blockquote>
<h4 id="覆盖索引">覆盖索引</h4>
<blockquote>
<p>为了避免回表操作，即查询到的数据是主键，还要再用主键查询一次。如果索引的叶子节点包含要查询的数据就不用进行回表操作了。而一个索引包含了所有需要查询的字段的值，我们就称之为覆盖索引。</p>
<p>覆盖索引的优点：</p>
<p>​ 索引条目通常原小于数据行大小，如果只用读取索引，Mysql就会极大地减少数据访问量。覆盖索引也会让I/O密集型应用有帮助，因为索引比数据更小，更容易放入内存中。</p>
<p>​ 索引是按照列值顺序存储的(至少在单页内如此)，所以I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O少得多。</p>
<p>​ 一些存储引擎如MyISAM在内存中只缓存索引，数据依赖操作系统缓存，导致访问数据需要进行系统调用。</p>
<p>​ 由于InnoDB采用聚簇索引，所以覆盖索引对于InnoDB表特别有用。</p>
<p>并非所有类型的索引都可以成为覆盖索引。覆盖索引必须存储索引列的值，而哈希索引、空间索引、全文索引等都不能存储索引列的值，故Mysql只能用B-Tree索引做覆盖索引。</p>
</blockquote>
<h3 id="索引的优缺点">索引的优缺点</h3>
<blockquote>
<p>优点：</p>
<p>​ 索引大大减少了服务器需要扫描的数量。</p>
<p>​ 索引可以帮助服务器避免排序和临时表。</p>
<p>​ 索引可以将随机I/O变为顺序I/O。</p>
<p>缺点：</p>
<p>​ 索引会占据额外空间，此外也降低了更新表的操作效率，因为更新表时Mysql不仅要保存数据还需要保存索引文件。</p>
</blockquote>
<h3 id="高效地使用索引">高效地使用索引</h3>
<h4 id="独立的列">独立的列</h4>
<blockquote>
<p>索引必须是独立的列。如索引为A，查询时使用 A + 1 = X，不会使用索引。即索引列不能是表达式的一部分，也不能是函数的参数。</p>
</blockquote>
<h4 id="索引前缀下推icp">索引前缀下推ICP</h4>
<blockquote>
<p>即在使用索引时若找到索引后若没有ICP则需要先回表然后进行判断where条件，引入ICP后可以直接在找到索引后利用where条件先筛选。</p>
</blockquote>
<h4 id="前缀索引和索引选择性">前缀索引和索引选择性</h4>
<blockquote>
<p>有时索引很长的字符列，索引会变得大且慢，此时可以使用模拟哈希索引，也可以索引开始的部分字符，以节省索引空间，提高索引效率。</p>
<p>索引的选择性是指不重复的索引值和数据报的记录总数的比值。索引选择性越高则查询效率越高，1为最佳。</p>
<p>可以将长度较大的字符列，采用前缀索引的方式，即使用该列的前x个字符作为索引。这样可以使索引更小，更快。但是存在缺点：Mysql不能使用前缀索引进行ORDER BY和GROUP BY操作，也不能使用前缀索引进行覆盖扫描。</p>
<p>而具体选择几个字符作为前缀可以通过计算区分度来决定。即根据需要建立前缀索引列占总体比值，和对应长度前缀占总体比值来判断。</p>
<p>SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;</p>
<p>SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;</p>
<p>但是前缀索引由于是部分信息，所以查找时需要回表操作，不能使用覆盖索引。</p>
</blockquote>
<h4 id="索引使用注意点">索引使用注意点</h4>
<blockquote>
<p>Mysql不能在索引中执行LIKE操作。Mysql5.5及更早的版本中只允许在索引中做简单的比较操作。Mysql能在索引中做最左前缀匹配的LIKE比较，但不能执行以通配符开头的LIKE查询，这种情况下Mysql只能提前数据行的值而非索引值来进行比较。</p>
</blockquote>
<h4 id="普通索引和唯一索引的选择">普通索引和唯一索引的选择</h4>
<blockquote>
<p>普通索引和唯一索引在查找操作的区别，性能上差距几乎没有：</p>
<p>​ 普通索引查找到满足条件的第一个记录后需要查找下一个记录，直到第一个没有满足条件的记录。此时可能遇到从磁盘进行I/O读取的情况。</p>
<p>​ 唯一索引查找到满足条件时直接返回结果。</p>
<p>普通索引和唯一索引在更新操作的区别：</p>
<p>​ 主要和InnoDB的存储有关，在更新时如果数据页在内存中会直接更新，若数据页没有在内存中，在不影响数据一致性的情况下会将更新操作缓存到change buffer中，直到下次访问到这个数据页时再将这些操作写入。change buffer也是可持久化的数据。将change buffer写入数据页的操作叫merge，访问数据页会触发merge，也会有后台线程进行定期merge。</p>
<p>​ 对于唯一索引，由于需要判断唯一性，故每次操作时都需要读取数据页到内存，此时change buffer没有作用。</p>
<p>​ 而对于普通索引，不需要检查唯一性，可以使用change buffer。此时减少了I/O访问。性能更高。</p>
<p>故change buffer的使用场景为：写多读少的场景，因为写多读少往往可以让写操作积累，这样减少的I/O访问次数更多，提升效率。而若是写后立即读的场景，由于读取数据会调用数据页，change buffer不会积累较多操作，无法提升性能，且维护change buffer还需要开销，性能反而变低。</p>
<p>change buffer和redo log的区别：</p>
<p>​ change buffer主要目的在于将磁盘随机读取操作推迟，而redo log的主要目的在于将磁盘随机写入操作推迟。</p>
</blockquote>
<h2 id="锁-1">锁</h2>
<h3 id="共享锁和排他锁">共享锁和排他锁</h3>
<blockquote>
<p>即行锁的读锁和写锁</p>
<table style="width:100%;">
<colgroup>
<col style="width: 9%">
<col style="width: 16%">
<col style="width: 14%">
<col style="width: 29%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>行锁类型</th>
<th>锁功能</th>
<th>锁兼容性</th>
<th>加锁</th>
<th>释放锁</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>共享锁（读锁、S锁）</td>
<td>允许获取共享锁的亊务读数据</td>
<td>与共享锁兼容，与排它锁不兼容</td>
<td>只有 <code>Serializable</code> 隔离级别会默认为：读加共享锁；其他隔离级别下，可显示使用 <code>select...lock in share model</code> 为读加共享锁</td>
<td>在事务提交或回滚后会自动同时释放锁；除了使用 <code>start transaction</code> 的方式显式开启事务，InnoDB 也会自动为增删改査语句开启事务，并自动提交或回滚；(<code>autocommit=1</code>)</td>
</tr>
<tr class="even">
<td>排它锁（写锁、X锁）</td>
<td>允许获取排它锁的事务更新或删除数据</td>
<td>与共享锁不兼容，与排它锁不兼容</td>
<td>在默认的 <code>Reapeatable Read</code> 隔离级别下，InnoDB 会自动为增删改操作的行加排它锁；也可显式使用 <code>select...for update</code> 为读加排它锁</td>
<td>…</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="意向锁和独占锁">意向锁和独占锁</h3>
<blockquote>
<p>这个是在InnoDB引擎层实现的。MDL锁是Server层实现的。</p>
<p>为了兼容行锁和表锁，设置了意向共享锁和意向排他锁。主要目的是方便表级的读写锁的判断，即当表内存在数据用于排他锁时，会上意向排它锁，此时全表读锁即可利用意向排它锁来判断是否可以获得到锁。</p>
<p>​ 意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 x 锁</p>
<p>​ 意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 s 锁</p>
<p>新请求的锁需要兼容旧锁才能被满足。</p>
</blockquote>
<h3 id="全局锁表锁和行锁">全局锁、表锁和行锁</h3>
<blockquote>
<p>全局锁：对整个数据库实例加锁。可以使用Flush tables with read lock命令上锁。一般用于全库逻辑备份。该操作会让数据库变为只读状态。如果不加锁会导致备份时得到的库的视图是不一致的。</p>
<p>若存储引擎支持一致性读，即可重复读隔离，则可以使用mysql官方工具<strong>mysqldump</strong>使用-single-transaction参数，来获取一致性视图，进行备份操作。</p>
<p>表级锁：</p>
<p>​ lock tables ... read/write。可以使用unlock tables主动释放锁，也可以在客户端断开连接时自动释放。</p>
<p>​ MDL(metadata lock)元数据锁，不显示使用而是在访问表时自动上锁，当执行表增删改操作时上MDL读锁，执行表结构修改时上MDL写锁。MDL锁是在语句执行开始时申请，在语句结束后不会马上释放，需要事务提交后才能被释放。这样会导致对表结构修改操作时，若当前存在MDL读锁，且之后的操作也需要获取MDL读锁，后续的操作会被堵塞。</p>
<p>行锁：Mysql行锁是存储引擎自己实现的。并非所有引擎都支持行锁。MyISAM就不支持行锁。而InnoDB实现了行锁。</p>
<p>InnoDB的行锁是两阶段锁，即在事务中，当执行需要锁操作的指令才会自动加锁，但锁的释放则需要等事务结束才释放。</p>
<p>InnoDB的死锁解决策略：</p>
<p>​ 方法1.通过设置innodb_lock_wait_timeout设置等待超时时间。默认值50s</p>
<p>​ 方法2.发起死锁检测，发现死锁后主动回滚死锁链条的某个事务，让其他事务可以继续执行。设置innodb_deadlock_detect为on。一般使用这个。</p>
</blockquote>
<h3 id="record-lock记录锁gap-lock-间隙锁和next-key-临键锁">Record lock记录锁、Gap lock 间隙锁和Next-key 临键锁</h3>
<blockquote>
<p>Record lock记录锁：即添加到记录上的锁。<strong>InnoDB提供的行锁是基于索引的</strong>，若执行计划访问不了索引则会直接使用表锁。记录锁锁住的是索引记录。如果使用索引作为条件命中了记录，那么就是记录锁，被锁住的记录不能被别的事务插入相同的索引键值，修改和删除。我们用<strong>主键或者唯一索引</strong>作为条件<strong>等值</strong>查询的时候，命中记录就是加的记录锁。对于范围查询则会加临键锁。</p>
<p>Gap lock 间隙锁：锁在索引之间或第一个索引前或最后一个索引后，是左开右开区间。无论是等值查询还是范围查询，当使用<strong>唯一索引/非唯一索引没有命中</strong>时加的是间隙锁。</p>
<p>Next-key 临键锁：类似间隙锁，是左开右闭区间。当使用范围查询且使用<strong>非唯一索引命中</strong>的情况使用临键锁。注意当命中后不仅会加临键锁，还会向后加间隙锁。如 表为 1 - 3 - 5，命中3时会加(1,3]区间和(3,5)区间，即最后锁住(1,5)区间。但是需要注意的是锁住的范围还会和主键有关，如锁住的非索引为(2,5)，具体记录为1-2、3-5，即使插入的是2-2也会失败，插入0-2则会成功。</p>
<p>间隙锁之间不冲突，临键锁之间冲突。</p>
</blockquote>
<h3 id="索引和锁">索引和锁</h3>
<blockquote>
<p>InnoDB只有在访问行的时候才会对其加锁，而索引可以减少InnoDB访问的次数，从而减少锁的数量。但如果索引不能过滤掉无效的行，那么InnoDB检索到数据并返回给服务器层后，Mysql才能应用Where子句，此时InnoDB已经锁住了这些行，到适当时释放。Mysql 5.1前InnoDB可以在服务端过滤掉行后释放，之前的版本，只有在事务提交后才能释放。</p>
<p>InnoDB在二级索引上使用共享锁，访问主键索引需要排它锁。</p>
</blockquote>
<h2 id="mysql日志">Mysql日志</h2>
<h3 id="日志redo-log-和-binlog">日志redo log 和 binlog</h3>
<blockquote>
<p>redo log和binlog区别：</p>
<p>​ <strong>redo log是InnoDB特有的日志</strong>，<strong>binlog是Server层特有的日志</strong></p>
<p>​ redo log是物理日志，记录了“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，如“给ID=2这一行的C字段加1”。</p>
<p>​ redo log是循环写的，空间固定且可以被用完；binlog是可以追加写入的，即binlog文件写到一定大小后会切换到下一个，不会覆盖之前的日志。</p>
<p>Mysql在这一部分主要设计思想为先写日志再写磁盘。即WAL(Write Ahead Logging技术)。</p>
<p>redo log的使用：具体而言当存在记录需要更新时，InnoDB引擎会先把记录写入redo log里，并更新内存，此时认为更新完成了。同时InnoDB会在适当时将操作记录更新到磁盘里。但InnoDB的redo log的固定大小的，如可以配置一组4个文件，每个文件大小为1GB，则redo log一共可以记录4GB操作。然后在写入的过程中会记录当前的write_pos和checkpoint即写入的位置和需要擦除的位置。若二者重合则需要提前将记录写到磁盘。</p>
<p>redo log 和binlog是怎么配合的？<strong>两阶段提交</strong>。以更新某个行的某个字段值为1为例：</p>
<p>​ 执行器会找存储引擎去取出对应行，存储引擎会利用树查找，若该行位于内存中，则返回，否则通过磁盘读入再返回给执行器。</p>
<p>​ 执行器拿到数据将值修改后，调用存储引擎接口写入新数据。</p>
<p>​ 存储引擎将数据更新到内存中，记录该操作到<strong>redo log</strong>，此时redo log处于<strong>prepare</strong>状态。然后告知执行器可以随时提交事务。</p>
<p>​ 执行器生成操作的binlog，将binlog写入磁盘。</p>
<p>​ 执行器调用引擎的事务提交接口，引擎将redo log改为<strong>commit</strong>状态，更新完成。</p>
<p>为什么要<strong>两阶段提交</strong>？</p>
<p>​ 若先写binlog再写redo log：假设在写入binlog后，redo log写入前数据库崩溃了。此时事务没有执行结束，没有对数据进行修改，但由于binlog已经记录了导致还原时会多出一次操作。</p>
<p>​ 若先写redo log再写binlog：假设在写入redo log后，binlog写入前数据库崩溃了。此时事务结束了，数据已经被修改，但由于binlog没有记录操作，导致还原时操作被丢失了。</p>
<p>使用两阶段提交后数据库崩溃的恢复过程：</p>
<p>​ 若在写入redo log prepare后 binlog前崩溃，则不会恢复该操作，因为这个操作没有提交。</p>
<p>​ 若在写入redo log prepare、 binlog后，redo log commit前崩溃，则会检查binlog完整性，若完整则恢复。</p>
<p>可以通过innodb_flush_log_at_trx_commit设为1，让每次事务的redo log持久化到磁盘，设置sync_binlog为1，让每次事务的binlog持久化到磁盘。</p>
</blockquote>
<h3 id="mysql的flush">mysql的flush</h3>
<blockquote>
<p>由于数据写入时都是先写入日志，即内存中，并没有进行磁盘写入。而同内存数据页不符的磁盘数据页被称为“脏页”。而同步后的数据页叫“干净页”。</p>
<p>而刷新的触发时机如下：</p>
<p>​ InnoDB的redo log分为write pos 和 checkpoint，当write pos达到checkpoint时需要推进checkpoint，即写入一定的数据到磁盘。</p>
<p>​ 系统内存不足，需要新的内存页。</p>
<p>​ 每隔一段时间，会有线程自动将一定内存页刷入磁盘页。</p>
<p>​ 当数据库关闭时，将数据刷入磁盘页。</p>
</blockquote>
<h3 id="undo-log">undo log</h3>
<blockquote>
<p>即MVCC使用的回滚日志。每次操作后会记录对应的undo操作。</p>
</blockquote>
<h2 id="mysql查询优化">Mysql查询优化</h2>
<h3 id="sql执行顺序">Sql执行顺序</h3>
<blockquote>
<ul>
<li><ol start="7" type="1">
<li><ul>
<li>SELECT</li>
</ul></li>
</ol></li>
<li><ol start="8" type="1">
<li><ul>
<li>DISTINCT <select_list></select_list></li>
</ul></li>
</ol></li>
<li><ol type="1">
<li><ul>
<li>FROM <left_table></left_table></li>
</ul></li>
</ol></li>
<li><ol start="3" type="1">
<li><ul>
<li><join_type> JOIN <right_table></right_table></join_type></li>
</ul></li>
</ol></li>
<li><ol start="2" type="1">
<li><ul>
<li>ON <join_condition></join_condition></li>
</ul></li>
</ol></li>
<li><ol start="4" type="1">
<li><ul>
<li>WHERE <where_condition></where_condition></li>
</ul></li>
</ol></li>
<li><ol start="5" type="1">
<li><ul>
<li>GROUP BY <group_by_list></group_by_list></li>
</ul></li>
</ol></li>
<li><ol start="6" type="1">
<li><ul>
<li>HAVING <having_condition></having_condition></li>
</ul></li>
</ol></li>
<li><ol start="9" type="1">
<li><ul>
<li>ORDER BY <order_by_condition></order_by_condition></li>
</ul></li>
</ol></li>
<li><ol start="10" type="1">
<li><ul>
<li>LIMIT <limit_number></limit_number></li>
</ul></li>
</ol></li>
</ul>
</blockquote>
<h3 id="mysql执行查询的流程">Mysql执行查询的流程</h3>
<blockquote>
<p>1、客户端发送一条查询给服务器。</p>
<p>2、服务器检查查询缓存，若命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。即解析查询语句前，若查询缓存是开启的，Mysql会优先检查这个查询是否命中缓存中的数据。该检查是通过一个对大小写敏感的哈希查找实现的。</p>
<p>3、服务器端执行SQL解析、预处理，再由优化器生成对应的执行计划。</p>
<p>4、Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询。</p>
<p>5、将结果返回给客户端。</p>
<p>即客户端先经过连接器认证 —&gt; 查询缓存 —&gt; 经过分析器 —&gt; 经过优化器 —&gt; 经过执行器 —&gt; 获得结果返回给客户端。</p>
</blockquote>
<h3 id="显示查询执行情况">显示查询执行情况</h3>
<blockquote>
<p>使用SHOW PROFILE</p>
<p>​ 先查看当前profiling是否开启，如果没开启则set profiling = 1开启profile机制。</p>
<p>​ 然后执行对应sql，通过show profiles;查看执行的query情况，找出刚刚执行的sql，通过show profile for query number来展现具体的情况。</p>
<p>使用SHOW STATUS</p>
<p>使用慢查询日志。</p>
</blockquote>
<h3 id="explain查看执行计划">Explain查看执行计划</h3>
<blockquote>
<p>即在sql语句前使用explain查看详细的执行计划。</p>
<figure>
<img src="/2021/03/13/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/Mysql%E7%AA%81%E5%87%BB/explain执行计划.png" alt="explain执行计划"><figcaption aria-hidden="true">explain执行计划</figcaption>
</figure>
<p>ID：表示执行顺序，id相同时自上而下执行，当存在子查询时会出现不同id，id越大越先执行。</p>
<p>select_type：表示查询类型。SIMPLE表示简单查询，即没有union和子查询。 primary最外层查询，即存在子查询时的最外层查询。SUBQUERY子查询。DERIVED表示派生类型，即使用了UNION关键字。UNION表示union关键字后跟随的查询。UNION RESULT表示union的结果。</p>
<p>table：表示该执行计划作用的表。</p>
<p>type：如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">type</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">不访问表或索引即可得出结果</td>
</tr>
<tr class="even">
<td style="text-align: center;">const</td>
<td style="text-align: center;">使用唯一索引查询到一条记录</td>
</tr>
<tr class="odd">
<td style="text-align: center;">system</td>
<td style="text-align: center;">表示仅一行</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>eq_ref</strong></td>
<td style="text-align: center;">使用唯一索引的扫描</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>ref</strong></td>
<td style="text-align: center;">使用非唯一索引或使用唯一索引的前缀扫描</td>
</tr>
<tr class="even">
<td style="text-align: center;">ref_or_null</td>
<td style="text-align: center;">类似ref，但可以额外查找NULL</td>
</tr>
<tr class="odd">
<td style="text-align: center;">index_merge</td>
<td style="text-align: center;">索引合并优化</td>
</tr>
<tr class="even">
<td style="text-align: center;">unique_subquery</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">index_subquery</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>range</strong></td>
<td style="text-align: center;">索引范围扫描，常见于使用了&lt;、&gt;等操作符</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>index</strong></td>
<td style="text-align: center;">索引全扫描</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>all</strong></td>
<td style="text-align: center;">全表扫描</td>
</tr>
</tbody>
</table>
<p>possible_keys：可能使用的索引。</p>
<p>key：实际使用的索引。</p>
<p>key_len：需要被使用索引的长度。</p>
<p>ref：表示查找时使用的列/常量，常见const（常量），func，NULL，字段名（例：film.id）。</p>
<p>rows：预估需要扫描的行数。</p>
<p>filtered：表示返回结果占需要读取行数的百分比。</p>
<p>extra：执行计划的补充说明。具体如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">extra</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>Using filesort</strong></td>
<td style="text-align: center;">对数据进行了外部索引排序，而不是按索引顺序排序，表示mysql无法利用索引排序</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Using temporary</strong></td>
<td style="text-align: center;">使用临时表保存中间结果，常见于order by和group by</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Using index</strong></td>
<td style="text-align: center;">表示只需要访问索引树就可以获取值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Using where</strong></td>
<td style="text-align: center;">使用where过滤</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Using join buffer</td>
<td style="text-align: center;">使用了连接缓存</td>
</tr>
<tr class="even">
<td style="text-align: center;">impossible where</td>
<td style="text-align: center;">where字句值总为false</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Using index condition</strong></td>
<td style="text-align: center;">表示可以使用索引，但还需要进行回表操作</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="mysql-schema设计">Mysql Schema设计</h3>
<h4 id="选择优化的数据类型">选择优化的数据类型</h4>
<blockquote>
<p>更小的通常更好：尽量使用可以存储数据的最小数据类型。</p>
<p>简单就好：如整型比字符操作代价更低。举例：使用Mysql存储日期和时间，而不是使用字符串。使用整型来存储IP地址。</p>
<p>尽量避免NULL：最好指定列为NOT NULL，除非真的需要NULL值。因为查询中包含可为NULL的列对应Mysql来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。</p>
</blockquote>
<h4 id="设计中的陷阱">设计中的陷阱</h4>
<blockquote>
<p>太多的列：</p>
<p>太多的关联：</p>
<p>全能的枚举：将没有必要设计成枚举的列设计成枚举，每次修改时都需要用到ALTER TABLE</p>
<p>不要全盘否定NULL：有时NULL会比特定的值好用，避免代码复杂。</p>
</blockquote>
<h3 id="慢查询优化">慢查询优化</h3>
<blockquote>
<p>1、已经执行完成的SQL。show variables like ‘slow_query_log’；</p>
<p>​ 查看慢查询是否开启。</p>
<p>​ 查看慢查询的日志存放位置。 show variables like ‘slow_query_log_file’；</p>
<p>​ 查看慢查询的时间。show variables like ‘long_query_time’；</p>
<p>如何分析日志：</p>
<p>​ 使用mysqldumpslow工具：执行mysqldumpslow -s r -t 10 日志路径</p>
<p>​ 还可以使用pt-query-digest</p>
<p>2、正在执行的SQL</p>
<p>​ show processlist；</p>
<p>主要分析步骤：</p>
<p>​ 1、确认应用程序是否在检索大量超过需要的数据。即可能访问了太多的行/列。</p>
<p>​ 2、确认Mysql服务器是否在分析大量超过需要的数据行。</p>
</blockquote>
<h3 id="是否向数据库请求了不需要的数据">是否向数据库请求了不需要的数据？</h3>
<blockquote>
<p>判断是否查询了不需要的记录。</p>
<p>​ 如是否存在向Mysql查询了大量记录，然后获取前面N行后关闭结果集。如果存在这种情况，可以在查询后添加LIMIT。</p>
<p>多表关联时返回全部列而非具体需要的列。</p>
<p>是否总是取出全部列？即使用SELECT *操作。</p>
<p>是否重复查询相同的数据？若存在则使用缓存机制。</p>
</blockquote>
<h3 id="mysql是否扫描额外的记录">Mysql是否扫描额外的记录？</h3>
<blockquote>
<p>Mysql开销的三个指标：响应时间、扫描行数、返回行数。</p>
<p>响应时间：包括服务时间和排队时间。服务时间指数据库处理这个查询真正花了多长时间。排队时间指服务器因为等待某些资源而没有真正执行查询的时间(如等待I/O操作，等待行锁等)。</p>
<p>查看扫描的行数和返回的行数。</p>
<p>查看扫描的行数和访问类型。</p>
<p>​ 通过EXPLAIN查看。在Mysql使用如下三种方式应用WHERE条件，从好到坏依次为：</p>
<p>​ 在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</p>
<p>​ 使用索引覆盖扫描(在Extra列出现Using index)来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在Mysql服务器层完成的，但无须回表操作。</p>
<p>​ 从数据表中返回数据，然后过滤不满足条件的记录(在Extra列出现Using Where)。这在Mysql服务器层完成，Mysql需要从数据表读出记录再过滤。</p>
<p>当发现查询需要扫描大量数据但只返回少数列时，可以尝试以下方式优化：</p>
<p>​ 使用索引覆盖扫描，把所有需要用的列都放入索引中，这样存储引擎无须回表即可返回结果。</p>
<p>​ 改变库表结构，如使用单独的汇总表。</p>
<p>​ 重新复杂的查询，让Mysql优化器可以以更优化的方式执行查询。</p>
</blockquote>
<h3 id="重构查询的方式">重构查询的方式</h3>
<blockquote>
<p><strong>将一个复杂查询拆分为多个简单查询</strong>。</p>
<p><strong>切分查询</strong>：如删除旧数据时，如果采用一个大语句删除，会一次锁住许多数据、占满事务日志、耗尽系统资源、阻塞小而重要的查询。可以选择一次删除比较少的数目，分多次删除。</p>
<p><strong>分解关联查询</strong>：即将关联查询改为对每个表进行单表查询，然后将结果在应用程序中进行关联。</p>
<p>​ 优点：让缓存的效率更高。</p>
<p>​ 将查询分解后执行单个查询可以减少锁的竞争。</p>
<p>​ 在应用层做关联可以更容易对数据库进行拆分，更容易做到高性能和可拓展。</p>
<p>​ 查询本身的效率可以有所提升。</p>
<p>​ 减少冗余记录的查询，在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复访问一部分数据。</p>
<p>​ 相当于应用中实现了哈希关联，而不是使用Mysql的嵌套循环关联。</p>
</blockquote>
<h2 id="mysql集群分布式">Mysql集群/分布式</h2>
<h3 id="分库分表">分库分表</h3>
<blockquote>
<p>垂直分表：即按列拆分数据表，一般是将大表按列拆分成多个表。</p>
<p>垂直分库：即将一个数据库中的业务按不同类型进行拆分，拆分到多个数据库中。</p>
<p>水平分表、分库：即由于单表/库内的数据过多，需要对数据按行拆分到多个表/库中。</p>
</blockquote>
<h3 id="水平分库分表的方式及问题">水平分库、分表的方式及问题</h3>
<blockquote>
<p>主要方式分为：离散映射和连续映射。</p>
<p>​ 离散映射：利用取模函数，将数据均匀地划分到每个表/库，这样良好地解决了热点问题，但带来了数据迁移和历史数据问题。</p>
<p>​ 连续映射：即按id或创建时间等连续范围进行映射，这样可以避免数据迁移问题，但带来了热点问题。</p>
<p>数据迁移问题：即分库后的数据再次达到上限需要二次分库。</p>
<p>热点问题：由于数据是连续分库的，当达到库上限时虽然无须数据迁移只需新建库，但这样会导致所有的插入操作都集中到新库中。</p>
<p>具体水平分库、分表过程：</p>
<p>​ 假设开始时仅一个数据库DB0，两个表T0、T1。使用id%2进行插入表。</p>
<p>​ 当单数据库达到一定数据量如1kw时，增加一个数据库，将其中一个表移动到新库，对于1kw内的数据通过%2分布到两个库的旧表中，1kw后的数据分布到两个库的新表中。</p>
<p>​ 如果还达到上限如2kw，则将两个库中的两个表再取出一个表移动到两个新库中，然后对应2kw内的数据按之前的方法划分到4个库中，对应2kw后的数据按照%4分布到新的4个表中。</p>
</blockquote>
<h3 id="数据迁移">数据迁移</h3>
<blockquote>
<p>最简单的方式：停机迁移。</p>
<p>无法停机则使用双写迁移。即同时写两个库，一个老库，一个新库。主要分为三步：</p>
<p>​ 导入历史数据阶段：数据库双写，查询走老数据库，通过定时任务补全新老数据差异。</p>
<p>​ 新老数据无差异阶段：数据库双写，查询走新数据库。</p>
<p>​ 稳定运行阶段，移除旧数据库。</p>
</blockquote>
<h3 id="数据库join操作">数据库join操作</h3>
<blockquote>
<p>对于分库后join操作可以使用的解决方法：</p>
<p>​ <strong>全局表</strong>：对于系统各模块都依赖的表可以在每个数据库中都存储一份。</p>
<p>​ <strong>字段冗余</strong>：对于常使用的字段，各模块表都冗余备份一次。但是难以保证数据一致性。</p>
<p>​ <strong>系统层面组装</strong>：在系统层面，调用不同模块的组件或服务，获取数据并拼接。</p>
</blockquote>
<h2 id="tips">Tips</h2>
<blockquote>
<p>InnoDB存储引擎处理死锁的方式是，将持有最少行级排他锁的事务进行回滚。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ye</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">130k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:59</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
